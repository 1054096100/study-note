# fork和exec

Unix下某个进程的内存分成三部分：代码段，堆栈段，数据段。代码段用来存放程序运行的代码，堆栈段用来存放子程序的局部变量，数据段用来存放全局变量

## fork()

​一个程序一调用fork函数，系统就为一个新的进程准备了前述三个段，首先，**系统让新的进程与旧的进程使用同一个代码段**，因为它们的**程序还是相同的**，对于数据段和堆栈段，系统则复制一份给新的进程，这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，**虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了**(在shell里用ps命令，可以看到2个独立运行的进程。通常你 kill掉1个，不会影响另1个的运行)，也就是说，它们之间不再共享任何数据了

对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零，这样，对于程序，只要判断fork函数的返回值，就知道自己是处于父进程还是子进程中

父进程和子进程间的**通信**有多种方法，最常见的是信号，另外还有管道，Socket，消息队列等

父进程和子进程间的**共享数据**的办法，可以用线程或共享内存

### fork( )

简单一句话，`fork()`的做法就是`拷贝`父进程的上下文，然后再从父进程中分离出来。其实可能大部分程序员对 fork() 的用法是：创建子进程，然后父子进程使用 pipe 通信。

### fork 复制的上下文与父进程的关系

在实际使用中，确实就按照上文而言，fork() 之后的子进程对父进程是`拷贝`关系。也就是说，子进程对`大多数`变量的操作，都是不会影响父进程的。

**但是文件描述符等涉及操作系统层面的全局资源需要注意：这些仅仅是上下文在内存中的位置不同，但是它们底层所指向的资源是共享的，操作时需要注意**。不过事实上，**这也是父子进程使用 pipe 互相通信的原理基础**。

### fork 复制上下文的原理

我被问过一个问题：“`fork()` 调用时要拷贝上下文，这么做在大进程中调用的时候是不是效率很低？”

Linux 作为开源运动的集大成之作，显然不会那么蠢。事实上，在Linux中，对fork进行了优化，调用时采用**写时复制** (COW，copy on write）的方式，在系统调用fork生成子进程的时候，**不马上为子进程复制父进程的资源，而是在遇到“写入”（对资源进行修改）操作时才复制资源**。

## exec()

​	**对于exec系列函数一个进程一旦调用exec类函数，它本身就“死亡”了**，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，**并为新程序分配新的数据段与堆栈段**，唯一留下的，就是进程号，也就是说，**对系统而言，还是同一个进程，不过已经是另一个程序了**

