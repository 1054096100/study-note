# TCP和UDP

## TCP

TCP在数据包接收无序、丢失或在交付期间被破坏时，**负责数据恢复**。**它通过为其发送的每个数据包提供一个序号来完成此恢复**。记住，较低的网络层会将每个数据包视为一个独立的单元，因此，**数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分**。

为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。**如果网络拥塞，这种重新传送将导致发送的数据包重复**。但是，**接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它**。

## UDP

### 传输方式

面向报文（数据发送方式是一份一份的）

#### UDP 报文大小的影响因素

- [1] UDP协议本身，UDP协议中有16位的UDP报文长度，那么UDP报文长度不能超过2^16=65536；
- [2] 以太网(Ethernet)数据帧的长度，数据链路层的MTU(最大传输单元)；
- [3] socket的UDP发送缓存区大小。

#### 数据包最大长度

根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是2^16-1的个字节。由于UDP包头占8个字节，而在IP层进行封装后的IP包头占去20字节，所以这个是UDP数据包的最大理论长度是2^16 - 1 - 8 - 20 = 65507字节。

如果发送的数据包超过65507字节，send或sendto函数会错误码1，当然啦，一个数据包能否发送65507字节，还和UDP发送缓冲区大小相关，如果发送缓冲区小于65507字节，在发送一个数据包为65507字节的时候，send或sendto函数会错误码1。

#### 数据包理想长度

UDP是不可靠的传输协议，为了减少 UDP 包丢失的风险，我们最好能控制 UDP 包在下层协议的传输过程中不要被切割。相信大家都知道MTU这个概念。 **MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系**。由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64字节，最大不能超过1518字节，**对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧**，一般的以太网转发设备会**丢弃这些数据帧**。由于以太网 EthernetII 最大的数据帧是1518字节，除去以太网帧的帧头14 Bytes和帧尾CRC校验部分4 Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500字节这个值我们就把它称之为MTU

在下层数据链路层最大传输单元是1500字节的情况下，要想IP层不分包，那么UDP数据包的最大大小应该是1500字节 – IP头(20字节) – UDP头(8字节) = 1472字节。不过鉴于Internet上的**标准MTU值为576字节**，所以建议**在进行Internet的UDP编程时，最好将UDP的数据长度控制在 (576-8-20)548字节以内**

### 数据包的发送和接收问题

#### UDP的通信有界性

在阻塞模式下，UDP的通信是**以数据包作为界限**的，**即使server端的缓冲区再大也要按照client发包的次数来多次接收数据包，server只能一次一次的接收，client发送多少次，server就需接收多少次。**

#### UDP数据包的无序性和非可靠性

client依次发送1、2、3三个UDP数据包，server端先后调用3次接收函数，可能会依次收到3、2、1次序的数据包，收包可能是1、2、3的任意排列组合，也可能丢失一个或多个数据包。

#### UDP数据包的接收

##### 情况一

client发送两次UDP数据，第一次 500字节，第二次300字节，server端阻塞模式下接包，第一次recvfrom( 1000 )，收到是 1000，还是500，还是300，还是其他？

由于UDP通信的有界性，接收到只能是500**或**300（因为UDP的无序性和非可靠性，接收到可能是300，也可能是500），也可能一直阻塞在recvfrom调用上，直到超时返回(也就是什么也收不到)。

##### 情况二

在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，server端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？

由于UDP通信的有界性，第一次recvfrom( 200)将接收第一个500字节的数据包，但是因为用户空间buf只有200字节，于是只会返回前面200字节，剩下300字节将丢弃。第二次recvfrom( 1000)将返回300字节，第三次recvfrom( 1000)将会阻塞。

#### UDP包分片问题

如果MTU是1500，Client发送一个8000字节大小的UDP包，那么Server端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到1500，还是8000。如果某个IP分片丢失了，recvfrom(9000)，又返回什么呢？

根据UDP通信的有界性，在buf足够大的情况下，接收到的一定是一个完整的数据包，UDP数据在下层的分片和组片问题由IP层来处理，提交到UDP传输层一定是一个完整的UDP包，那么recvfrom(9000)将返回8000。如果某个IP分片丢失，udp里有个CRC检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以UDP是不可靠的传输协议，那么recvfrom(9000)将阻塞。

#### UDP丢包问题

在不考虑UDP下层IP层的分片丢失，CRC检验包不完整的情况下，造成UDP丢包的因素有哪些呢？

##### UDP socket缓冲区满造成的UDP丢包

##### UDP socket缓冲区过小造成的UDP丢包

##### ARP缓存过期导致UDP丢包

#### UDP的冗余传输方案

![](http://oklbfi1yj.bkt.clouddn.com/TCP%E5%92%8CUDP/1.jpg)

### UDP真的比TCP要高效吗

实际上UDP在大多情况下并不一定比TCP高效，TCP发展至今天，为了适应各种复杂的网络环境，其算法已经非常丰富，协议本身经过了很多优化，如果能够合理配置TCP的各种参数选项，那么在多数的网络环境下TCP是要比UDP更高效的。

#### 影响UDP高效的因素

##### 无法智能利用空闲带宽导致资源利用率低

一个简单的事实是UDP并不会受到MTU的影响，MTU只会影响下层的IP分片，对此UDP一无所知。在极端情况下，UDP每次都是发小包，包是MTU的几百分之一，这样就造成UDP包的有效数据占比较小(UDP头的封装成本)；或者，UDP每次都是发巨大的UDP包，包大小MTU的几百倍，这样会造成下层IP层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个UDP包的无效。由于网络情况是动态变化的，UDP无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而TCP有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，TCP的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。

##### 无法动态调整发包

由于**UDP没有确认机制，没有流量控制和拥塞控制**，这样在网络出现拥塞或通信两端处理能力不匹配的时候，UDP并不会进行调整发送速率，从而导致大量丢包。**在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞**。更加严重的是，UDP的无秩序性和自私性，一个疯狂的UDP程序可能会导致这个网络的拥塞，挤压其他程序的流量带宽，导致所有业务质量都下降。

##### 改进UDP的成本较高

UDP编程可是比TCP要难不少的，考虑到改造成本，为什么不直接用TCP呢？

### UDP协议的正确使用场合

#### 高通信实时性要求和低持续性要求的场景下

#### 多点通信的场景下

一个典型的场景是多人实时音视频通信，这种场景下实时性要求比较高，可以容忍一定的丢包率。比如：对于音频，对端连续发送p1、p2、p3三个包，另一端收到了p1和p3，在没收到p2的保持p1的最后一个音（也是为什么有时候网络丢包就会听到嗞嗞嗞嗞嗞嗞…或者卟卟卟卟卟卟卟卟…重音的原因），等到到p3就接着播p3了，不需要也不能补帧，一补就越来越大的延时。对于这样的场景就比较合适用UDP了，如果采用TCP，那么在出现丢包的时候，就可能会出现比较大的延时。

## TCP与UDP区别

UDP和TCP协议的主要区别是两者在如何实现信息的可靠传递方面不同。TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。 与TCP不同，UDP协议并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把UDP协议称为不可靠的传输协议。相对于TCP协议，UDP协议的另外一个不同之处在于如何接收突发性的多个数据报。不同于TCP，UDP并不能确保数据的发送和接收顺序。事实上，UDP协议的这种乱序性基本上很少出现，通常只会在网络非常拥挤的情况下才有可能发生。 
既然UDP是一种不可靠的网络协议，那么还有什么使用价值或必要呢？其实不然，在有些情况下UDP协议可能会变得非常有用。因为UDP具有TCP所望尘莫及的速度优势。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观**UDP，由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证**。



















































