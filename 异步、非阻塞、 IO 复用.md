# 异步、非阻塞、 IO多路复用

以小明去买奶茶为例讲解异步、非阻塞、 IO 复用。

## 同步与异步

### 同步与异步的理解

同步与异步的重点在**消息通知的方式上**，也就是调用结果通知的方式。 
同步：当一个同步调用发出去后，调用者要**一直等待调用结果的通知后（这就是获取消息通知的方式）**，才能进行后续的执行。 
异步：当一个异步调用发出去后，调用者不能立即得到调用结果的返回。 
异步调用，要想获得结果，一般有两种方式：

```
主动轮询异步调用的结果;
被调用方通过callback来通知调用方调用结果。
```

### 生活中的例子

#### 同步买奶茶

小明点单交钱，然后**等着拿奶茶**；异步买奶茶：小明点单交钱，店员给小明一个小票，等小明奶茶做好了，再来取。

异步买奶茶: 小明要想知道奶茶是否做好了，有两种方式：

```
小明主动去问店员，一会就去问一下：“奶茶做好了吗？”…直到奶茶做好。这叫轮训。
等奶茶做好了，店员喊一声：“小明，奶茶好了！”，然后小明去取奶茶。这叫回调。
```

## 阻塞与非阻塞

### 阻塞与非阻塞的理解

阻塞与非阻塞的重点在于进/线程等待消息时候的行为，**也就是在等待消息的时候，当前进/线程是挂起状态，还是非挂起状态**。

### 阻塞调用

在发出去后，在消息返回之前，**当前进/线程会被挂起*，直到有消息返回，当前进/线程才会被激活**。

### 非阻塞调用

在发出去后，**不会阻塞当前进/线程，而会立即返回**。

### 生活中的例子

#### 阻塞买奶茶

小明点单交钱，干等着拿奶茶，什么事都不做。

#### 非阻塞买奶茶

小明点单交钱，等着拿奶茶，等的过程中，时不时刷刷微博、朋友圈。

## 总结

1、同步与异步，重点在于消息通知的方式;

2、阻塞与非阻塞，重点在于等消息时候的行为。

### 4种组合方式

1、同步阻塞：小明在柜台干等着拿奶茶；

2、同步非阻塞：小明在柜台边刷微博边等着拿奶茶；

3、异步阻塞：小明拿着小票啥都不干，一直等着店员通知他拿奶茶；

4、异步非阻塞：小明拿着小票，刷着微博，等着店员通知他拿奶茶。

## I/O多路复用

### select系统调用

select可以允许调用者通知预期的read是否会阻塞。若有这个调用，那么库过程read就可以被新的操作替代，首先进行select调用，然后只有在安全的情形下（即不会阻塞）才进行read调用。

select创建了3个文件描述符**集**（fd_set）并**拷贝到内核中**，分别监听读、写、异常动作。select可以**监听的文件描述符受到单个进程所能打开的fd的限制**，默认为1024。**采用轮询方式，遍历所有的fd**，最后返回一个文件描述符是否就绪的mask掩码，并根据mask掩码**给fd_set赋值**。**将之前的fd_set拷贝传出到用户态并返回就绪的文件描述符的总个数**。**用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断**。应用程序索引就绪文件描述符的时间复杂度是O(n)。**再次调用select时，需要将新的fd_set监听文件描述符拷贝传入进内核**。select**只能**工作在相对较低下的**LT模式**

### poll系统调用

**将struct pollfd结构体数组拷贝到内核中进行监听**。poll采用链表poll_list来进行文件描述符的存储，因此**poll可以监听的文件描述符数为系统可以打开的最大文件描述符数（65535）**。**采用轮询方式，查询每个fd的状态**，如果就绪，**内核就修改fd对应的revents的值，而events成员保持不变，因此下次调用poll时，应用程序无需重置pollfd类型的事件集参数**。将之前传入的struct pollfd结构体数组拷贝传出到用户态，并返回就绪文件描述符的总个数。**用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判读**。应用程序索引就绪文件描述符的时间复杂度是O(n)。poll**只能**工作在相对较低下的**LT模式**。

### epoll系统调用

**执行epoll_create()函数会在内核创建一颗红黑树**rb_node以及**就绪链表rdllist(存放已经就绪的文件描述符)**，监听的文件描述符数为系统可以打开的最大文件描述符数（65535）。接着用户执行的epoll_ctl()函数**将epoll_event结构体拷贝传入内核，内核会在红黑树上添加相应的结点，并注册回调函数ep_poll_callback()**，**内核在检测到某文件描述符可读/可写时就调用回调函数callback，该回调函数将文件描述符放入就绪链表rdllist中**。epoll_wait()函数只需要观察rdllist中有无就绪的文件描述符即可，**内核将就绪的文件描述符事件复制到传入的poll_event结构体数组中返回给用户空间，所以用户只用遍历依次处理即可**，即应用程序索引就绪文件描述符的时间复杂度是O（1）。这里**返回的文件描述符是通过mmap让内核和用户空间共享同一块内存传递的，减少了不必要的拷贝。再次调用epoll系统调用，不用重建红黑树，直接沿用已经存在的即可**。**epoll支持ET模式**，**当内核将该事件通知给用户后，用户必须立即处理**，这样就**减少了可读、可写和异常事件被触发的次数**。

它能显著提高程序**在大量并发连接中只有少量活跃的情况**下的系统CPU利用率

#### epoll用法

```c++
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);
```

首先要调用epoll_create建立一个epoll fd。参数size是内核保证能够正确处理的最大文件描述符数目（现在内核使用红黑树组织epoll相关数据结构，不再使用这个参数）。

epoll_ctl可以操作上面建立的epoll fd，例如，将刚建立的socket fd加入到epoll中让其监控，或者把 epoll正在监控的某个socket fd移出epoll，不再监控它等等。

epoll_wait在调用时，在给定的timeout时间内，当在监控的这些文件描述符中的某些文件描述符上有事件发生时，就返回用户态的进程。

#### epoll为什么高效（相比select）

1、仅从上面的调用方式就可以看出epoll比select/poll的一个优势：select/poll每次调用都要传递所要监控的所有fd给select/poll系统调用（这意味着每次调用都要将fd列表从用户态拷贝到内核态，当fd数目很多时，这会造成低效）。而每次调用epoll_wait时（作用相当于调用select/poll），不需要再传递fd列表给内核，因为已经在epoll_ctl中将需要监控的fd告诉了内核（epoll_ctl不需要每次都拷贝所有的fd，只需要进行增量式操作）。所以，在调用epoll_create之后，内核已经在内核态开始准备数据结构存放要监控的fd了。每次epoll_ctl只是对这个数据结构进行简单的维护。

2、此外，内核使用了slab机制，为epoll提供了快速的数据结构：

在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控的fd。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的fd，这些fd会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。 

3、epoll的第三个优势在于：当我们调用epoll_ctl往里塞入百万个fd时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的fd给我们用户。这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。而且，通常情况下即使我们要监控百万计的fd，大多一次也只返回很少量的准备就绪fd而已，所以，epoll_wait仅需要从内核态copy少量的fd到用户态而已。那么，这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把fd放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个fd的中断到了，就把它放到准备就绪list链表里。所以，当一个fd（例如socket）上有数据到了，内核在把设备（例如网卡）上的数据copy到内核中后就来把fd（socket）插入到准备就绪list链表里了。



如此，一颗红黑树，一张准备就绪fd链表，少量的内核cache，就帮我们解决了大并发下的fd（socket）处理问题。

1.执行epoll_create时，创建了红黑树和就绪list链表。

2.执行epoll_ctl时，如果增加fd（socket），则检查在红黑树中是否存在，存在立即返回，不存在则添加到红黑树上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪list链表中插入数据。

3.执行epoll_wait时立刻返回准备就绪链表里的数据即可。

### 为什么epoll比select和poll更高效？

#### （1）减少了用户态和内核态之间文件描述符的拷贝

select创建了3个文件描述符集（fd_set）并**拷贝到内核中**，分别监听读、写、异常事件。内核分配相关数据结构（fd_set_bits），内核在检测到有就绪事件后，就修改用户传进来的fd_set的值以告知用户有就绪的文件描述符。将文件描述符fd_set**拷贝传出到用户态**并返回就绪的文件描述符的总个数。**内核删除和文件描述符相关的数据结构**，**由于内核修改了用户传进来的fd_set文件描述符集，下次调用select前必须要重置fd_set**，然后重新传给内核，**内核再重新拷贝一份，重新分配数据结构**。

poll系统调用将struct pollfd结构体数组拷贝到内核中进行监听，内核分配相关数据结构poll_list，用来存储监听的文件描述符，然后调用所有fd对应的poll(将current挂到各个fd对应的设备等待队列上)，**内核在检测到有就绪事件后，就修改fd对应的revents的值用来告知用户有就绪的文件描述符，而events成员保持不变，因此下次调用poll时，应用程序无需重置pollfd类型的事件集参数**。将之前传入的struct pollfd结构体数组拷贝传出到用户态，并返回就绪文件描述符的总个数。**内核删除和文件描述符相关的数据结构**，下次调用poll需要将struct pollfd重新传给内核，**内核再重新拷贝一份，重新分配数据结构**。

执行epoll_create()函数会**在内核创建一颗红黑树rb_node以及就绪链表rdllist(存放已经就绪的文件描述符)**，接着用户执行的epoll_ctl()函数将epoll_event结构体拷贝传入内核，内核会在红黑树上添加相应的结点，**内核将就绪的文件描述符事件复制到传入的poll_event结构体数组中返回给用户空间，系统调用在返回时采用mmap共享存储区，需要拷贝的次数大大减少**。**由于epoll创建的有关文件描述符的数据结构本身就存在于内核态中。下一次调用epoll系统调用时，不需要再次拷贝用户空间所要监听的文件描述符，也不需要重新构建红黑树和就绪链表等相关数据结构**，直接沿用已经存在的数据结构

#### （2）减少了对就绪文件描述符的遍历

select和poll采用轮询的方式来检查文件描述符是否处于就绪状态，并且**用户并不知道有哪些文件描述符处于就绪态，需要遍历查找就绪文件描述符**。

而epoll采用回调机制。

#### （3）select和poll只支持LT模式，而epoll支持高效的ET模式

LT模式（电平触发）：LT模式是默认的工作模式，当检测到文件描述符上有事件发生并将此事件通知给应用程序，应用程序**可以不立即处理该事件，下次调用会再次响应应用程序并通知此事件**。

**ET模式（边沿触发）**：当检测到文件描述符上有事件发生并将此事件通知给应用程序，应用程序**必须立即处理该事件，如果没处理或者没处理完，下次调用不会再响应应用程序并通知此事件**。

ET模式很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高，**epoll工作在ET模式的时候，必须使用非阻塞的套接字**，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。







































































































