# 右值引用

## 左值和右值

区分左值和右值的一个简单办法是：**看能不能对表达式取地址，如果能，则为左值，否则为右值**。

例如：

```c++
int i = getVar();
```

从getVar()函数获取一个整形值（右值），然而，这行代码会产生几种类型的值呢？答案是会产生两种类型的值，一种是左值i，一种是函数getVar()返回的临时值，**这个临时值在表达式（即`int i = getVar();`）结束后就销毁了**，而左值i在表达式结束后仍然存在，这个临时值就是右值，具体来说是一个纯右值，右值是不具名的。

所有的具名变量或对象都是左值，而匿名变量则是右值，比如，简单的赋值语句：

```c++
int i = 0;
```

在这条语句中，i 是左值，0 是字面量，就是右值。在上面的代码中，i 可以被引用，0 就不可以了。具体来说上面的表达式中等号右边的0是纯右值（prvalue），在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值。

## 左值引用

首先复习一下左值引用，c++98/03中的左值引用是这样的：

```c++
int i = 0;
int& j = i; // 这里的i是一个左值，所以我们把这种操作叫作左值引用
```

这里的int&是对左值进行绑定（但是int&却不能绑定右值）

也就是说，不能有一下操作：

```c++
int& j = 0;
```

## 右值引用

相应的，对右值进行绑定的引用就是右值引用，他的语法是这样的A&&，通过双引号来表示绑定类型为A的右值。通过&&我们就可以很方便的绑定右值了，比如我们可以这样绑定一个右值：

```c++
int&& i = 0; // 因为0是一个右值，所以我把这种操作叫作右值引用
```

这里我们绑定了一个右值0。

右值引用是C++11中新增加的一个很重要的特性，他主是要用来**解决**C++98/03中遇到的两个问题，第一个问题就是**临时对象非必要的昂贵的拷贝操作**，第二个问题是在模板函数中如何按照参数的实际类型进行转发。通过引入右值引用，很好的解决了这两个问题，改进了程序性能。

再来看看一行代码：

```c++
T&& k = getVar();
```

这行代码和`int i = getVar();`很像，只是多了“&&”，这就是右值引用。我们知道左值引用是对左值的引用，那么，对应的，对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值。

这里，getVar()产生的临时值不会像`T&& k = getVar();`那样，在表达式结束之后就销毁了，而是会被“续命”，**它的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长**。









































