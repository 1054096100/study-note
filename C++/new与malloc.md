# new与malloc

## 1. 申请的内存所在位置

new 操作符从**自由存储区（free store）**上为对象动态分配内存空间，而malloc函数从**堆**上动态分配内存。**自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存**，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

那么**自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节**。**自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存**。

## 2.返回类型安全性

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合**类型安全**性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。

## 3.内存分配失败时的返回值

new内存分配失败时，会**抛出bac_alloc异常**，它**不会返回NULL**；malloc分配内存失败时返回NULL。在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：

```c++
int *a  = (int*)malloc(sizeof(int));
if(NULL == a) {
    ...
}
else {
    ...
}
```

从C语言走入C++阵营的新手可能会把这个习惯带入C++：

```c++
int* a = new int();
if(NULL == a) {
    ...
}
else {   
    ...
}
```

实际上这样做**一点意义也没有**，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：

```c++
try {
    int* a = new int();
}
catch(bad_alloc) {
    ...
}
```

## 4.是否需要指定内存大小

使用**new操作符**申请内存分配时无须指定内存块的大小，**编译器会根据类型信息自行计算**，而malloc则需要显式地指出所需内存的尺寸。

```c++
class A{...}
A* ptr = new A;
A* ptr = (A*)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A);
```

当然了，我**这里使用malloc来为我们自定义类型分配内存是不怎么合适的**，请看下一条。

## 5.是否调用构造函数/析构函数

使用new操作符来分配对象内存时会经历三个步骤：

- 第一步：调用operator new 函数（对于数组是operator new()）分配一块足够大的，**原始**的，未命名的内存空间以便存储特定类型的对象。
- 第二步：编译器运行相应的**构造函数**以构造对象，并为其传入初值。
- 第三部：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：

- 第一步：调用对象的析构函数。
- 第二步：编译器调用operator delete或operator delete()）函数释放内存空间。

总之来说，**new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会**。

## 6.对数组的处理

C++提供了new[]与delete[]来专门处理数组类型:

```c++
A* ptr = new A[10];//分配10个A对象
```

使用new[]分配的内存必须使用delete[]进行释放：

```c++
delete[] ptr;
```

至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小。

## 7.new与malloc是否可以相互调用

operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。

## 8.是否可以被重载

operator new / operator delete可以被重载，而malloc/free**不允许重载**。

## 9. 能够直观地重新分配内存

使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

new没有这样直观的配套设施来扩充内存。

## 总结

当然，malloc并不是说比不上new，它们各自有适用的地方。**在C++这种偏重OOP的语言，使用new/delete自然是更合适的**（因为有很多自定义类型，使用malloc不方便）。

















