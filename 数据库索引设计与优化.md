# 数据库索引设计与优化

## 2、表和索引结构

### 索引页和表页

表和索引行都被储存在页中。缓冲池和I/O活动都是基于页的，例如一次将一个完整的也读取到缓冲池。这意味着一次I/O会读入多条记录到缓冲池，而不仅仅是一条。其实，一次I/O可以读入多个页到缓冲池中。

### 索引行

索引行在评估访问路径的时候是一个非常有用的概念。对于一个唯一索引，例如表CUST上的主键索引CNO，一个索引行等同于叶子页中的一个索引条目。**字段的值从表中复制到索引上，并加上一个指向表中记录的指针**。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/1.png)

### 表行

图2.1中的每个索引行都指向表中相对应的一行记录，指针通常标识了记录所存放的页以及它在页中的位置。表中的每一行除了储存行的字段之外，还包含了一些控制信息用于定义行并帮助DBMS处理插入或删除操作。

显然，表中记录的顺序只能按照表上某一个索引的顺序来组织。如果通过表上其他的索引来访问这张表，那么表中相应的记录将不会按照与索引条目的顺序存储。例如，第一条索引记录有可能指向页17，下一条索引记录有可能指向页2，再下一条可能指向页85，等等。如此一来，虽然索引的处理顺序仍然是顺序且高效的，但是表的处理却是随机且低效的。

### 缓冲池和磁盘I/O

关系型数据库管理系统最重要的一个目标是**确保表或者索引中的数据是随时可用的（也就是说当我需要使用的时候，我可以里面得到它，也就是说得到的速度要快）**。为了尽可能地实现这个目标，我们**使用内存中的缓存池来最小化磁盘活动**。每个DBMS都会根据对象类型（表或索引）以及页的大小拥有多个缓冲池。每个缓冲池都足够大，大到可以存放许多页，可能是成千上万的页。**缓冲池管理器将尽力确保经常使用的数据被保存在池中，以避免一些不必要的磁盘读**。

### 从磁盘驱动器进行的随机I/O

图2.2展示了等待一个页从磁盘驱动器读取至缓冲池所需的巨大成本。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/2.png)

我们必须记住一个页包含了多条记录，我们可能需要该页上所有的行，或者其中一部分行，又或者只需要其中的某一行 —— 但所花的成本都是相同的，约10ms。如果磁盘驱动器被重度使用，那么这一速度将大幅降低，因为需要等待磁盘空闲下来。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/3.png)

### 从磁盘服务器缓存进行的读取

现今的磁盘服务器都提供自己的内存（或缓冲区）以降低响应时间上的巨大成本。图2.4展示了从磁盘服务器的缓冲区读取一个表或索引页（等同于读取多个表或索引行）的过程。就像从数据库缓冲池读取一样，磁盘服务器试图将频繁使用的数据保留在内存（缓冲区）中，以降低高昂的磁盘读成本。**若DBMS所需的页不在数据库缓冲池中，继而会向磁盘服务器发起读请求，磁盘服务器会判断该页是否在服务器缓存区中，只有当它发现页不在缓冲区时才从磁盘驱动器上读取该页。如果该页在磁盘服务器的读缓冲区中，那么所花费的时间将从10ms大幅降低到1ms**。如果不在磁盘服务器的读缓冲区中，那么就必须从磁盘进行一次很慢的读取，这一过程可能要花费很长的时间等待磁盘设备空闲下来。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/4.png)

### 从磁盘驱动器进行的顺序读取

顺序地读取页有两个非常重要的优势：

- 同时**读取多个页意味着平均读取每个页的时间将会减少**。
- 由于**DBMS事先知道需要读取哪些页**，所以可以在页被真正请求之前就提前将其读取进来，我们称其为预读。

### 三种类型的读I/O操作

同步读、顺序读和辅助式随机读。

#### 同步IO和异步IO

术语同步IO是指在进行IO操作时，DBMS不能继续其他操作，它必须等待，直至IO操作完成。例如，**在一次**同步读操作中，我们必须先定位到我们所需要的行（在图中用“C”表示起始部分的CPU时间），随后访问该页并处理该行（在图中展示为第二部分的CPU时间），每一步都必须等待，直至上一步完成。

异步读是当**前一步**的页尚在处理时就被提前发起了，这一处理时间和IO时间之间可能有很大一部分的重叠。在这些页被实际处理之前，异步IO就已经完成了。每一组页都以这种方式被预读然后再处理，图2.9展示了这一过程。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/5.png)

**大部分的数据库写是异步的**，以达到对性能的影响最小化。**这一方式导致的最主要影响是加重了磁盘环境的负载**，而这反过来**会影响读IO的性能**。

### 索引组织表

如果一个表的行不是特别长，那么可以考虑将表上所有的列复制到索引上，以加快SELECT的执行速度。如此一来，表就变得冗余了。有些DBMS有去除多余表的选项。若使用这一选项，那么**其中一个索引**的叶子页将用于存储表行。

在Oracle中，**这一选项被称为索引组织表，包含表行的索引被称为主键索引**。**其余的索引都指向包含表行的那个索引**（MySQL中叫做辅助索引）。

**索引组织表的最明显的好处就是节省磁盘空间**（为什么？难道磁盘上不需要存？）。另外，INSERT、UPDATE和DELETE操作的速度也更快。

然而，这给其余的索引带来了不利。如果这些索引使用的是直接指向表行的指针（指针中包含页号），那么主键（聚集）索引的一次叶子页分裂将导致其余索引上大量的磁盘IO。任何对于主键索引键的更新操作，由于需要移动索引行，都会导致DBMS去更新那些指向这一索引行的其他索引行。















