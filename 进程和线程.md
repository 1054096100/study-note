# 进程和线程

## 进程

拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。

### 为什么会要有进程存在？

CPU和I/O运行速率量级相差太大，CPU的速率远远高过I/O速率，导致一旦执行到I/O指令时，系统中CPU资源就处于闲置状态。**系统运行期间，CPU资源被大量浪费**。所以为了提升CPU资源使用率，**加载更多的程序到内存中，一旦某个程序要执行I/O操作，就切换到其他程序运行**。既然涉及到程序切换，那就势必要对一个运行中程序的所有相关信息进行统一管理，这样才能以该单位进行切换避免出错，而这里，这个单位就叫做进程。（简单的来说就是需要时时刻刻对程序运行时的一系列信息进行保留）

### 创建进程

对于每个创建的进程，内核都会为这个进程生成一个进程描述符task_struct、分配一个内核栈、以及虚拟地址映射到物理地址的页表。

1、**进程描述符和内核栈存在于内核空间**，准确的说它们是一个联合结构体。

**task_struct记录了进程的基本信息**，包括**标识号（PID）**、信号、状态、**调度信息**、**进程链信息（父子进程）**、**文件信息**、局部描述符表、任务状态段等。 

2、**进程的内核栈从用户态切换到内核态时都是空的。所以栈底记录了用户栈地址**。   

3、**每个进程拥有统一的（这里的“统一”指的是都是从0开始的）虚拟地址空间**，包括堆、栈、代码段、数据段等。

页表存放在系统空间的页表区，进程描述符中有指针指向页表。

### 进程状态

既然进程之间会进行切换，那么至少有运行、非运行两种状态。那么为什么还要有其他的状态呢？因为，让处于I/O等待过程中的程序重新运行是对CPU资源的浪费。

### 进程调度

现代操作系统中比较通用的运行时状态信息是一个称为进程控制块PCB（Process Control Block）的结构体

#### PCB中主要含有三类信息

##### 进程标识信息

表示信息主要指标识符，包括进程ID（PID）、父进程ID、用户ID（UID）

##### 进程状态信息

##### 进程控制信息

## 线程

拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。

### 为什么需要线程

**更小粒度的控制**可以达到**更加精确的调度结果**，从而**充分利用CPU**。

### 线程的概念

**线程是对进程进行更小粒度的细分**。考虑实际应用中，**每个程序**代码中可能存在**对于多个硬件部件的操作**，如一部分进行内部数据计算、一部分负责文件读写、一部分负责显示刷新，最后**一部分负责与用户交互**。**每个部分以一个线程形式运行，通过将CPU在进程内部的两个线程间切换**，达到执行慢I/O操作的同时。

对于单核来讲，可能见效一般，但是对于多处理器多核来讲，将每一个线程分配各同一CPU种的多核后，那就是并行执行多个线程。

与进程一样，线程也应该维护运行时信息。

### 多线程技术适用的场景

- 前台和后台工作
- 异步处理
- 提高执行速度
- 模块化程序结构

### 线程支持级别

#### 用户级

线程管理所有工作在应用程序内完成，内核意识不到线程的存在。即应用程序本身拥有绝对自主权，它可以根据程序特点自由使用线程管理策略，同时，也避免了由于某些操作系统内核不支持多线程而无法使用线程技术。
但由于内核未进行支持，内核仍以进程为单位对程序进行调度。因此在线程中调用操作系统API时，一旦发生阻塞，则整个进程都将被阻塞

#### 内核级

线程管理工作全部由内核完成，应用程序只需要提交任务为线程即可

## 线程与进程关系

![](http://oklbfi1yj.bkt.clouddn.com/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/1.PNG)

## 线程池

### 基本概念

顾名思义，就是一个**线程的池子**，里面**有若干线程**，它们的目的就是执行提交给线程池的任务，**执行完一个任务后不会退出，而是继续等待或执行新任务**。

线程池主要由两个概念组成，一个是**任务队列**，另一个是**工作者线程**，**工作者线程主体就是一个循环**，**循环从队列中接受任务并执行，任务队列保存待执行的任务**。

### 优点

- 它可以**重用线程，避免线程创建的开销**
- 在任务过多时，**通过排队避免创建过多线程，减少系统资源消耗和竞争，确保任务有序完成**


## 协程

**协程是一种用户态的轻量级线程**

如果将程序分为IO密集型应用和CPU密集型应用，那么两者的发展如下：

IO密集型应用: 多进程-->多线程-->事件驱动-->协程

CPU密集型应用:多进程-->多线程

如果说多进程对于多CPU，多线程对应多核CPU，那么**事件驱动和协程则是在充分挖掘、不断提高单核CPU性能的潜力。**

### 异步 vs 同步

无论是线程还是进程，使用的都是同步进制，当发生阻塞时，性能会大幅度降低，无法充分利用CPU潜力，浪费硬件投资，更重要造成软件模块的铁板化，紧耦合，无法切割，不利于日后扩展和变化。不管是进程还是线程，每次阻塞、切换都需要陷入系统调用(system call)，先让CPU跑操作系统的调度程序，然后再由调度程序决定该跑哪一个进程(线程)。多个线程之间在一些访问互斥的代码时还需要加上锁，这也是导致多线程编程难的原因之一。

现下流行的异步server都是**基于事件驱动**的（如nginx）。事件驱动简化了编程模型，**很好地解决了多线程难于编程，难于调试的问题**。异步事件驱动模型中，把会导致**阻塞的操作转化为一个异步操作，主线程负责发起这个异步操作，并处理这个异步操作的结果**。由于**所有阻塞的操作都转化为异步操作**，理论上主线程的大部分时间都是在处理实际的计算任务，少了多线程的调度时间，所以这种模型的性能通常会比较好。

### 协程 vs 线程

协程是一种**用户级**的轻量级线程。协程**拥有自己的寄存器上下文和栈**。**协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈**。因此：

协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

在并发编程中，协程与线程类似，每个协程表示一个执行单元，有自己的本地数据，与其它协程共享全局数据和其它资源。目前主流语言基本上都选择了多线程作为并发设施，与线程相关的概念是抢占式多任务（Preemptive multitasking），而与协程相关的是**协作式多任务**。

不管是进程还是线程，每次阻塞、切换都需要陷入系统调用(system call)，先让CPU跑操作系统的调度程序，然后再由调度程序决定该跑哪一个进程(线程)。

而且由于**抢占式调度执行顺序无法确定**的特点，**使用线程时需要非常小心地处理同步问题**，而协程完全不存在这个问题（事件驱动和异步程序也有同样的优点）。

我们在自己在进程里面完成逻辑流调度，碰着i\o我就用非阻塞式的。那么我们即可以利用到异步优势，又可以避免反复系统调用，还有进程切换造成的开销，分分钟给你上几千个逻辑流不费力。这就是协程。

### 协程 vs 事件驱动

事件驱动编程的架构是预先设计一个事件循环，这个事件循环程序不断地检查目前要处理的信息，根据要处理的信息运行一个触发函数。其中这个外部信息可能来自一个目录夹中的文件，可能来自键盘或鼠标的动作，或者是一个时间事件。这个触发函数，可以是系统默认的也可以是用户注册的回调函数。

**基于事件驱动**的编程是单线程思维，其特点是**异步+回调**。协程也是单线程，但是它能让原来要使用异步+回调方式写的非人类代码,可以用看似同步的方式写出来。它是实现推拉互动的所谓**非抢占式协作**的关键。

### 协程的优点

高并发+高扩展性+低成本：一个**CPU支持上万的协程都不是问题**。所以很适合用于**高并发处理**。

### 协程缺点

- 无法利用多核资源：协程的本质是个单线程,它不能同时将单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上
- 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决


## 进程与线程的区别

第一：因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它**独立的地址空间**，建立众多的数据表来维护它的代码段、堆栈段和数据段，**这对于多进程来说十分“奢侈”，系统开销比较大**，而线程不一样，**线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快**，效率高，但是**正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉**。

第二：体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而**线程由于共享数据段所以通信机制很方便**。。

第三：体现在CPU系统上面，线程使得CPU系统更加有效，因为**操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上**。

第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。

### 进程与线程的选取

进程与线程的选择取决以下几点：1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；4、并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；5、**需要更稳定安全时，适合选择进程**；需要速度时，选择线程更好。

因为我的项目中需要对数据段的数据共享，可以被多个程序所修改，所以使用线程来完成此操作，无需加入复杂的通信机制，使用进程需要添加复杂的通信机制实现数据段的共享，增加了我的代码的繁琐，而且使用线程开销小，项目运行的速度快，效率高。

如果只用进程的话，虽然安全性高，但是对代码的简洁性不好，程序结构繁琐，开销比较大，还需要加入复杂的通信机制，会使得我的项目代码量大大增加，切换速度会变的很慢，执行效率降低不少。



















































