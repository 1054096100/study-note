# 深入解析文件系统和设备驱动的架构设计

## 1、内核的基础层和应用层

### 内核基础层提供的服务

#### 内核中的任务调度

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/1.png)

上述代码定义了一个wait结构，然后设置进程睡眠。如果有其他进程唤醒这个进程后，判断条件是否满足，如果满足，删除wait对象，否则进程继续睡眠。

#### 工作队列

工作队列和tasklet相似，都是一种延缓执行的机制。不同之处是工作队列有自己的进程上下文，所以工作队列可以睡眠，也可以被调度，而tasklet不可睡眠。

#### 自旋锁

自旋锁用来在**多处理器**的环境下保护数据。自旋锁在单处理器环境下，其实不起作用。

因为被自旋锁锁着的进程一直在旋转（其实是一直反复执行一条指令），而不是睡眠，所以**自旋锁可以用在中断等禁止睡眠的场景**。

内核信号量和自旋锁使用区别：

- 内核信号量不能用在中断处理函数和tasklet等不可睡眠的场景
- 深层次的原因是Linux内核以进程为单位调度，如果在中断上下文睡眠，中断不能被正确处理。

#### radix 树（基数树）

radix树是一种空间换时间的数据结构，通过空间的冗余减少了时间的上的消耗。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/2.png)

radix树很适合稀疏的数据，内核中文件的页缓存就采用了radix树。

### 内核应用层

内核应用层是建立在基础层之上的功能性系统。例如文件系统、设备、驱动以及网络。

## 2、文件系统

可以认为Linux内核的应用层就是以文件系统为核心而展开的。字符设备、块设备这些设备驱动的概念都要依靠文件系统实习。设备管理的基础架构也要依赖文件系统。

从文件系统入手，掌握基本概念和实现架构后，可以从文件系统引入设备文件的概念，设备文件又可以引申到字符设备和块设备，这样就从文件系统过渡到设备管理。设备管理包括了设备驱动，设备驱动要用到中断，设备里面的块设备又控制了通用块层和IO调度。而文件系统向外引申又和网络的socket联系。深入文件系统的代码，可以了解到内存的页面管理。

### 文件系统的基本概念

#### VFS

Linux通过虚拟文件系统（VFS）管理文件系统。

VFS是Linux内核文件系统的一个极其重要的基础设施，**VFS为所有的文件系统提供了统一的接口，对每个具体文件系统的访问要通过VFS定义的接口来实现**。

**VFS本身只存在于内存中，它需要将硬盘上的文件系统抽象到内存中**，这个工作是通过几个重要的结构实现的。**VFS定义了几个重要的结构：dentry、inode、super_block，通过这些结构将一个真实的硬盘文件系统抽象到了内存，从而通过管理dentry、inode这几个对象就可以完成对文件系统的一些操作**（当然，在合适的时候，仍然需要将内存的数据写入到硬盘）。

#### 超级块 super_block

**超级块（super_block）代表了整个文件系统本身**。通常，**超级块是对应文件系统自身的超级块结构**（可参考ext2文件系统的超级块结构）。**超级块保存了文件系统设定的文件块大小，超级块的操作函数**，而**文件系统内所有的inode也都要链接到超级块的链表头**。

超级块的内容需要读取具体文件系统在硬盘上的超级块结构获得，所以超级块是具体文件系统超级块的内存抽象。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/3.png)

- s_root是指向文件系统根dentry的指针。
- s_inodes指向文件系统内所有的inode，通过它可以遍历inode对象。
- Super_operations提供了最重要的超级块操作。例如super_operation的成员函数read_inode提供了读取inode信息的功能。每个**具体的文件系统**一般都要提供这个函数来实现对inode信息的读取，例如ext2文件系统提供的具体函数是ext2_read_inode。

#### 目录项 dentry

对于一个通常的文件系统来说，文件和目录一般按树状结构保存。直观来看，目录里保存着文件，而所有目录一层层汇聚，最终到达根目录。

在VFS里，目录本身也是一个文件，只是有点特殊。每个文件都有一个dentry（可能不止一个），这个dentry链接到上级目录的dentry。根目录有一个dentry结构，而根目录里的文件和目录都链接到这个根dentry，二级目录里的文件和目录，同样通过dentry链接到二级目录。**这样一层层链接，就形成了一颗dentry树。从树顶可以遍历整个文件系统的所有目录和文件**。

为了加快对dentry的查找，内核使用了hash表来缓存dentry，称为dentry cache。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/4.png)

- d_inode指向一个inode结构。这个inode和dentry共同描述了一个普通文件或者目录文件。
- d_parent是指针，指向父dentry结构。
- d_hash是链接到dentry cache的hash链表。
- d_name成员保存的是文件或者目录的名字。
- d_mounted用来指示dentry是否是一个挂载点。

#### 索引节点inode

**inode代表一个文件**。inode保存了文件的大小、创建时间、文件的块大小等参数，以及对文件的读写函数、文件的读写缓存等信息。**一个真实的文件可以有多个dentry，因为指向文件的路径可以有多个（考虑文件的链接），而inode只有一个**。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/5.png)

- i_list、i_sb_list、i_dentry分别是三个链表头。成员i_list用于链接描述inode当前状态的链表。成员i_sb_list用于链接到超级块中的inode链表。当创建一个新的inode时候，成员i_list要链接到inode_in_use这个链表，表示inode处于使用状态，同时成员i_sb_list也要链接到文件系统超级块的s_inodes链表头。由于一个文件可以对应多个dentry，这些dentry都要链接到成员i_dentry这个链表头。
- i_ino是inode的号。

#### 文件对象

文件对象的作用是**描述进程和文件交互的关系**。这里需要指出的是，**硬盘上并不存在一个文件对象**。**进程打开一个文件，内核就动态创建一个文件对象**。**同一个文件，在不同的进程中有不同的文件对象**。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/6.png)

- f_pos表示进程对文件操作的位置。例如对文件读取前10字节，f_pos就指示第11字节位置。
- f_mapping指向一个address_space结构。这个结构封装了文件的读写缓存页面。

### 超级块作用分析

每个文件系统都有一个超级块结构，**每个超级块都要链接到一个超级块链表**。而文件系统内的每个文件在打开时都需要在内存分配一个**inode结构，这些结构都要链接到超级块**。

图2.1展示了超级块之间的关系以及超级块和inode之间的链接关系。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/7.png)

super_block1和super_block2是两个文件系统的超级块，它们被链接到super_blocks链表头，后者使用的就是内核基础层提供的双向链表。顺着super_blocks链表可以遍历整个操作系统打开的文件的inode结构。

### dentry作用分析

用图2-2来解释dentry的链接关系。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/8.png)

如图2-2所示，根目录下有usr和home两个目录，usr目录下有wj和nk两个文件，home目录下有个mnt目录，这是另外一个文件系统，挂载到当前文件系统。在mnt目录下有个cj文件。

文件系统的dentry链表图如图2-3所示。这只是个示意图，但是展示了几个重要的概念。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/9.png)

- 每个文件的dentry链接到父目录的dentry，形成了文件系统的结构树。

  具体来说，就是usr和home两个dentry的d_child成员链接到根目录的d_subdirs成员。而wj和nk两个dentry结构链接到usr这个dentry。

- 所有的dentry都指向一个dentry_hashtable

  dentry_hashtable是个数组，它的数组成员是hash链表。如果某个文件已经被打开过，内存中就应该有该文件的dentry结构，并且该dentry被链接到dentry_hashtable数组的某个hash链表头。后续再访问该文件的时候，就可以直接从hash链表里面找到，避免了再次读硬盘。这是dentry的cache概念。

- home目录下的mnt目录指向一个挂载的文件系统。

  如何判断目录不是一个普通的目录，而是一个文件系统？这是dentry的d_mounted成员的功能。如果该成员不为0，代表该dentry是个挂载点，有文件系统挂载，需要特殊处理。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/10.png)

从图2-3可以看到，挂载过来的文件系统本身也有一个dentry树，也有自己的根目录。两个dentry树之间并没有链接关系。

在Linux系统里，字符设备和块设备、普通文件和目录、socket等都是一个文件，所以它们都有自己的inode结构。为了辨别这些不同的类型，inode结构的i_mode成员用不同的值代表不同的类型。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/11.png)

### 文件对象作用分析

文件对象代表进程和具体文件交互的关系。内核为每个**打开的文件**申请一个文件对象，同时返回文件的号码。每个进程都指向一个文件描述符表。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/12.png)

这个表里面用数组保存了进程中每个打开的文件。当应用进程打开一个硬盘上的文件时，内核要为这个文件分配一个文件对象并保存文件指针到文件描述符表里面的数组。

这里的“文件”指的是硬盘上具体存在的文件，而**“文件对象”是在内存里存在的文件结构**。**在读写文件的时候，通过文件号就可以获得文件的对象**。**这也就是读写文件必须先打开文件的原因，如果不执行打开的过程，是不能完成文件读写的**。

















































