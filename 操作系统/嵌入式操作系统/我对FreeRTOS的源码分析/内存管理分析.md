# 内存管理分析

 FreeRTOS操作系统将内核与内存管理分开实现，操作系统内核仅规定了必要的内存管理函数原型，而不关心这些内存管理函数是如何实现的。这样做大有好处，可以增加系统的灵活性：不同的应用场合可以使用不同的内存分配实现，选择对自己更有利的内存管理策略。比如对于安全型的嵌入式系统，通常不允许动态内存分配，那么可以采用非常简单的内存管理策略，一经申请的内存，甚至不允许被释放。在满足设计要求的前提下，系统越简单越容易做的更安全。再比如一些复杂应用，要求动态的申请、释放内存操作，那么也可以设计出相对复杂的内存管理策略，允许动态分配和动态释放。 	FreeRTOS内核规定的几个内存管理函数原型为：

```c
void *pvPortMalloc( size_t xSize ) ：内存申请函数
void vPortFree( void *pv ) ：内存释放函数
void vPortInitialiseBlocks( void ) ：初始化内存堆函数
size_t xPortGetFreeHeapSize( void ) ：获取当前未分配的内存堆大小
size_t xPortGetMinimumEverFreeHeapSize( void )：获取未分配的内存堆历史最小值
```

FreeRTOS提供了5种内存管理实现，有简单也有复杂的，可以应用于绝大多数场合。它们位于下载包目录...\FreeRTOS\Source\portable\MemMang中,文件名分别为：heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c。

FreeRTOS提供的内存管理都是从内存堆中分配内存的。**默认情况下，FreeRTOS内核创建任务、队列、信号量、事件组、软件定时器都是借助内存管理函数从内存堆中分配内存**。最新的FreeRTOS版本（V9.0.0及其以上版本）可以完全使用静态内存分配方法，也就是不使用任何内存堆。

对于heap_1.c、heap_2.c和heap_4.c这三种内存管理策略，内存堆实际上是一个很大的数组，定义为： static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];

对于heap_3.c，这种策略只是简单的包装了标准库中的malloc()和free()函数，包装后的malloc()和free()函数具备线程保护。因此，内存堆需要通过编译器或者启动文件设置堆空间。 

heap_5.c比较有趣，它允许程序设置多个非连续内存堆，比如需要快速访问的内存堆设置在片内RAM，稍微慢速访问的内存堆设置在外部RAM。每个内存堆的起始地址和大小由应用程序设计者定义。

## heap_1.c

这是5个内存管理策略中最简单的一个，我们称为第一个内存管理策略，它简单到只能申请内存。是的，跟你想的一样，一旦申请成功后，这块内存再也不能被释放。对于大多数嵌入式系统，特别是对安全要求高的嵌入式系统，这种内存管理策略很有用，因为对系统软件来说，**逻辑越简单越容易兼顾安全**。实际上，**大多数的嵌入式系统并不需要动态删除任务、信号量、队列等，而是在初始化的时候一次性创建好，便一直使用，永远不用删除**。所以这个内存管理策略实现简洁、安全可靠，使用的非常广泛。我对这个对内存管理策略也情有独钟。

### 内存申请：pvPortMalloc()

```c
void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;


    /* 确保申请的字节数是对齐字节数的倍数 */
    #if( portBYTE_ALIGNMENT != 1 )
    {
        if( xWantedSize & portBYTE_ALIGNMENT_MASK )
        {
            xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
        }
    }
    #endif


    vTaskSuspendAll();
    {
        if( pucAlignedHeap == NULL )
        {
            /* 第一次使用,确保内存堆起始位置正确对齐 */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
        }


        /* 边界检查,变量xNextFreeByte是局部静态变量,初始值为0 */
        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) )
        {
            /* 返回申请的内存起始地址并更新索引 */
            pvReturn = pucAlignedHeap + xNextFreeByte;
            xNextFreeByte += xWantedSize;
        }
    }
    ( void ) xTaskResumeAll();


    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
        }
    }
    #endif


    return pvReturn;
}
```

函数一开始会将申请的内存数量调整到对齐字节数的整数倍，所以实际分配的内存空间可能比申请内存大。比如对于8字节对齐的系统，申请11字节内存，经过对齐后，实际分配的内存是16字节（8的整数倍）。 	接下来会挂起所有任务，因为内存申请是不可重入的（使用了静态变量）。  	如果是第一次执行这个函数，需要将变量pucAlignedHeap指向内存堆区域第一个地址对齐处。我们上面说内存堆其实是一个大数组，编译器为这个数组分配的起始地址是随机的，可能不符合我们的对齐需要，这时候要进行调整。比如内存堆数组ucHeap从RAM地址0x10002003处开始，系统按照8字节对齐，则对齐后的内存堆如图1-1所示：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/1.png)

之后进行边界检查，查看剩余的内存堆是否够分配，检查xNextFreeByte + xWantedSize是否溢出。如果检查通过，则为申请者返回有效的内存指针并更新已分配内存数量计数器xNextFreeByte（从指针pucAlignedHeap开始，偏移量为xNextFreeByte处的内存区域为未分配的内存堆起始位置）。比如我们首次调用内存分配函数pvPortMalloc(20)，申请20字节内存。根据对齐原则，我们会实际申请到24字节内存，申请成功后，内存堆示意图如图1-2所示：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/2.png)

内存分配完成后，不管有没有分配成功都恢复之前挂起的调度器。

如果内存分配不成功，这里最可能是内存堆空间不够用了，会调用一个钩子函数vApplicationMallocFailedHook()。这个钩子函数由应用程序提供，通常我们可以打印内存分配设备信息或者点亮故障指示灯。

## heap_2.c

第二种内存管理策略要比第一种内存管理策略复杂，它使用一个最佳匹配算法，允许释放之前已分配的内存块，但是**它不会把相邻的空闲块合成一个更大的块（换句话说，这会造成内存碎片）**。

这个内存管理策略用于重复的分配和删除具有相同堆栈空间的任务、队列、信号量、互斥量等等，并且不考虑内存碎片的应用程序，**不适用于分配和释放随机字节堆栈空间的应用程序**（否则会造成比较多的内存碎片）！

与第一种内存管理策略一样，内存堆仍然是一个大数组，定义为：

```c
static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];  
```

局部静态变量pucAlignedHeap指向对齐后的内存堆起始位置。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/3.png)

### 内存申请：pvPortMalloc()

与第一种内存管理策略不同，第二种内存管理策略使用一个链表结构来跟踪记录空闲内存块，将空闲块组成一个链表。结构体定义为：

```c
typedef struct A_BLOCK_LINK
{
    struct A_BLOCK_LINK *pxNextFreeBlock;   /*指向列表中下一个空闲块*/
    size_t xBlockSize;                      /*当前空闲块的大小，包括链表结构大小*/
} BlockLink_t;
```

两个BlockLink_t类型的局部静态变量xStart和xEnd用来标识空闲内存块的起始和结束。刚开始时，整个内存堆有效空间就是一个空闲块，如图2-2所示。因为要包含的信息越来越多，我们必须舍弃一些信息，舍弃的信息可以在上一幅图中找到。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/4.png)

 图2-2中的pvReturn是我自己增加的，用于接下来分析内存申请操作，堆栈初始化并没有这个变量，也没有对其操作的代码。从图2-2中可以看出，整个有效空间组成唯一一个空闲块，在空闲块的起始位置放置了一个链表结构，用于存储这个空闲块的大小和下一个空闲块的地址。由于目前只有一个空闲块，所以空闲块的pxNextFreeBlock指向链表xEnd，而链表xStart结构的pxNextFreeBlock指向空闲块。这样，xStart、空闲块和xEnd组成一个单链表，xStart表示链表头，xEnd表示链表尾。随着内存申请和释放，空闲块可能会越来越多，但它们仍是以xStart链表开头以xEnd链表结尾，根据空闲块的大小排序，小的在前，大的在后，我们在内存释放一节中会给出示意图。

**当申请N字节内存时，实际上不仅需要分配N字节内存，还要分配一个BlockLink_t类型结构体空间，用于描述这个内存块，结构体空间位于空闲内存块的最开始处**。当然，和第一种内存管理策略一样，**申请的内存大小和BlockLink_t类型结构体大小都要向上扩大到对齐字节数的整数倍**。

 我们看一下内存申请过程：首先计算实际要分配的内存大小，判断申请的内存是否合法。如果合法则**从链表头xStart开始查找，如果某个空闲块的xBlockSize字段大小能容得下要申请的内存，则从这块内存取出合适的部分返回给申请者，剩下的内存块组成一个新的空闲块**，**按照空闲块的大小顺序插入到空闲块链表中，小块在前大块在后**。注意，**返回的内存中不包括链表结构，而是紧邻链表结构（经过对齐）后面的位置**。举个例子，如图2-2所示的内存堆，当调用申请内存函数，如果内存堆空间足够大，就将pvReturn指向的地址返回给申请者，而不是静态变量pucAlignedHeap指向的内存堆起始位置！

当多次调用内存申请函数后（没有调用内存释放函数），内存堆结构如图2-3所示。注意图中的pvReturn仍是我自己增加上去的，pvReturn指向的位置返回给申请者。后面我们讲内存释放时，就是根据这个地址完成内存释放工作的。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/5.png)

### 内存释放：vPortFree()

因为**不需要合并相邻的空闲块**，第二种内存管理策略的内存释放也非常简单：**根据传入的参数找到链表结构，然后将这个内存块插入到空闲块列表，更新未分配的内存堆计数器大小**，结束。

```c
void vPortFree( void *pv )
{
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;


    if( pv != NULL )
    {
        /* 根据传入的参数找到链表结构 */
        puc -= heapSTRUCT_SIZE;


        /* 预防某些编译器警告 */
        pxLink = ( void * ) puc;


        vTaskSuspendAll();
        {
            /* 将这个块添加到空闲块列表 */
            prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
            /* 更新未分配的内存堆大小 */
            xFreeBytesRemaining += pxLink->xBlockSize;
            
            traceFREE( pv, pxLink->xBlockSize );
        }
        ( void ) xTaskResumeAll();
    }
}
```

我们举一个例子，将图2-3 pvReturn指向的内存块释放掉，假设（configADJUSTED_HEAP_SIZE-40）远大于要释放的内存块大小，释放后的内存堆如图2-4所示：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/6.png)

从图2-4我们可以看出第二种内存管理策略的两个特点：第一，空闲块是按照大小排序的；第二，相邻的空闲块不会组合成一个大块。

我们再接着引申讨论一下这种内存管理策略的优缺点。通过对内存申请和释放函数源码分析，我们可以看出它的一个优点是速度足够快，因为它的实现非常简单；第二个优点是可以动态释放内存。但是它的缺点也非常明显：由于在释放内存时不会将相邻的内存块合并，所以这可能造成内存碎片。这就对其应用的场合要求极其苛刻：第一，每次创建或释放的任务、信号量、队列等必须大小相同，如果分配或释放的内存是随机的，绝对不可以用这种内存管理策略；第二，如果申请和释放的顺序不可预料，也很危险。举个例子，对于一个已经初始化的10KB内存堆，先申请48字节内存，然后释放；再接着申请32字节内存，那么一个本来48字节的大块就会被分为32字节和16字节的小块，如果这种情况经常发生，就会导致每个空闲块都可能很小，最终在申请一个大块时就会因为没有合适的空闲块而申请失败（并不是因为总的空闲内存不足，而是因为设计的缺陷）！

## heap_3.c

第三种内存管理策略简单的封装了标准库中的malloc()和free()函数，采用的封装方式是操作内存前挂起调度器、完成后再恢复调度器。封装后的malloc()和free()函数具备线程保护。

第一种和第二种内存管理策略都是通过定义一个大数组作为内存堆，数组的大小由宏configTOTAL_HEAP_SIZE指定。第三种内存管理策略与前两种不同，它不再需要通过数组定义内存堆，而是需要使用编译器设置内存堆空间，一般在启动代码中设置。因此宏configTOTAL_HEAP_SIZE对这种内存管理策略是无效的。

## heap_4.c

第四种内存分配方法**与第二种比较相似**，只不过**增加了一个合并算法**，将相邻的空闲内存块合并成一个大块。 与第一种和第二种内存管理策略一样，**内存堆仍然是一个大数组**，定义为：

```c
static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
```

### 内存申请：pvPortMalloc()

```c
typedef struct A_BLOCK_LINK
{
    struct A_BLOCK_LINK *pxNextFreeBlock;   /*指向列表中下一个空闲块*/
    size_t xBlockSize;                      /*当前空闲块的大小，包括链表结构大小*/
} BlockLink_t;
```

与第二种内存管理策略一样，空闲内存块也是以单链表的形式组织起来的，BlockLink_t类型的局部静态变量xStart表示链表头，但第四种内存管理策略的链表尾保存在内存堆空间最后位置，并使用BlockLink_t指针类型**局部静态变量pxEnd**指向这个区域（**第二种内存管理策略使用静态变量xEnd**表示链表尾），如图4-1所示。 第四种内存管理策略和第二种内存管理策略还有一个很大的不同是：**第四种内存管理策略的空闲块链表不是以内存块大小为存储顺序，而是以内存块起始地址大小为存储顺序，地址小的在前，地址大的在后。这也是为了适应合并算法而作的改变**。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/7.png)

从图4-1中可以看出，整个有效空间组成唯一一个空闲块，在空闲块的起始位置放置了一个链表结构，用于存储这个空闲块的大小和下一个空闲块的地址。由于目前只有一个空闲块，所以空闲块的pxNextFreeBlock指向指针pxEnd指向的位置，而链表xStart结构的pxNextFreeBlock指向空闲块。xStart表示链表头，pxEnd指向位置表示链表尾。

当申请x字节内存时，实际上不仅需要分配x字节内存，还要分配一个BlockLink_t类型结构体空间，用于描述这个内存块，结构体空间位于空闲内存块的最开始处。当然，和第一种、第二种内存管理策略一样，申请的内存大小和BlockLink_t类型结构体大小都要向上扩大到对齐字节数的整数倍。

我们先说一下内存申请过程：首先计算实际要分配的内存大小，判断申请内存合法性，如果合法则从链表头xStart开始查找，如果某个空闲块的xBlockSize字段大小能容得下要申请的内存，则将这块内存取出合适的部分返回给申请者，**剩下的内存块组成一个新的空闲块，按照空闲块起始地址大小顺序插入到空闲块链表中，地址小的在前，地址大的在后**。**在插入到空闲块链表的过程中，还会执行合并算法：判断这个块是不是可以和上一个空闲块合并成一个大块，如果可以则合并；然后再判断能不能和下一个空闲块合并成一个大块，如果可以则合并**！合并算法是第四种内存管理策略和第二种内存管理策略最大的不同!经过几次内存申请和释放后，可能的内存堆如图4-2所示：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/8.png)

### 内存释放：vPortFree()

第四种内存管理策略的内存释放也比较简单：根据传入的参数找到链表结构，然后将这个内存块插入到空闲块列表，需要注意的是在插入过程中**会执行合并算法**，这个我们已经在内存申请中讲过了。最后是将这个内存块标志为“空闲”、更新未分配的内存堆大小，结束。

如图4-2所示的内存堆示意图，如果我们将32字节的“已分配空间2”释放，由于这个内存块的上面和下面都是空闲块，所以在将它插入到空闲块链表的过程在中，会先和“剩余空闲块1”合并，合并后的块再和“剩余空闲块2”合并，这样组成一个大的空闲块，如图4-3所示：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%88%91%E5%AF%B9FreeRTOS%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/9.png)









