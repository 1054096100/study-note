# 任务调度

![](http://oklbfi1yj.bkt.clouddn.com/FreeRTOS/3.jpg)

## 任务管理

### 1、小型多任务嵌入式系统简介

不同的多任务系统有不同的特点。

**PC的输入处理一般是“软实时”**，为了保证让大部分觉得能够使用。PC对每个输入的响应限定在一个恰当的时间范围之内---但是如果超出了这个范围，并不会让人觉得无法使用。比如打字，如果按下了键盘，电脑没有反应顶多觉得电脑反应比较慢。

仅仅从单处理器多线程来说，实时嵌入式操作系统和PC是差不多的。但**实时操作系统的特点是具有硬实时的特性**。

**硬实时功能必须在给定的时间限制之内完成**----**如果无法做到即意味着整个系统的绝对失败**。**汽车的安全气囊触发机制就是一个硬实时的例子。安全气囊必须在撞击发生后的给定时间内弹出**。

### 2、任务函数

例子：

```c
void ATaskFunction(void *pvParameters)
{
   int iVarExample = 0;
   for (;;)
   {
      //任务代码放这
   }
   vTaskDelete( NULL ); 
}
```

### 3、顶层任务状态

应用程序可以包含多个任务。如果运行应用程序的微控制器只有一个核(core)，那么同一时间实际上只有一个任务会被执行。这就意味着一个任务可以有2个状态，运行态和非运行态。

当一个任务处于运行态时，处理器就执行这个任务的代码。

当一个任务处于阻塞态的时候，该任务休眠，这个任务的当前运行状态都被妥善保存，以便于下次调试器决定让他进入运行态的时候可以恢复执行。当任务恢复执行时，其将从离开运行态时正准备执行的那一条指令开始执行。

**任务从非运行态转移到运行态叫切入**(switched in)，相反**运行态转移到非运行态被称为切出**(switched out)。**FreeRTOS的调度器是能让任务切入切出的唯一实体**。

### 4、创建任务

xTaskCreat()API函数 有6个参数：

- pvTaskCode （任务函数指针）
- pcName（调试用任务名）
- usStackDepth（任务栈大小）
- pvParameters（任务参数）
- uxPriority（任务优先级）
- pxCreatedTask（传出任务句柄）

xTaskCreat()API函数 有2种返回值：

- pdTRUE 创建成功
- errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 内存不够创建失败

### 5、任务优先级

每个任务都有自己的优先级。对于如何为任务制定优先级，FreeRTOS并没有强加任何限制。任意数量的任务可以共享同一个优先级。当然你也可以为每个任务指定唯一的优先级。

低优先级号表示任务优先级低，0是最低的优先级。

调度器保证总是在所有可运行（即就绪态）任务中选择具有最高优先级的任务，并使其进入运行态。**如果被选中的优先级上具有多个任务，调度器会让这些任务轮流执行**。

**要能够选择下一个运行的任务，调度器需要在每个时间片结束时刻运行自己本身**。**一个称为心跳中断的周期性中断用于此目的**。**时间片的长度通过心跳中断的频率进行设定**，**心跳中断频率由FreeRTOSConfig.h中的编译时配置常量configTICK_RAKE_HZ进行配置**。

FreeRTOS API函数调用中指定的时间总是以心跳中断为单位。常量portTICK_RATE_MS用于将以心跳为单位的时间值转化为以毫秒为单位的时间值。有效的精度依赖于系统心跳频率。

### 6、非运行态

#### 阻塞状态

由于调度器**只会**执行高优先级的任务，如果同时存在两个优先级的任务，那么低优先级的任务就将被饿死。所以实际使用的过程中，**高优先级的任务需要能够切换进入非运行态以让低优先级的任务也可以进行**。（为什么不可以把高优先级的任务变为低优先级的任务呢？因为如果把高优先级任务的优先级改为最低，从而执行低优先级的任务，那么每次通过这种方式去修改优先级，最终所有任务的优先级都是很低的。因为每次都需要把最高优先级改得比当前最低优先级还要低）

如果一个任务正在**等待某个事件发生**，则称这个任务处于**阻塞态**（blocked）。

任务进入阻塞态**可以等待以下两个不同类型的事件**：
1.**定时**。延时或者绝对时间到点。通常用来周期执行某个任务。
2.**同步事件**。源于其他任务或者中断。（各种信号量，二值信号，互斥信号，计数信号量）
任务可以在进入阻塞态以等待**同步事件**制定一个**超时时间**(超时实际上需要用到定时这个事件)，这样可以有效地实现阻塞状态下同时等待两种类型的事件。

#### 挂起状态

**挂起状态的任务对于调度器来说是不可见的**。一般用的比较少。调用函数vTaskSuspend()可以挂起任务。vTaskResume()可以解除挂起。

#### 就绪状态

如果任务处于非运行态，但既没挂起也没阻塞，就叫就绪状态。**就绪状态为运行前的中间态**。

### 7、空闲任务和空闲任务钩子函数。

简单的来说就是一个系统默认的，**优先级为0的任务函数**。系统为空闲状态下执行。**一般用来计算CPU的利用率，或者将CPU配置到低功耗**。

### 8、删除任务

使用函数vTaskDelete()可以删除任务。

**只有内核为任务分配的内存空间才会在任务被删除后自动回收，任务自己占用的内存或者资源需要由应用程序自己释放**。（但是一个进程结束后，它使用的内存不是也会被释放掉吗？还是说，对于FreeRTOS这个操作系统，不会去这么做？）

### 9、调度算法

- 每个任务都赋予一个优先级
- 每个任务都可以存在一个或者多个状态。
- 在任何时候都只有一个任务可以处于运行状态。
- 调度器总是在所有处于就绪态的任务中选择具有最高优先级的任务来执行。

这种调度方案被称为： 固定优先级抢占式调度。所谓固定优先级是指每个任务都被赋予了一个优先级而这个优先级不能被内核本身修改（只能被任务修改）。抢占是指当任务进入就绪态或者优先级改变时，如果处于运行态的任务优先级更低，则该任务总是抢占当前任务。































































































