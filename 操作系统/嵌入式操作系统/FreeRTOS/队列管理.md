# 队列管理

![](http://oklbfi1yj.bkt.clouddn.com/FreeRTOS/4.jpg)

在FreeRTOS各个任务之间可能会进行相互通信，而在FreeRTOS中**所有通信和同步的机制都是基于队列来实现的**。

本文主要说明一下问题：

- 如何创建一个队列。
- 队列如何管理其数据。
- 如何像队列发送数据。
- 如何从队列接受数据。
- 队列阻塞是什么意思。
- 往队列发送和从队列接收时优先级会有什么影响。

## 1、队列的特性

### 可被多任务存取

队列是具有自己独立权限的内核对象。不属于任何任务。**所有任务**都可以对同一个队列写入和读出。但是从编程上来看，读取队列一般只有一个任务。

### 读队列时阻塞

当队列为空的时候，读队列的任务会进入阻塞状态。

**当某个任务读队列的时候，可以指定一个阻塞超时时间**。若这段时间之内队列为空，则任务将保持阻塞的状态。当队列有了数据之后，该任务将自动变阻塞状态为就绪状态。当时间超过设定的时间，也会变为就绪状态。

当多个任务同时读取一个队列的时候（假设这些任务现在处于阻塞状态），一旦队列有数据，只有一个任务会解除阻塞，该任务为所有读取队列任务中**优先级最高**的。若优先级相同，则选择**等待时间最长**的。

### 写队列时阻塞

当队列写满时，写队列的任务会进入阻塞状态。

## 2、使用队列

### 创建队列

xQueueCreate()函数

参数：

​        uxQueueLength 队列能存储的最大数目
​        uxltemSize 队列中数据单元的长度

返回值为该队列的句柄。若创建失败则会返回NULL。

### 向队列发送数据

xQueueSendToBack()与xQueueSendToFront()函数

参数：
​        xQueue 目标队列句柄
​        pvltemToQueue 发送数据的指针
​        xTicksToWait 阻塞超时时间

返回值：
​        pdPASS数据被成功发送。
​        errQUEUE_FULL队列已满。

#### 在中断服务程序中使用的函数

xQueueSendToBackISR()与xQueueSendToFrontISR()函数

### 从队列读取数据

xQueueReceive()与xQueuePeek()函数
参数：
​        xQueue 读取队列的句柄
​        pvBuffer 接收缓存指针
​        xTicksToWait 阻塞超时时间

返回：
​        pdPASS数据被成功接收。
​        errQUEUE_FULL队列为空。
**xQueueReceive()接受数据后会将数据从队列删除。xQueuePeek()接收数据后不会对队列做任何修改**。分别相当于pop和top操作。

#### 在中断服务程序中使用的函数

xQueueReceiveISR()与xQueuePeekISR()函数

### 查询队列中有效数据数量

uxQueueMessagesWaiting()函数

用来查询队列中数据的个数。

参数：
​        xQueue 查询队列的句柄
返回：
​        当前队列中数据的个数，0表示队列为空。

#### 在中断中使用的函数

uxQueueMessagesWaitingISR()函数

## 3、传输大型数据单元

大型数据的传输一般用传输数据地址指针的方式。若一个字节一个字节的拷进拷出则会浪费太多资源。

但对于指针的传输需要注意:

- 指针指向的内存空间所有权必须明确。应保证不会有任何两个程序同时修改共享内存中的数据。最好保证，在数据被发送前，只由发送任务修改，当数据被接收后，只由接受任务修改。
- 指针指向的内存空间必须有效。如果指针指向的内存空间是动态分配的，则只应有一个任务负责对其进行内存释放。当其被释放后就不能有其他程序再次访问他了。

## 4、疑问

上面的那些读取、写入函数，为什么要单独为中断服务程序而编写？





























































































































































