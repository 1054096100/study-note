# 内存管理

![](http://oklbfi1yj.bkt.clouddn.com/FreeRTOS/7.jpg)

**每当任务，队列或者信号量被创建时，内核需要进行动态的内存分配。虽然可以调用标准的malloc()与free()库函数，但有以下一些问题**。

- **这两个函数在小型嵌入式系统中可能不可用**。
- **这两个函数的具体实现可能会相对较大，会占用较多的代码空间**。
- 这两个函数通常不具备现成安全特性。
- **这两个函数具有不确定性。每次调用时的时间和开销可能不同**。
- **这两个函数会产生内存碎片**。
- 这两个函数会使得链接器配置的复杂。

FreeRTOS将内存分配作为可移植层面。这使得不同的应用程序可以提供适合自身的具体实现。当内核请求内存时，其调用的是pvPortMalloc()而不是直接调用malloc()；当内存释放时调用的是vPortFree()而不是直接调用free()。

FreeRTOS自带有三种pvPortMalloc()和vPortFree()的实现范例。用户可以选用任意一种。

## 1、内存分配方案

### Heap_1.c

**其实现了一个非常基本的pvPortMalloc()版本，而没有实现vPortFree()**（那该如何释放内存？）。**如果应用程序不需要删除任务，队列或者信号量，则其具有使用heap_1的潜质**。其具有确定性。（什么叫做具有确定性？）
这种分配方案将FreeRTOS的内存堆空间看成一个简单的数组。当调用pvPortMalloc()时，则将数组又简单的细分成为更小的内存块。数组大小在FreeRTOSConfig.h中由configTOTAL_HEAP_SIZE定义。

![](http://oklbfi1yj.bkt.clouddn.com/FreeRTOS/8.jpg)

- A表示数组在没有任何任务创建时的情形。
- B表示数组在创建了一个任务后的情形。
- C表示数组在创建了三个任务后的情形。

### Heap_2.c

不同与Heap_1.c，其采用了一个**最佳匹配算法来分配内存，并支持内存释放**。由于声明了一个静态数组，所以会让整个应用程序看起来耗费了很多内存，即使是在数组没有进行任何实际分配之前。

**最佳匹配算法保证pvPortMalloc()会使用最接近请求大小的空间块**。例如：

假设现在的空间包含了三个空闲内存块，分别为5字节，25字节和100字节。此时调用pvPortMalloc()，请求分配20字节大小的内存空间。因为，匹配请求字节数（这里请求的字节数是20个字节）的最小空闲内存块是具有25字节大小的内存块---所以**pvPortMalloc()会将这个25字节再分为一个20字节块和5字节块**，然后返回一个指向20字节块的指针，剩下的5字节块则保留下来，用来以后pvPortMalloc()使用。

**Heap_2.c不会把相邻的空闲块合并成一个更大的内存块，所以会产生内存碎片。如果分配和释放的总是相同大小的内存块，则内存碎片不会成为一个问题。所以Heap_2.c适合于那些重复创建与删除具有相同空间任务的应用程序**。

![](http://oklbfi1yj.bkt.clouddn.com/FreeRTOS/9.jpg)

- A表示内存在创建了三个任务之后的情形。内存的顶部还剩余一个大的空闲块。
- B表示内存在删除了一个任务后的情形。顶部的大空闲块保持不变，并多出了两个小的空闲块，分别是被删除任务的TCB和任务栈。
- C表示数组在又创建了一个任务后的情形。**创建一个任务会产生两次调用pvPortMalloc()，一次是分配TCB，一次是分配任务栈**。

Heap_2.c虽然具有不确定性（什么叫做不确定性？），单笔大多数标准库实现的malloc()与free()更有效率。

### Heap_3.c

简单的调用了标准库malloc()和free()，但是通过暂时挂起调度器使得函数调用具备了线程安全特性。