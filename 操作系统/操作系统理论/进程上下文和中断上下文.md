# 进程上下文和中断上下文

内核态和用户态有自己的内存映射，即自己的地址空间。

**处理器总处于以下状态中的一种：**

1、内核态，运行于进程上下文，**内核代表进程运行于内核空间**（比如说进程执行系统调用的时候会陷入内核态，但是，此时还是运行于进程上下文）；

2、内核态，运行于中断上下文，**内核代表硬件运行于内核空间**；

3、用户态，运行于用户空间。

综上所述，**内核可以工作在进程上下文或中断上下文**（中断上下文和进程上下文不可能同时发生）。

也就是说，**用户态不能访问内核地址空间的内存（需要内核态运行于进程上下文），也不能直接访问硬件**。要想这么做，一是通过系统调用进入内核态，也就**产生了进程上下文**；二是通过中断访问硬件，也就产生了中断上下文。两种状态的切换对应不同的目的（一个使用系统调用，一个访问硬件），有不同的来源（一个使用系统调用进入，一个使用硬件中断进入）。

用户空间的应用程序，通过系统调用，进入内核空间。由内核代表该进程运行于内核空间，这就涉及到上下文的切换，用户空间和内核空间具有不同的地址映射，通用或专用的寄存器组，而用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执行。

所谓的“进程上下文”，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。（简单来说，进程上下文就是与恢复一个进程有关的信息）

所谓“中断上下文”，就是硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。**这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理**。中断上下文，其实也可以看作就是**硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是之前被中断的进程环境。因为，中断的过程结束后，需要恢复到被中断的那个位置）**。

Linux内核工作在进程上下文或者中断上下文。提供系统调用服务的内核代码代表发起系统调用的应用程序运行在进程上下文；另一方面，中断处理程序，**异步运行**在中断上下文。中断上下文和特定进程无关（正是因为异步，所以，中断上下文不一定和当前的进程有关，可能是很久之前的那个进程执行了一个读/写磁盘的操作，之后硬件才发出中断信号，所以说，硬件发出中断信号的时候，并不知道是否是之前的进程，所以是在一个不确定的时候发出的，所以发生中断的时候，此时的中断上下文和特定的进程无关）。

内核之所以进入进程上下文是因为进程自身的一些工作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态等。

内核进入中断上下文是因为中断信号而导致的中断处理或软中断。而中断信号的发生是随机的，中断处理程序及软中断并不能事先预测发生中断时当前运行的是哪个进程，所以在中断上下文中引用current是可以的，但没有意义。事实上，对于A进程希望等待的中断信号，可能在B进程执行期间发生。例如，A进程启动写磁盘操作，A进程睡眠后B进程在运行，当磁盘写完后磁盘中断信号打断的是B进程，在中断处理时会唤醒A进程。

内核可以处于两种上下文：进程上下文和中断上下文。在系统调用之后，用户应用程序进入内核空间，此后内核空间针对用户空间相应进程的代表就运行于进程上下文。异步发生的中断会引发中断处理程序被调用，**中断处理程序就运行于中断上下文**。**中断上下文和进程上下文不可能同时发生**。

运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。因此，内核会限制中断上下文的工作，不允许其执行如下操作：

(1) 进入睡眠状态或主动放弃CPU（不理解）

因为没有后备进程，所以中断上下文不可以睡眠，否则不能再对它重新调度。

(2) 执行耗时的任务

中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。

当执行一个中断处理程序时，内核处于中断上下文中。进程上下文是一种内核所处的操作模式，此时内核代表进程执行。例如，执行系统调用或运行内核线程。进程是以进程上下文的形式连接到内核的，因此，进程上下文可以睡眠，也可以调用调度程序。































































