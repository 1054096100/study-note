# 匿名管道

## 前言

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以**进程之间要交换数据必须通过内核**，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。

![](http://oklbfi1yj.bkt.clouddn.com/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/1.JPG)

## 管道

### 什么是管道

如果用过Linux命令，那么我们对这个名词不会陌生，我们经常通过“|”来使用管道，比如`ls -l|grep string`。**管道是一个进程连接数据流到另一个进程的通道，通常一个进程的输出通过管道连接到另一个进程的输入**。

### 管道的实现原理

#### 管道

一个管道实际上就是个**只存在于内存中**的文件。

管道是一种特殊的文件，它不属于某一种文件系统，而是一种独立的文件系统，有其自己的数据结构。
根据管道的适用范围将其分为：无名管道和命名管道。

#### 匿名管道

主要用于**父进程与子进程之间**，或者**两个兄弟进程之间**。在linux系统中可以通过系统调用建立起一个单向的通信管道，且这种关系只能由父进程来建立。

#### 命名管道

**命名管道是建立在实际的磁盘介质或文件系统（而不是只存在于内存中）上有自己名字的文件，任何进程可以在任何时间通过文件名或路径名与该文件建立联系**。为了实现命名管道，引入了一种新的文件类型——FIFO文件（遵循先进先出的原则）。
**实现一个命名管道实际上就是实现一个FIFO文件**。命名管道一旦建立，之后它的读、写以及关闭操作都与普通管道完全相同。虽然FIFO文件的inode节点在磁盘上，但是仅是一个节点而已，文件的数据还是存在于内存缓冲页面中，和普通管道相同。

#### 管道实现机制

**管道是由内核管理的一个缓冲区**，相当于我们放入内存中的一个纸条。
管道的一端连接一个进程的输出。这个进程会向管道中放入信息。
管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。
**一个缓冲区不需要很大一般为4K大小，它被设计成为环形的数据结构，以便管道可以被循环利用**。
当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。
当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。
**当两个进程都终结的时候，管道也自动消失**。

### 底层管道

popen是高级函数，pipe则是底层调用，它不需要启动shell来解释命令，而且它能提供更多对数据的控制

#### 语法

```c++
#include <unistd.h>
int pipe(int pipefd[2]);
```

#### 用法

调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，**pipefd[0]指向管道的读端，pipefd[1]指向管道的写端**（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，**通过read(pipefd[0]);或者write(pipefd[1]);向这个文件读写数据其实是在读写内核缓冲区**。pipe函数调用成功返回0，调用失败返回-1。

#### 通信机制

![](http://oklbfi1yj.bkt.clouddn.com/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/2.jpg)

### 示例

#### 代码

```c++
#include <iostream>
#include <stdio.h>
#include <unistd.h>
#include <unistd.h>

using namespace std;

int main(int argc, char const *argv[]) {
    int pipefd[2];
    pipe(pipefd); // 在内核缓冲区创建管道

    pid_t r_pid;
    r_pid = fork();

    char read_buf[100] = {0};
    char write_buf[100] = "hello";
    
    if (r_pid == 0) {
    	close(pipefd[0]);
    	printf("son: sending %s, size = %d\n", write_buf, (int)sizeof(write_buf));
    	write(pipefd[1], write_buf, sizeof(write_buf));
    	close(pipefd[1]);
    }
    if (r_pid > 0) {
        close(pipefd[1]);
        read(pipefd[0], read_buf, 100);
        printf("parent: receive %s, size = %d\n", read_buf, (int)sizeof(read_buf));
        close(pipefd[0]);
    }
	
	return 0;
}
```

结果：

![](http://oklbfi1yj.bkt.clouddn.com/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/3.png)

#### 解释

1、父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。

2、父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。

3、父进程关闭管道写端，子进程关闭管道读端。子进程可以往管道里写，父进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。

### 注意点

**两个进程通过一个管道只能实现单向通信**，比如最上面的例子，父进程读子进程写，如果有时候也需要子进程读父进程写，就必须另开一个管道。
管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。
**通信进程需要是父子进程关系，这使得它的应用受到了很大限制，这时我们可以用命名管道来解决。**

## 进程通信必须借助操作系统内核原因

首先，**进程通信是指在进程间传输数据(交换信息)**。

因为每个进程有自己独立的地址空间。在操作系统和硬件的**地址保护机制**下，进程无法访问其他进程的地址空间，限制每个进程只能访问自己的地址空间。所以**必须借助于操作系统的系统调用函数实现进程之间的通信**。

















