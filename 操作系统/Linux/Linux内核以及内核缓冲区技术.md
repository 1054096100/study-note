# Linux内核以及内核缓冲区技术

## GNU/Linux 操作系统的基本体系结构

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E4%BB%A5%E5%8F%8A%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2%E5%8C%BA%E6%8A%80%E6%9C%AF/1.jpg)

最上面是用户（或应用程序）空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。

GNU C Library （glibc）也在这里。它**提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制**。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。

**Linux 内核可以进一步划分成 3 层**。最上面是系统调用接口，它实现了一些基本的功能，例如 read 和 write。系统调用接口之下是**内核代码，可以更精确地定义为独立于体系结构的内核代码**。**这些代码是 Linux 所支持的所有处理器体系结构所通用的**。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。

## 内核缓冲区

为什么总是需要将数据由内核缓冲区换到用户缓冲区或者相反呢？

因为，用户进程是运行在用户空间的，不能直接操作内核缓冲区的数据。 用户进程进行系统调用的时候，会由用户态切换到内核态，待内核处理完之后再返回用户态。

应用缓冲技术能很明显的提高系统效率。内核与外围设备的数据交换，内核与用户空间的数据交换都是比较费时的，**使用缓冲区**就是为了优化这些费时的操作。其实核心到用户空间的操作本身是不buffer的，是由I/O库用buffer来优化了这个操作。比如read本来从内核读取数据时是比较费时的，所以一次取出一块，**以避免多次陷入内核**。

应用内核缓冲区的 主要思想就是一次读入大量的数据放在缓冲区，需要的时候从缓冲区取得数据。

管理员模式和用户模式之间的切换需要消耗时间，但相比之下，**磁盘的I/O操作消耗的时间更多**（所以在这段时间请求磁盘数据的进程会被挂起），为了提高效率，内核也使用缓冲区技术来提高对磁盘的访问速度。磁盘是数据块的集合，**内核会对磁盘上的数据块做缓冲。内核将磁盘上的数据块复制到内核缓冲区中**，当一个用户空间中的进程要从磁盘上读数据时，此时要从用户态陷入到内核态，而**内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程的缓冲区中**。**当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求队列，然后把该进程挂起（因为磁盘的I/O操作消耗的时间比切换进程消耗的时间更多），接着为其 他进程服务**。一段时间之后(其实很短的时间)，内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程的缓冲区中，最后唤醒被挂起的进程。

## 理解内核缓冲区技术的原理好处

有助于更好的掌握系统调用`read`和`write`，**read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换**。

从理论上讲，内核可以在任何时候写磁盘，但并不是所有的write操作都会导致内核的写动作。**内核会把要写的数据暂时存在内核缓冲区中，积累到一定数量后再一 次写入**。有时会导致意外情况，比如断电，内核还来不及把内核缓冲区中的数据写道磁盘上，这些更新的数据就会丢失。

应用内核缓冲技术导致的结果是：**提高了磁盘的I/O效率**；**优化了磁盘的写操作**；需要及时的将缓冲数据写到磁盘。

















































