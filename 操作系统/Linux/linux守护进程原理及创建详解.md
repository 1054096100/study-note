# linux守护进程原理及创建详解

​	在linux或者unix操作系统中在系统的引导的时候会开启很多服务，这些服务就叫做守护进程。守护进程是脱离于终端并且在后台运行的进程。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断

​	每个守护进程都会监听一个端口，一些常用守护进程的监听端口是固定的，像httpd监听80端口， sshd监听22端口等；我们可以将其理解为责任制，时候等待，有求必应

### 一. 守护进程简介

​	守护进程，也就是通常说的Daemon进程，是Linux中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程常常在系统引导装入时启动，在系统关闭时终止。Linux系统有很多守护进程，大多数服务都是通过守护进程实现的

​	由于在Linux中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。但是守护进程却能够突破这种限制，它从被执行开始运转，直到整个系统关闭时才退出。如果想让某个进程不因为用户或终端或其他地变化而受到影响，那么就必须把这个进程变成一个守护进程

### 二.守护进程的分类

​	**独立启动**（stand_alone):该类进程启动后就常驻内存，所以会一直占用系统资源。其最大的优点就是它会一直启动，当外界有要求时相应速度较快，像httpd等进程

​	**超级守护进程**：系统启动时由一个统一的守护进程xinet来负责管理一些进程，当相应请求到来时需要通过xinet的转接才可以唤醒被xinet管理的进程。这种进程的优点时最初只有xinet这一守护进程占有系统资源，其他的内部服务并不一直占有系统资源，只有数据包到来时才会被xinet管理员来唤醒。并且我们还可以通过xinet来对它所管理的进程设置一些访问权限，相当于多了一层管理机制

### 三：创建守护进程

![](http://oklbfi1yj.bkt.clouddn.com/linux%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%AF%A6%E8%A7%A3/1.PNG)

**创建子进程，父进程退出**

　　这是编写守护进程的第一步。由于守护进程是脱离控制终端的，因此，完成第一步后就会在Shell终端里造成一程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离

　　**在Linux中父进程先于子进程退出会造成子进程成为孤儿进程，而每当系统发现一个孤儿进程是，就会自动由1号进程（init）收养它，这样，原先的子进程就会变成init进程的子进**

**在子进程中创建新会话**

　　这个步骤是创建守护进程中最重要的一步，虽然它的实现非常简单，但它的意义却非常重大。在这里使用的是系统函数setsid，在具体介绍setsid之前，首先要了解两个概念：进程组和会话期
　　进程组：是一个或多个进程的集合。进程组有进程组ID来唯一标识。除了进程号（PID）之外，进程组ID也是一个进程的必备属性。每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID。且**该进程组ID不会因组长进程的退出而受到影响**
　　会话周期：会话期是一个或多个进程组的集合。**通常，一个会话开始与用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期**
　　接下来就可以具体介绍setsid的相关内容：
　　setsid函数作用：
　　	setsid函数用于创建一个新的会话，并担任该会话组的组长。调用setsid有下面的3个作用：
　　	一、让进程摆脱原会话的控制
　　	二、让进程摆脱原进程组的控制
　　	三、让进程摆脱原控制终端的控制

　　那么，在创建守护进程时为什么要调用setsid函数呢？由于创建守护进程的第一步调用了fork函数来创建子进程，再将父进程退出。**由于在调用了fork函数时，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变，因此，还还不是真正意义上的独立开来，而setsid函数能够使进程完全独立出来，从而摆脱其他进程的控制**











