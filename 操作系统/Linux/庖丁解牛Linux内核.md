# 庖丁解牛Linux内核

## 1、计算机是如何工作的

### 存储程序计算机工作模型

#### 什么是冯诺伊曼体系结构

指的是**存储程序**计算机。从两个层面来讲

一个层面就是从硬件的角度来看（也就是计算机的主板）：

![1](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/1.png)

也就是通过IP这个指针，CPU一条一条指令的执行。也就是说，从main函数开始，一条一条指令往下读。（注意，每条指令的长度可能不同）

但是要注意的就是，在写汇编代码的时候，**IP寄存器不能被直接修改**，只能通过特殊指令简介修改，例如call指令可以简介修改IP寄存器。

从程序员的角度来看：

![2](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/2.png)

即内存保存指令和数据，CPU解释执行指令。

### X86汇编基础

![3](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/3.png)

其中，这里的`b`、`w`、`l`、`q`指的是`mov`指令后面跟的东西（例如movl）。

立即数是以`$`开头的数值。所以第二行的`$0x123`代表立即数`0x123`，而第三行的`0x123`代表直接访问`0x123`这块内存地址的数据。

类似的`%ebx`和`(%ebx)`也是有区别的。以`%`开头的代表`ebx`是一个寄存器，`(%ebx)`指的是寄存器ebx里面存了一个内存地址，然后去这块内存地址的数据。（所以这种用法和`$`很像）

![4](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/4.png)

### 反汇编一个简单的C程序分析其汇编指令执行过程

代码如下：

```c

int g(int x) {
	return x + 3;
}

int f(int x) {
	return g(x);
}

int main(int argc, char const *argv[]) {
	
	return f(8) + 1;
}
```

然后把C源程序反汇编成一个汇编代码：

```shell
gcc -S -o main.s main.c -m32
```

其中，`main.s`指的是生成的汇编代码文件，`-m32`指的是生成32位的汇编代码。

在汇编代码的文件里面，所有以`.`开头的都是用于链接时的辅助信息，不会在实际被执行。

我们把这些辅助信息删除后，得到了干净的汇编代码：

![5](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/5.png)

其中`leave`指令的意思，可以理解为宏指令，由`mov`和`pop`组成：

![6](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/6.png)

可以看出，`enter`指令是先保存了当前栈的基地址，然后再把`esp`赋值给`ebp`，也就是此时的栈底和栈顶是指向一样的内存地址，因此相当于另起了一个栈帧。

同理，`leave`指令相当于撤销这个栈帧。

**函数的返回值默认使用eax寄存器存储返回给上一级函数**。

## 2、操作系统是如何工作的

### 函数调用堆栈

#### 三个法宝

存储程序计算机、函数调用堆栈、中断机制

##### 堆栈

![7](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/7.png)

![8](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/8.png)

![9](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/9.png)

![10](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/10.png)

![11](/Users/hantaohuang/Desktop/庖丁解牛Linux内核/11.png)

从p2对应的汇编代码可以看出，没有在p2的栈帧中为形参x、y分配空间，函数p2的形参是保存在前一个函数的栈帧里面。

##### 中断机制

之前的那些压栈操作、call、ret指令都是连续的一个指令流（即一条一条指令去执行），所以CPU很笨，只能一条指令一条指令执行。但是这么严密的一条指令一条指令执行，它怎么从一个进程跳到另一个进程去执行？然后再跳回来还能接着执行？这就需要用到**中断机制**。在发生中断的时候，不仅仅是像call指令一样把`cs:ip`压栈，还做了其他的一些操作。

### 利用mykernel实验模拟计算机硬件平台

#### mykernel实验背后涉及的思想

中断机制做的事情：当一个中断信号发生的时候，cpu把当前的ip、bp、sp都压到一个叫做内核堆栈的另外一个堆栈里面去，然后再把ip指向中断处理程序的入口，然后就开始执行中断处理程序。

#### 利用mykernel实验模拟计算机硬件平台





































































































































