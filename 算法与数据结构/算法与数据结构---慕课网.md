# 算法与数据结构---慕课网

### 1、选择排序（  o(n²)  ）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/1.gif)

两重循环

每次循环找出最小（最大）的那个值，进行交换即可

```c++
/* 选择排序 */
template<typename T>
void selectionSort(T arr[], int n) {
	for (int i = 0; i < n; i++) {
		int minIndex = i;
		for (int j = i + 1; j < n; j++) {
			if (arr[j] < arr[minIndex]) {
				minIndex = j;
			}
		}
		swap(arr[i], arr[minIndex]);
	}
}
```

### 2、插入排序（  o(n²)  ）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/2.gif)

两重循环

和打扑克牌的时候，给扑克牌排序很像

**适用于：**

近乎有序的序列（此时的时间复杂度会接近 **o(n)** ）

作为其他更加复杂的排序的**子过程**出现

可以衍生出**希尔排序**

一旦找到了合适的位置，就可以终止了。我们可以发现，因为，前面的数字已经排好了序，所以，只要发现待排序的数字大于或等于比较的那个数字，就可以插入了，不需要继续比较了（正是因为可以提前终止扫描，所以所需的时间比选择排序要少<选择排序需要扫描完整个数组>）

假设这个数组本身基本上是有序的，在这种情况下内层循环可以很快的找到它应该插入的位置，此时，插入排序的效率会非常高

```c++
/* 插入排序 */
template<typename T>
void insertionSort(T arr[], int n) {
	for (int i = 1; i < n; i++) {
		// 寻找元素arr[i]合适的插入位置
		for (int j = i; j > 0; j--) {
			if (arr[j] < arr[j - 1]) {
				swap(arr[j], arr[j - 1]);
			}
			else {
				break;
			}
		}
	}
}
```

#### 插入排序的优化

因为插入排序的一个明显的问题就是，交换的次数太多了，十分耗时间（而选择排序每次遍历都是先比较完，最后只交换一次（而每次交换都要赋值三次<三变量法>），所以，实际上，当数据量很大的时候，插入排序的性能并没有比选择排序好）

##### 使插入排序每次遍历完只交换一次

```c++
/* 插入排序 */
template<typename T>
void insertionSort(T arr[], int n) {
	for (int i = 1; i < n; i++) {
		// 寻找元素arr[i]合适的插入位置
		T e = arr[i];
		int j; // j 保存元素e应该插入的位置
		for (j = i; j > 0; j--) {
			if (e < arr[j - 1]) {
				arr[j] = arr[j - 1];
			}
			else {
				break;
			}
		}
		arr[j] = e;
	}
}
```

### 3、nlogn 比 n²快多少

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/3.PNG)

### 4、归并排序（  o(nlogn)  ）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/4.gif)

总体思路就是找出每一次归并的left和right。然后再来进行归并。

先把数组分成一半，然后想办法把左边的数组给排序，把右边的数组给排序（一直递归下去）

#### 分成递归分成一半然后归并的原因

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/5.PNG)

一步一步划分，到第三次划分的时候，每一部分就只剩下一个元素了

为什么是分了三次每一部分就只剩下一个元素了呢？

因为`8/2=4`、`4/2=2`、`2/2=1`。把这个顺序倒过来思考也就是`2的n次方=8`，解得n为 log 2为底8的对数（思想是二分法）

所以说，划分的时间复杂度是**o(logn)**

然后因为归并的时候，时间复杂度是**o(n)**，所以，总的时间复杂度是**o(nlogn)**

#### 实现

不能和前面的选择排序、插入排序一样直接在这个数组上通过交换位置完成这个过程

##### 以空间换时间（需要使用o(n)复杂度的额外的空间）

我们**需要开辟一个同样大小的临时的空间**来辅助我们完成这个归并过程（把两个排好序的数组合并成一个排好序的数组）。因为归并排序不是去交换两个元素，而是去比较两个元素。所以，如果不使用额外的空间，那么就可能会覆盖掉前面的元素。

但是在现代计算机中，时间的效率要比空间的效率重要得多，所以设计一个算法，通常是优先考虑时间复杂度（除非我们意识到了空间复杂度是我们算法的重要瓶颈）

##### 使用3个索引在数组中进行追踪

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/6.PNG)

初始时候红色的分别指向小数组开头的位置，蓝色的也是

其中蓝色的箭头表示**最终**在归并的过程中我们需要跟踪的位置，而两个红色的箭头分别指向这两个排好序的数组当前要考虑的元素

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/7.PNG)

首先看1和2这两个元素（红色的）谁应该先放到最终的数组中。因为1比2小，所以1应该放到最终的数组中：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/8.PNG)

然后，蓝色的箭头就可以考虑下一个位置了：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/9.PNG)

而且原来红色的1所在的箭头也可以考虑下一个元素了：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/11.PNG)

然后就可以考虑2和4这两个元素谁更小，显然2更小（一直重复这样的操作即可归并完成）

##### 防止数组越界

定义如下变量：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/12.PNG)

##### 代码(使用递归实现自顶向下的归并排序)

```c++
#include <iostream>
#include <algorithm>
#include "SortTestHelper.h"

using namespace std;

/*
归并排序的归并部分
将arr[l...mid]和arr[mid + 1...r]两部分进行归并
*/
template<typename T>
void __merge(T arr[], int l, int mid, int r) {//这里的l和r是相对于那个子数组的还没排好序的上一级大数组而言的
	T aux[r - l + 1]; // 需要一个临时空间
	for (int i = l; i <= r; i++) {
		aux[i - l] = arr[i]; //aux是一个个子数组，所以一直是从0开始的，而arr是从l开始的，所以它们之间有一个l距离的偏移量
	}

	//正式进行归并的操作
	int i = l, j = mid + 1; // 其中i，j是在子数组中移动的，k是在arr这个大数组中移动的
	for (int k = l; k <= r; k++) {// k是arr待存放的位置（当所有都归并完了以后，arr就是有序的了）
		/* 前面的两个if用来判断数组下标有没有越界 */
		if (i > mid) { // 如果K还没有遍历完，但是左边的数组已经遍历完了，说明右边的还没有归并完，此时直接把右边的子数组归并即可
			arr[k] = aux[j - l];
			j++;
		}
		else if (j > r) { // 同上
			arr[k] = aux[i - l];
			i++;
		}
		else if (aux[i - l] < aux[j - l]) {
			arr[k] = aux[i - l];
			i++;
		}
		else {
			arr[k] = aux[j - l];
			j++;
		}
	}
}


/*
递归使用归并排序，对arr[l...r]的范围进行排序

参数1：需要排序的数组
参数2：需要排序的数组的第一个元素的下标
参数3：需要排序的数组的最后一个元素的下标
*/
template<typename T>
void __mergeSort(T arr[], int l, int r) {
	if (l >= r) { // 此时子数组只有一个元素，不需要再对半分了，所以返回
		return;
	}

	/* 开始对数组进行递归划分，也就是一半的一半的一半... */
	int mid = (l + r) / 2;
	/* 对左半部分进行划分 */
	__mergeSort(arr, l, mid);
	/* 对右边半部分进行划分 */
	__mergeSort(arr, mid + 1, r);
	/* 划分完了之后，进行归并 */
	__merge(arr, l, mid, r);

}


/*
归并排序
参数1：需要排序的数组
参数2：数组中元素的个数
*/
template<typename T>
void mergeSort(T arr[], int n) {

	__mergeSort(arr, 0, n - 1);
}

int main(int argc, char const *argv[])
{
	int n = 50000;
	int* arr = SortTestHelper::generateRandomArray(n, 0, n);

	mergeSort(arr, 50000);

	SortTestHelper::printArray(arr, n);

	return 0;
}
```

#### 应用场景

求逆序对

#### 和插入排序比较

在一般情况下，归并排序要比插入排序快。但是，在数字序列近乎有序的情况下，插入排序要比归并排序快

#### 优化

##### 对于数组本身近乎有序的情况

在上面代码中的归并的过程中，无论两个子数组直接合成的大数组是否已经有序了，都会进行归并的操作，但是，**如果直接合成的大数组实际上已经有序了，是可以不需要归并了**：

```C++
template<typename T>
void __mergeSort(T arr[], int l, int r) {
	if (l >= r) { // 此时子数组只有一个元素，不需要再对半分了，所以返回
		return;
	}

	/* 开始对数组进行递归划分，也就是一半的一半的一半... */
	int mid = (l + r) / 2;
	/* 对左半部分进行划分 */
	__mergeSort(arr, l, mid);
	/* 对右边半部分进行划分 */
	__mergeSort(arr, mid + 1, r);
	/* 划分完了之后，进行归并 */
	if (arr[mid] > arr[mid + 1]) {// 两个子数组直接合并的大数组无序，进行归并
		__merge(arr, l, mid, r);
	}
}
```

##### 对于递归到底的情况

对于近乎所有的高级排序算法，都存在一种优化情况，那就是递归到底的情况

例如，在上面代码中，递归分割子数组的时候，是到数组只有一个元素的时候，才开始返回回去的。实际上，在子数组的数据量比较小的时候，可以转而使用插入排序，来提高一些性能。这是基于两个原因：

1、一方面，当子数组数据量小的时候，整个数组近乎有序的概率就会比较大，此时插入排序有优势

```C++
template<typename T>
void __mergeSort(T arr[], int l, int r) {
	if (r- l <= 15) { // 此时子数组有16个元素，我们之间对它进行排序后返回，之后就不用继续对半划分了
		insertionSort(arr, l, r);
		return;
	}

	/* 开始对数组进行递归划分，也就是一半的一半的一半... */
	int mid = (l + r) / 2;
	/* 对左半部分进行划分 */
	__mergeSort(arr, l, mid);
	/* 对右边半部分进行划分 */
	__mergeSort(arr, mid + 1, r);
	/* 划分完了之后，进行归并 */
	if (arr[mid] > arr[mid + 1]) {// 两个子数组直接合并的大数组无序，进行归并
		__merge(arr, l, mid, r);
	}
}
```

#### 使用迭代自底向上的归并排序

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/13.gif)

##### 代码

```c++
template <typename T>
void mergeSortBU(T arr[], int n) {
	for (int size = 1; size <= n; size += size) {
         for (int i = 0; i + size < n; i += size + size) {
             __merge(arr, i, i + size - 1, min(i + size + size- 1, n - 1));
         }
	}
}
```

### 5、快速排序（ o(nlogn) ）

#### 总体思路

每次从当前考虑的数组中选择一个元素，以这个元素为标定点（一般都是选数组的第一个元素）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/14.PNG)

然后把这个元素想办法挪到数组排好序后的那个位置（其它的可能还没有排好序）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/15.PNG)

此时，这整个数组就有了一个性质：4前面的所有元素都是小于4的，4后面的元素都是大于4的

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/16.PNG)

之后要做的就是对小于4这部分的子数组和大于4的这部分子数组分别继续使用快速排序，逐渐递归下去，完成整个排序过程

所以，快速排序最重要的就是**如何把这个选定的元素挪到正确的位置上**（这个过程的时间复杂度是logn的，所以，让n个元素都挪到正确的位置的时间复杂度为nlogn），而这个过程也正是快速排序的核心。

通常，我们管这个子过程叫做**Partition**（也就是把整个数组分成两部分）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/17.PNG)

在这个过程中，我们通常都使用**整个数组的第一个元素**来作为我们分界的标志点：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/18.PNG)

对于这个数组中的第一个元素，我们把它叫做`l`（它的值对应为 v），之后，我们逐渐遍历右边没有被访问的元素。在遍历的过程中，我们将让整个数组一部分小于`v`，另一部分是大于`v`这个元素。在这个过程中，我们需要记录哪个是小于`v`和大于`v`的分界点，用索引`j`来记录这个位置（j所指的是**小于v的最后一个元素**）。当前访问的元素叫做`i`

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/19.PNG)

接下来讨论`i`这个位置，看我们如何来决定当前的元素到底要怎样变化使我们整个数组还保持这样的性质

##### 如果当前元素`e`大于`v`

那么，就直接把当前元素放在大于`v`后面的部分

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/20.PNG)

此时，整个数组就变成了这个样子：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/21.PNG)

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/22.PNG)

##### 如果当前元素`e`小于`v`

那么只需要当前`j`所指的后面一个元素和当前`i`所指的元素进行交换（因为 j + 1后面的元素是大于v的，所以可以放到原来 i 的那个位置）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/23.gif)

然后，j往后移一个位置（指向小于v的最后一个元素）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/24.PNG)

这时候，小于v的部分就多了一个元素，大于v的部分就少了一个元素

然后 i 往后移一下

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/25.PNG)

一直重复这个过程，在遍历完了之后（也就是 i 移到了最后），数组是如下情况：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/26.PNG)

最后，把`l`和`j`两个位置的元素交换：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/27.PNG)

此时，这个数组就像我们设想的那样真正分成了小于`v`和大于`v`的两部分，而`v`这个元素则放在了它应该在的位置，此时，指向`v`这个元素的索引就是`j`这个位置（所以，每次进行partition的操作都可以返回一个分界线，然后在这个分界线的基础上继续进行partition操作）

对以上过程进行递归即可

**注意：上面的过程中，红色的那个v是不属于任何一个部分的，因为它将来是要成为分界点的**

#### 代码实现

```c++
#include <iostream>
#include <algorithm>
#include "SortTestHelper.h"

using namespace std;

/*
对 arr[l...r]部分进行partition操作，其中r是每一个需要快速排序的数组的最后一个元素
返回一个索引值p，使得arr[l...p - 1] < arr[p]; arr[p + 1...r] > arr[p]
*/
template<typename T>
int __partition(T arr[], int l, int r) {
	T v = arr[l];

	// arr[l + 1...j] < v; arr[j + 1...i) > v 因为i是当前需要和v比较的，所以还不确定，因此不包括i
	int j = l;
	for (int i = l + 1; i <= r; i++) { // 无论当前i所处的值是大于v还是小于v，i都要往后移
		if (arr[i] < v) {
		    swap(arr[j + 1], arr[i]);
		    j++;
		}
	}

	swap(arr[l], arr[j]);

	return j;
}

/*
对 arr[l...r]部分进行快速排序，其中r是每一个需要快速排序的数组的最后一个元素
*/
template<typename T>
void __quickSort(T arr[], int l, int r) {
	if (l >= r) { // 此时不需要排序了（因为数组里只有一个元素）
		return;
	}
	// 快速排序的过程
	int p = __partition(arr, l, r);
	__quickSort(arr, l, p - 1);
	__quickSort(arr, p + 1, r);
}

template<typename T>
void quickSort(T arr[], int n) {
	__quickSort(arr, 0, n - 1);
}

int main(int argc, char const *argv[])
{
	int n = 100000;
	int *arr = SortTestHelper::generateRandomArray(n, 0, n);
    
	quickSort(arr, n);
    
	SortTestHelper::printArray(arr, n);
	return 0;
}
```

#### 优化方案

##### 优化一

和插入排序的优化方案一样，在递归的到块结束的时候，可以使用插入排序

```c++
template<typename T>
void __quickSort(T arr[], int l, int r) {
	if (r - l <= 15) { // 当数组元素个数小于等于16个的时候，就使用插入排序
         insertionSort(arr, l, r);
         return;
	}
	// 快速排序的过程
	int p = __partition(arr, l, r);
	__quickSort(arr, l, p - 1);
	__quickSort(arr, p + 1, r);
}
```

##### 优化二

在数组近乎有序的情况下，快速排序会非常的慢（因为此时每次划分的花，得到的数据结构是链表，而不是左右平衡的二叉树。对10万个数据排序，大概需要51秒；而优化了的归并排序此时会非常的快，只需要0.1秒左右），此时的快速排序会退化为**o(n²)**的级别

**分析**；

归并排序之所以是**o(nlogn)**级别的算法，这是因为在每次划分的时候，我们都把上一层的数组**一分为二**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/28.PNG)

整个层数是**logn**层的（每划分一次，就得到一层，所以是**logn**层），所以整个算法就是**nlogn**级别的

实际上，快速排序也是将整个数组一分为二的过程，只不过这个分发不一样。对于快速排序来说，我们是需要找到一个标定点，以这个标定点进行划分的。这样一来，快速排序就会和归并排序存在一个很大的不同。**归并排序可以保证每次都把数组一分为二，而快速排序却没有这个保证**，换句话来说，分出来的子数组可能是一大一小

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/29.PNG)

我们进一步去分的话，依然可能会存在这种情况

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/30.PNG)

此时，快速排序生成的这棵递归树的平衡度就比归并排序要差，所以**不能保证这棵树的高度是logn**，很有可能比logn要高

**快速排序最差的情况（退化为o(n²)）**

也就是整个数组完全有序的情况

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/31.PNG)

这个递归树的高度为 n ，这棵递归树整个可以看作是一个链表

这棵树的高度是n，我们在每层处理的时候，又用o(n)的复杂度，此时，快速排序就退化成了一个o(n²)级别的算法

**优化方法**

因为我们是固定的选用了最左边的那个元素作为标定元素，所以会出现上面的那种结果。我们希望的是尽可能的选择整个数组中间的元素作为标定元素。虽然我们不能非常快速、准确的定位那个元素，但是我们只要随机选择一个元素就好了。我们可以用数学方法证明出来此时快速排序的时间复杂度的期望值是**nlogn**（这里的期望值指的是平均值，而不代表每次都是**nlog**）。在这种情况下（指的是数组完全有序），退化为o(n²)级别的排序算法的可能性是非常非常低的（因为，在第一层的时候，有n个元素，要选到最小的那个元素的概率是1/n；在第二层的时候，要选到最小的概率是1/(n - 1)，以此类推，把这些概率乘起来，得到的概率值趋近于0）

 ```c++
template<typename T>
int __partition(T arr[], int l, int r) {
	swap(arr[l], arr[rand()%(r - l + 1) + l]); // 随机从[l, r]范围内选取一个元素和最左边的元素交换（所以，还是以最左边的作为标定）

	T v = arr[l];

	// arr[l + 1...j] < v; arr[j + 1...i) > v 因为i是当前需要和v比较的，所以还不确定，因此不包括i
	int j = l;
	for (int i = l + 1; i <= r; i++) {
		if (arr[i] < v) {
		    swap(arr[j + 1], arr[i]);
		    j++;
		}
	}

	swap(arr[l], arr[j]);

	return j;
}

template<typename T>
void quickSort(T arr[], int n) {
	srand(time(NULL));
	__quickSort(arr, 0, n - 1);
}
 ```

#### 应用场景

求第 n 大的数

#### 时间复杂度证明

关键是证明partiton操作所需的时间复杂度

首先证明一下求第 n 大的数的时间复杂度是O(n)，证明如下：

因为partition操作每次都会把数组划分成两半，但是我们只需要在其中的一半查找目标值即可，所以时间复杂度为：

```
   O(n + n / 2 + n / 4 + n / 8 + …… + 1)
 = O(n(1 / 2 + 1 / 4 + 1 / 8 + ...... + 1 / n))
 = O(n)        因为后面的是一个等比数列求和，它是趋近于一个常数的，所以最终是O(n)
```

至于完整的快速排序，它的时间复杂度证明为：

```
因为完整的快速排序它每次都是需要去遍历所有的小段，因此每次的时间复杂度是O(n)。至于有多少次呢？也就是把整个数组对半划分几次后每个小段只有一个元素？答案是logn。所以快速排序最终的时间复杂度是O(nlogn)
```

### 6、双路快速排序

当数组中含有大量的重复键值的时候，会出现递归树不平衡的情况

之前的讨论没有考虑 e 等于 v 的情况，我们上面讨论的是，当 e 小于 v 的时候，把 e 放到小于 v 的部分，否则的话，放到大于 v 的部分（也就是说，我们的代码隐藏的把等于 v 的部分放到了大于 v 的里面）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/32.PNG)

对于每一个键值来说，如果重复的元素太多，就会有大量的 e 等于 v 的话，就会出现递归树不平衡的情况（此时，快速排序就会退化成o(n²)级别的算法）：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/33.PNG)

此时，我们可以采用双路快速排序

#### 总体思路

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/34.PNG)

 原来的快速排序是大于 v 和小于 v 的部分放在了数组的一端，而双路快速排序则是分别放在了数组的两端

首先，我们先从 i 这个位置进行扫描。当我们面对的元素仍然是小于 v 的时候就继续向后扫描，**直到碰到了某个元素它是大于等于 v ，停止扫描**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/36.PNG)

同样，对于 j 也是这样的，从 j 向前扫描，如果是大于 v 的话，继续扫描，**直到碰到某个元素它是小于等于 v ，停止扫描**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/37.PNG)

此时，就可以把两边绿色的部分，分别归并到橙色和紫色的部分

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/38.PNG)

然后，i 和 j 所指的元素交换一下值即可

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/39.PNG)

然后，**i 后移，j 前移**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/40.PNG)

**直到 i < j**，就代表整个数组遍历完毕了

通过刚才的逻辑，其实橙色的部分是小于等于 v 的元素，而紫色的部分是大于等于 v 的元素

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/41.PNG)

通过这种方法，这种 partition 的方式把等于v的这个元素分散到了左右两部分（因为，当 i 和 j 都等于 v 的时候，i 和 j 所指的值仍然要交换一下位置）。这样，就不会有大量的等于v的元素集中在橙色或者是紫色

#### 代码实现

```c++
#include <iostream>
#include <ctime>
#include <algorithm>
#include "SortTestHelper.h"

using namespace std;

/*
对 arr[l...r]部分进行partition操作，其中r是每一个需要快速排序的数组的最后一个元素
返回一个索引值p，使得arr[l...p - 1] < arr[p]; arr[p + 1...r] > arr[p]
*/
template<typename T>
int __partition2(T arr[], int l, int r) {
	swap(arr[l], arr[rand() % (r - l + 1) + l]); // 避免在数组近乎有序的时候效率很低

	T v = arr[l];

	// arr[l + 1...i) <= v; arr(j...r] >= v
	int i = l + 1, j = r;
	while (true) {
		while (i <= r && arr[i] < v) {
			i++;
		}
		while ((j >= l + 1) && (arr[j] > v)) {
			j--;
		}

		if (i > j) { // 说明当 i 等于 j 的时候，也要交换一下值
			break;
		}
		else {
			swap(arr[i], arr[j]);
			i++;
			j--;
		}
	}

	swap(arr[l], arr[j]); // // 考虑最终 i  > j 的情况，因为最后 j 所指的位置是小于等于v的那部分数组，而 i 最后所指的位置是大于等于v的那部分数组。而v所在的位置也是属于小于等于v的部分，所以，是 l 和 j 所指的值进行交换。如果是 l 和 i 所指的位置进行交换，那么小于等于v的那部分数组的第一个元素就会是大于等于v的，明显不符合

	return j;
}

/*
对 arr[l...r]部分进行快速排序，其中r是每一个需要快速排序的数组的最后一个元素
*/
template<typename T>
void __quickSort2(T arr[], int l, int r) {
	if (l >= r) { // 此时不需要排序了（因为数组里只有一个元素）
		return;
	}
	// 快速排序的过程
	int p = __partition2(arr, l, r);
	__quickSort2(arr, l, p - 1);
	__quickSort2(arr, p + 1, r);
}

template<typename T>
void quickSort2(T arr[], int n) {
	srand(time(NULL));
	__quickSort2(arr, 0, n - 1);
}

int main(int argc, char const *argv[])
{
	int n = 100000;
	int *arr = SortTestHelper::generateRandomArray(n, 0, n);

	quickSort2(arr, n);

	SortTestHelper::printArray(arr, n);
	return 0;
}
```

### 7、三路快速排序

#### 总体思路

把整个数组**分成三个部分**：小于 v 、等于 v 、大于 v

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/42.PNG)

这样分隔之后，在递归的过程中，对于等于 v 的部分，我们就不用管了，只需要对小于 v 和大于 v 的进行处理

我们使用索引 lt 指向小于 v 的数组的最后一个元素，使用索引 gt 指向大于 v 的数组的最后一个元素

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/43.PNG)

使用索引 i 指向当前正在处理的元素：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/44.PNG)

这样，整个数组就分成了三部分

**现在分情况讨论要处理的 i 这个元素**

##### **如果 e等于v**

那么，直接纳入等于v的那部分：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/45.PNG)

然后 i 后移：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/46.PNG)

此时，整个数组就变成了：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/47.PNG)

##### **如果 e小于v**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/48.PNG)

那么，我们就需要把 i 所指的元素和等于 v 的第一个元素交换

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/49.PNG)

然后，数组就变成了：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/50.PNG)

然后，lt 和 i 索引都向后移：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/51.PNG)

##### 如果 e大于v

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/52.PNG)

此时，我们需要把 i 所指的元素和 gt - 1 所指的元素进行交换：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/53.PNG)

然后 **gt 后移**（**此时 i 不用后移**）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/54.PNG)

当整个数组处理完了以后，i 和 gt 两个索引重合（此时对整个数组操作完成）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/55.PNG)

最后，把 lt 和 l 位置的元素交换即可（此时数组变成完整的三部分）：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/56.PNG)

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/57.PNG)

之后，我们只需要对小于 v 和大于 v 的部分进行快速排序就好了，而等于 v 的部分则已经放在了数组中合适的位置

##### 三路快速排序的优点是

不需要对大量的等于 v 的元素重复的进行操作，可以一次性的少考虑很多元素

#### 代码实现

```c++
#include <iostream>
#include <ctime>
#include <algorithm>
#include "SortTestHelper.h"

using namespace std;

/*
对 arr[l...r]部分进行快速排序，其中r是每一个需要快速排序的数组的最后一个元素
*/
template<typename T>
void __quickSort3(T arr[], int l, int r) {
	if (l >= r) { // 此时不需要排序了（因为数组里只有一个元素）
		return;
	}
	// 快速排序的过程的partition部分
	swap(arr[l], arr[rand() % (r - l + 1) + l]);
	T v = arr[l];

	int lt = l; // arr[l + 1...lt] < v
	int gt = r + 1; // arr[gt...r] > v
	int i = l + 1; // arr[lt + 1...i] == v
	while (i < gt) {
		if (arr[i] < v) {
			swap(arr[i], arr[l + 1]);
			lt++;
			i++;
		}
		else if (arr[i] > v) {
			swap(arr[i], arr[gt - 1]);
			gt--;
		}
		else {
			i++;
		}
	}

	swap(arr[l], arr[lt]);
	__quickSort3(arr, l, lt - 1);
	__quickSort3(arr, gt, r);
}

template<typename T>
void quickSort3(T arr[], int n) {
	srand(time(NULL));
	__quickSort3(arr, 0, n - 1);
}

int main(int argc, char const *argv[])
{
	int n = 100000;
	int *arr = SortTestHelper::generateRandomArray(n, 0, n);

	quickSort3(arr, n);

	SortTestHelper::printArray(arr, n);
	return 0;
}
```

### 8、堆排序（ o(nlogn) ）

#### 普通队列

先进先出，后进后出

#### 优先队列(动态的)

出队顺序和入队顺序无关，和优先级有关

##### 应用场景

非常适合处理**动态的**情况。

在操作系统中执行任务的时候。操作系统要同时执行多个任务，实际上，操作系统是把执行周期划成了时间片，在每个时间片里，只能执行一个任务。那么究竟执行哪个任务呢？答案是每个任务都有一个优先级，操作系统将**动态的挑选一个优先级最高的执行**。此时就要选择优先队列来完成，操作系统的所有任务都进这个优先队列，由优先队列来调度操作系统每次要执行哪个任务。

因为任务的优先级是会动态变化的，所以需要一种数据结构去维护它，所以可以使用堆。因为它是一棵二叉树，复杂度与树的高度有关，所以可以比其他数据结构（例如普通数组、顺序数组）更好的维护这些优先级动态变化的任务。

##### 优先队列的实现

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/58.PNG)

对于总共有 n 个请求：

使用普通数组或者顺序数组，最差情况：O(n²)

使用堆：O(nlgn)

#### 堆的基本实现

因为，堆的复杂度是O(lgn)级别的，所以，它是一个树形结构。最为经典的一种实现就是二叉堆，相应的它对应的就是一棵二叉树

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/59.PNG)

##### 二叉堆的特点（最大堆）

**1、每一个子节点都小于它的父节点**（但是并不意味着层数越高，节点越大）

**2、二叉堆是一棵完全的二叉树**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/60.PNG)

##### 用数组存储二叉堆

因为堆是一种完全二叉树，所以可以用数组来存放

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/61.PNG)

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/62.PNG)

父子节点的关系：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/63.PNG)

##### 向最大堆中添加元素（Shift Up）

因为**最大堆是个完全二叉树**，我们很容易想到添加一个元素就是在数组最后一个元素的后面添加。但是，这可能会违背最大堆的定义。例如：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/64.PNG)

很明显，52不应该在11的位置

此时，我们需要让52逐步的和它的父节点比较，如果大于父节点，那么和父节点交换值

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/65.gif)

##### 代码实现

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <ctime>
#include <cmath>
#include <cassert>

using namespace std;

template<typename Item>
class MaxHeap
{
private:
    Item* data; // 因为并不知道数组中数据有多大，所以定义成指针类型，而不使用[]
    int count;
    int capacity;
    void shiftUp(int k) {
    	while ((k > 1) && (this->data[k / 2] < this->data[k])) { // 有索引就要考虑索引越界的问题，当k是父节点的时候，就不需要进行调整了
    	    swap(this->data[k / 2], this->data[k]);
    	    k /= 2; // 更新一下 k，到达原来的 k 的父节点的位置
    	}
    }
public:
	/*
    初始化数据

    第一个参数：最大堆能够承载的元素个数
	*/
    MaxHeap(int capacity) {
        this->data = new Item[capacity + 1]; // 因为数据是从数组下标1开始的，所以需要 capacity + 1 的大小
        this->count = 0;
        this->capacity;
    }

    ~MaxHeap() {
    	delete[] this->data; // 因为在堆中申请了内存，所以需要手动释放
    }

    int size() {
    	return this->count;
    }

    bool isEmpty() {
    	return this->count == 0;
    }

    /*
	向最大堆添加元素

	参数1：需要添加的元素
    */
    void insert(Item item) {
    	if ((this->count + 1) <= (this->capacity)) {
    		exit(-1);
    	}

    	this->data[this->count + 1] = item; // 先把元素添加到数组末尾
    	this->count++;
    	this->shiftUp(this->count); // 把添加进去的元素移到合适的位置
    }

    void printArray() {
    	for (int i = 1; i < this->count + 1; i++) {
    		cout << this->data[i]<<" ";
    	}
    }
};

int main(int argc, char const *argv[])
{
	MaxHeap<int>* maxheap = new MaxHeap<int>(100);
	
	srand(time(NULL));
	for (int i = 0; i < 15; i++) {
		maxheap->insert(rand() % 100);
	}

	maxheap->printArray();

	return 0;
}
```

##### 从堆中取出一个（Shift Down）

对应着**出队**

从堆中取出一个元素，**只能取出根节点的那个元素**（对于最大堆来说，相当于**取出了优先级最大的那个元素**）

取出根节点后，整个堆中相当于少了一个元素，此时需要填补这个元素。方法是：**把整个堆的最后一个元素放到那个地方**（根节点）。因为，这样做就可以**保证这个堆仍然是完全二叉树**。此时，**`count`也要减1**（此时不用管索引为11的那个元素，因为我们是通过`count`来标识堆的边界。所以，索引11的那个值就用不到了，也就是说索引11的那个值不在堆中了）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/66.PNG)

此时，这棵完全二叉树不是一个最大堆。所以，我们需要**把这个根节点的元素往下挪，找到它合适的位置**

**比较方法：**

让这个需要挪到的节点和它的两个子节点比较，**把最大的子节点和它交换**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/67.gif)

##### 代码实现

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <ctime>
#include <cmath>
#include <cassert>

using namespace std;

template<typename Item>
class MaxHeap
{
private:
    Item* data; // 因为并不知道数组中数据有多大，所以定义成指针类型，而不使用[]
    int count;
    int capacity;

    /*
    向堆中添加了元素之后，整理这个堆（不希望在类外面调用，所以私有）

    参数1：堆中需要移动的那个元素的索引
    */
    void shiftUp(int k) {
    	while ((k > 1) && (this->data[k / 2] < this->data[k])) { // 有索引就要考虑索引越界的问题，当k是父节点的时候，就不需要进行调整了
    	    swap(this->data[k / 2], this->data[k]);
    	    k /= 2; // 更新一下 k，到达原来的 k 的父节点的位置
    	}
    }

    void shiftDown(int k) {
        while ((2 * k) <= (this->count)) { // 判断这个节点是否有孩子。在一棵完全二叉树里面，如果这个节点有左孩子，就说这个节点有孩子
            int j = 2 * k;

            if ((j + 1 <= this->count) && (this->data[j + 1] > this->data[j])) {
                j++;
            }

            if (this->data[k] >= this->data[j]) {
                break;
            }
            else {
            	swap(this->data[k], this->data[j]);
            	k = j;
            }
        }
    }

public:
	/*
    初始化数据

    第一个参数：最大堆能够承载的元素个数
	*/
    MaxHeap(int capacity) {
        this->data = new Item[capacity + 1]; // 因为数据是从数组下标1开始的，所以需要 capacity + 1 的大小
        this->count = 0;
        this->capacity;
    }

    ~MaxHeap() {
    	delete[] this->data; // 因为在堆中申请了内存，所以需要手动释放
    }
    
    /*
    计算堆中元素的个数
    */
    int size() {
    	return this->count;
    }
    
    /*
    判断堆是否为空
    */
    bool isEmpty() {
    	return this->count == 0;
    }

    /*
	向最大堆添加元素

	参数1：需要添加的元素
    */
    void insert(Item item) {
    	if ((this->count + 1) <= (this->capacity)) {
    		exit(-1);
    	}

    	this->data[this->count + 1] = item; // 先把元素添加到数组末尾
    	this->count++;
    	this->shiftUp(this->count); // 把添加进去的元素移到合适的位置
    }
    
    /*
    取出最大堆中最大的值（也就是根节点的值）
    */
    Item extractMax() {
        if (this->count < 1) {
        	exit(-1);
        }

        Item ret = this->data[1];

        swap(this->data[1], this->data[count]);
        count--; //此时，索引count所指的那个值不存在了
        shiftDown(1); //把此时的根节点下移到合适的位置

        return ret;
    }
    
    /*
    打印堆中的元素
    */
    void printArray() {
    	for (int i = 1; i < this->count + 1; i++) {
    		cout << this->data[i]<<" ";
    	}
    }
};

int main(int argc, char const *argv[])
{
	MaxHeap<int>* maxheap = new MaxHeap<int>(100);
	
	srand(time(NULL));
	for (int i = 0; i < 9; i++) {
		maxheap->insert(rand() % 100);
	}

	maxheap->printArray();

	cout<<endl;

	while (!maxheap->isEmpty()) {
		cout<<maxheap->extractMax()<<" ";
	}

	return 0;
}
```

#### 堆排序

##### 应用场景

在总体上是不如归并排序和快速排序，因此**在系统级别实现的算法中很少用堆排序（一般使用归并排序），堆这种数据结构更多的是用于动态数据的维护**

##### 总体思路

把要排序的数组放入堆中，然后把堆中的元素一个一个的取出来（此时取出的顺序就是从大到小的），给要排序的数组赋值。然后得到的数组就是有序的了

##### 代码实现

```c++
#include <iostream>
#include <algorithm>
#include "Heap.h"
#include "SortTestHelper.h"

using namespace std;

/*
堆排序（让数组从小到达排序）

参数1：需要排序的数组
参数2：数组的个数
*/
template<typename T>
void heapSort1(T arr[], int n) {
    MaxHeap<T> *maxheap = new MaxHeap<T>(n);        
    for (int i = 0; i < n; i++) { // 这操作是logn级别的（和层序有关）
    	maxheap->insert(arr[i]); // 把arr数组中的元素放入最大堆中
    }

    for (int i = n - 1; i >= 0; i--) { // 这操作是logn级别的（和层序有关）
    	arr[i] = maxheap->extractMax(); // 给arr反向赋值，让arr中的值从小到大排序
    }
}

int main(int argc, char const *argv[])
{
    int n = 100;

	int* arr = SortTestHelper::generateRandomArray(n, 0, n);
	SortTestHelper::printArray(arr, n);

	cout<<endl;

	heapSort1(arr, n);
	SortTestHelper::printArray(arr, n);

	return 0;
}
```

##### 算法复杂度

将n个元素逐个插入到一个空堆中，算法复杂度是**O(nlogn)**

##### 优化方案

**1、通过改变建堆的方式，来加快排序的过程**

上面的**heapSort1**的方法是添加一个元素后，就马上整理这棵二叉树，使得它变成堆

实际上，我们可以**先把这个数组想象成一棵二叉树，然后再来构建堆**

首先，这棵二叉树的叶子节点本身就是一个最大堆（堆中只有一个元素，所以一定是最大堆）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/68.PNG)

最后一个非叶子节点的索引：用树中的最后一个叶子节点的索引除以2可得（在图中是10 / 2 = 5）。所以索引为5的这个节点为**最后一个非叶子节点的索引**

##### Heapify过程

从后往前：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/69.gif)

##### 代码实现

```c++
    /*
    使用Heapify过程来建立最大堆

    参数1：需要建立最大堆的数组
    参数2：数组中的元素个数
    */
    MaxHeap(Item arr[], int n) {
        this->data = new Item[n + 1];
        this->capacity = n;

        for (int i = 0; i < n; i++) {
            this->data[i + 1] = arr[i];
        }

        this->count = n;

        for (int i = count / 2; i >= 1; i--) {
            shiftDown(i);
        }
    }
```

```c++
/*
堆排序（让数组从小到大排序）

参数1：需要排序的数组
参数2：数组的个数
*/
template<typename T>
void heapSort2(T arr[], int n) {
    MaxHeap<T> *maxheap = new MaxHeap<T>(arr, n); // 建立最大堆
    for (int i = n - 1; i >= 0; i--) {
        arr[i] = maxheap->extractMax();
    }
}
```

##### Heapify算法的复杂度

因为一上来，就把`n/2`个元素给排除出去了，所以肯定会更快

heapify的过程，算法复杂度为**O(n)**

#### 原地堆排序（ o(nlogn) ）

一个数组实际上就可以看作是一个堆（例如：Heapify过程）

使用原地堆排序可以把算法的**空间复杂度降到O(1)级别**

##### 总体思路

对于一个数组来说，我们可以使用**Heapify**的操作来使得这个数组变成最大堆。**变成最大堆之后，数组的第一个元素就是这个数组的最大值。**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/70.PNG)

此时，我们**让这个数组的第一个元素和最后一个元素进行交换。这样，就让这个数组的最后一个元素变成了整个数组的最大值**。此时，前面的数组（arr[0, n - 1]）就不是最大堆了

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/71.PNG)

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/72.PNG)

然后，我们对前面的数组进行**ShiftDown**的操作，使得前面的数组变成最大堆

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/73.PNG)

然后，把第一元素和倒数第二个元素进行交换，使得这整个数组的倒数第二个元素是第二大的

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/74.PNG)

一直循环下去即可排好序

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/75.PNG)

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/76.PNG)

##### 代码实现

```c++
#include <iostream>
#include <algorithm>
#include "SortTestHelper.h"

using namespace std;

/*
让二叉树的某个元素往下挪，让这棵二叉树变成最大堆

参数1：需要操作的这个数组
参数2：数组中元素的个数（用来标定这棵二叉树的的索引的最大值，判断是否越界）
参数3：需要挪动的那个元素的索引
*/
template<typename T>
void __shiftDown(T arr[], int n, int k) {
    while ((2*k + 1) < n) {
        int j = 2*k + 1;
        if ((j + 1 < n) && (arr[j + 1] > arr[j])) {
        	j++;
        }
        if (arr[k] >= arr[j]) {
        	break;
        }
        else {
        	swap(arr[k], arr[j]);
        	k = j;
        }
    }
}

/*
堆排序

参数1：要排序的数组
参数2：数组中元素的个数
*/
template<typename T>
void heapSort(T arr[], int n) {
    // heapify
    for (int i = (n - 1) / 2; i >= 0; i--) { // 由二叉树从上往下整理成最大堆
    	__shiftDown(arr, n, i);
    }
    for (int i = n - 1; i > 0; i--) { // 真正进行排序的过程
    	swap(arr[0], arr[i]); // 逐个的把大的元素放到数组的后面
    	__shiftDown(arr, i, 0);
    }
}

int main(int argc, char const *argv[])
{
	int n = 100;
	int* arr = SortTestHelper::generateRandomArray(n, 0, n);
	SortTestHelper::printArray(arr, n);
	cout<<endl;
	heapSort(arr, n);
	SortTestHelper::printArray(arr, n);

	return 0;
}
```

### 9、排序算法总结

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/77.PNG)

**平均时间复杂度**

平均时间复杂度不是说每次都是这个复杂度，而是包含了最好情况和最坏情况

**原地排序**

原地排序指的是可以在原数组上面进行操作，而不需要开辟额外的空间（通过直接在原数组上面交换元素来实现）

归并排序必须要使用额外的空间来完成归并的过程。所以，如果一个系统对空间相对比较敏感的话，归并排序可能就并不适合了

**额外空间**

因为插入排序和堆排序都可以在原数组上面直接完成，所以它所用的额外空间是O(1)级别的

对于快速排序，我们采用递归的方式来进行排序，这个递归过程有logn那么多层。**而那么多层递归，就要有相应的那么多的栈空间（栈帧）来保存每层递归中的临时变量，以供递归返回的时候继续使用**

#### 排序的稳定性

稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生改变

例如：

排序前：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/78.PNG)

排序后：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/79.PNG)

##### 插入排序

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/80.gif)

##### 归并排序

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/81.gif)

##### 解决排序算法不稳定的问题

通过自定义比较函数（运算符重载），让排序算法不存在稳定性的问题

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/82.PNG)

### 10、索引堆

原来的：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/83.PNG)

组建成最大堆之后：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/84.PNG)

原来的：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/85.PNG)

将索引和数据分开存储，真正表征堆的这个数组是由索引构成的

组建成最大索引堆之后：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/86.PNG)

对于**data**这个域来说，值没有改变。真正改变的是**index**这个域。**index**的改变形成了这个堆

此时，堆顶的元素的**index**为10，表示的就是堆顶的元素是10这个索引所指向的这个**data**，也就是62

其实创建索引堆的思路和前面是一样的，只不过在做元素比较的时候比的是**data**的数据，真正在做元素交换的时候，交换的是索引

#### 使用索引堆的好处

1、构建堆的过程只是索引的位置发生交换，索引就是一个非常简单的`int`型。如果`data`是非常复杂的结构的话，此时我们只交换`int`型的索引，它的效率是非常高的

2、比如说，我们想要将进程号为7的系统任务优先级提一提。我们可以直接去找进程号为7的data，发现它是28。我们可以把它提成38。然后维护最大队的性质。此时只需要根据新的**data**数组来改变**index**这个数组就好了

（第一行是进程号，data代表优先级）

### 11、二分查找法

#### 使用条件

对于**有序数列**，才能使用二分查找法（排序的作用）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/90.PNG)

一直这样分下去，直到找到那个元素。（一半一半的分，这样形成了树形结构，所以时间复杂度是**logn**级别的）

#### 代码实现

```c
#include <iostream>

using namespace std;

/*
作用：二分查找，在有序数组arr中，查找target

返回值：如果找到target，返回相应的索引index；如果没有找到，返回 -1

参数1：需要查找的数组
参数2：数组中元素的个数
参数3：需要查找的目标元素
*/
template<typename T>
int binarySearch(T arr[], int n, T target) {
    // 在arr[l...r]之中查找target
    int l = 0, r = n - 1;
    while (l <= r) {

        // int mid = (l + r) / 2; 这种写法可能有bug，因为，当 l 和 r 都很大的时候，两个数相加会导致溢出

        /* 正确的写法 */
        int mid = l + (r - l) / 2;

        if (arr[mid] == target) {
        	return mid;
        }
        else if (target < arr[mid]) { // 在arr[l...mid - 1]之中查找target
        	r = mid - 1;
        }
        else{ // 在arr[mid + 1...r]之中查找target
        	l = mid + 1;
        }
    }

    return -1; // 没有查找到
}


int main(int argc, char const *argv[])
{
	int n;
	cout<<"输入数组个数:"<<endl;
	cin>>n;
	int* arr = new int[n];
	for (int i = 0; i < n; i++) {
		arr[i] = i;
	}

	for (int i = 0; i < n; i++) {
		cout<<arr[i]<<" ";
	}

	cout<<endl;

	binarySearch(arr, );

	return 0;
}
```

### 12、二叉搜索树（ o(n) ）

#### 应用场景

可以高效**解决查找问题**（例如，查找某个词出现的频率）

通常是为了**实现查找表**的这种结构（也叫做字典数据结构）。也就是说，对于一个一个数据而言，都是键值对的形式

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/91.PNG)

#### 二分搜索树的优势

**高效**

不仅可查找数据；还可以高效地插入，删除数据-动态维护数据

可以方便地回答很多数据之间的关系问题：min、max、floor、ceil、rank、select

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/92.PNG)

#### 二分搜索树的定义

1、二叉树

2、每个节点的键值大于左孩子；每个节点的键值小于右孩子；以左右孩子为根的子树仍为二分搜索树（二分搜索树中的定义天然的就包括了递归结构）

3、和堆不同，**二分搜索树不一定是完全二叉树**（所以用数组表示并不方便。通常使用节点来表示key、value）

#### 插入新节点

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/93.gif)

#### 查找节点

查的是索引key，返回的是值value

和插入的过程类似

#### 二分搜索树的遍历

##### 前序遍历

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/94.gif)

那三个点分别代表前、中、后序。前序遍历树的时候，**只有在访问到前面那个点的时候，才打印出节点**（沿着树枝走）

每个节点都访问了三次

##### 中序遍历

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/95.gif)

可以发现，中序遍历（**先左子树后右子树**）是按照**从小到大**的顺序把二叉搜索树给打印出来；中序遍历（**先右子树后左子树**）是按照**从大到小**的顺序把二叉搜索树给打印出来。

每个节点都访问了三次

##### 后序遍历

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/96.gif)

有个特点：只有当左右两个子树都遍历完了之后，才开始做他的事情。我们可以使用这个性质做一些事情。例如：**释放这棵树的时候，只有当左右子树都释放完了之后，才释放它自己**

每个节点都访问了三次

##### 深度优先遍历

前面所讲的前、中、后序遍历都沿着树枝访问节点的（只不过打印节点的时候时机不同而已），我们叫做深度优先遍历。也就是首先尝试**走到最深**，走不动了才会以回溯的方式返回，这样将这棵树遍历完

##### 广度优先遍历(层序遍历)

也就是一层一层的遍历，而没有走到最深（也就是叶子节点）

实现思路：**利用队列**

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/97.gif)

先把根节点入队，然后再出队。之后把根节点的左右两个孩子入队。然后让队头的节点出队，再让它的左右孩子入队。一直循环下去，直到队列中元素为空

##### 删除节点

找到这个节点很容易，删除这个节点也很容易。关键是如何操纵与这个节点相关联的部分（它的左孩子和右孩子），使得这棵树依然要保持二分搜索树的性质

##### 二分搜索树的最小值和最大值

最小值：一直沿着**左树枝**找，直到**叶子节点**。此时这个叶子节点就是**最小值**

最大值：一直沿着**右树枝**找，直到**叶子节点**。此时这个叶子节点就是**最大值**

##### 删除二分搜索树的最小值

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/98.gif)

最小值所在的节点它只会有右孩子（因为如果有左孩子，那么它就可以继续往左走）

根据二分搜索树的性质，可知可以直接把剩余的子树拼接上去

##### 删除二分搜索树的最大值

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/99.gif)

最大值所在的节点它只会有左孩子（因为如果有右孩子，那么它就可以继续往右走）

根据二分搜索树的性质，可知可以直接把剩余的子树拼接上去（也就是说，当要删除的节点只有一个子树的时候，可以直接把这个节点删除，然后把子树拼接上去）

##### 删除二分搜索树的节点（有左右子树）（ o(logn) ）

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/100.gif)

如果我们要删除一个节点，我们需要先找出应该把哪个节点拼接上去。由动态图可知，需要找到被删除节点**右子树的键最小的那个节点，用这个节点填补被删除的节点**

### 13、并查集

实现并集

可以用并查集这种数据结构来高效的实现图

并查集是一种很不一样的**树形结构**

#### 应用场景

##### 1、可以非常高效的处理连接问题

例如，判断网络中节点间的连接状态（这里的网络是一个抽象的概念：用户之间形成的网络。例如一个大型的社交网络也是一种网络。在**facebook**中，用户与用户之间形成了好友的关系，那么这种好友的关系就是一种连接的关系。此时，我们可以问这样的一个问题，任意的两个人是否可以通过好友互相认识呢？这就是一个典型的连接问题）

路由器与路由器之间形成的也是网络

道路交通、航班调度也可以形成网络

##### 2、可以实现数学中的集合

#### 并查集主要支持的操作

对一组数据，主要支持两个操作：

并：`union(p, q)`，将 p 和 q 两个元素合并在一起，也就是连接起来

查：`find(p)`，查找 p 这个元素具体在哪个组中

#### 并查集的基本数据表示

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/87.PNG)

图中，0到4是**互相**连接的，5到9是**互相**连接的

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/89.PNG)

**注意：图中的 id 标错了，应该标在下面一行**

图中，0、2、4、6、8这些偶数是**互相**连接的，1、3、5、7、9这些奇数是**互相**连接的

#### 代码实现

```c++
#include <iostream>

using namespace std;

namespace UF1 {
	class UnionFind {

	private:
		int* id; // 存放 id，id是用来标识两个元素是否连接。如果 id 的值相同，说明连接
		int count;// 存放元素的个数

	public:
		/*
        初始化并查集

        参数1：元素的个数
		*/
		UnionFind(int n) {
			this->count = n;
			this->id = new int[n];

			for (int i = 0; i < this->count; i++) {
                this->id[i] = i; //id的下标是才是我们要查找、合并的元素。id的值是用来标识两个元素是否相连
			}
		}

		/*
        作用：释放元素 
		*/
		~UnionFind() {
			delete[] this->id;
		}
        /*
        查找元素 p 的标识（也就是元素 p 在哪个连接里面）

        参数1：需要查找的元素
        */
		int find(int p) {
			if ((p < 0) && (p >= this->count)) {
                exit(-1);
			}

            return this->id[p];
		}

		/*
        作用：判断 p 和 q 是否连接在一起

        参数1：需要查找的元素
        参数2：需要查找的元素
		*/
		bool isConnected(int p, int q) {
			return this->id[p] == this->id[q];
		}

        /*
        作用：让 p 和 q 合并（实质是让 p 和 q 所在的组合并）
        让 p 和 q 两个元素所在的组中所有元素的标识都一样

        参数1：需要合并的元素
        参数2：需要合并的元素
        */
		void unionElements(int p, int q) {
			int pID = find(p);
			int qID = find(q);

			if (pID == qID) {
				return;
			}

			for (int i = 0; i < this->count; i++) {
				if (this->id[i] == pID) {
					this->id[i] = qID;
				}
				/*
				或者：
				if (this->id[i] == qID) {
					this->id[i] = pID;
				}
				*/
			}
		}
	};
}
```

```c++
#include <iostream>
#include <ctime>
#include <stdlib.h>
#include "UnionFind1.h"

using namespace std;

namespace UnionFindTestHelper {
	void testUF1(int n) {
		srand(time(NULL));
		UF1::UnionFind *uf = new UF1::UnionFind(n);

		time_t startTime = clock();

		for (int i = 0; i < n; i++) {
			int a = rand() % n;
			int b = rand() % n;
			uf->unionElements(a, b);
		}
		for (int i = 0; i < n; i++) {
			int a = rand() % n;
			int b = rand() % n;
			uf->isConnected(a, b);
		}

		time_t endTime = clock();

		cout<<"UF1, "<<2*n<<"ops, "<<double(endTime - startTime);
	}
}
```

```c++
#include <iostream>
#include "UnionFindTestHelper.h"

using namespace std;

int main(int argc, char const *argv[])
{
	int n = 100000;
	UnionFindTestHelper::testUF1(n);
	
	return 0;
}
```

#### 并查集的另外一种实现思路

用树形结构来表示元素是否连接在一起（将每一个元素看作是一个节点）

但是这种树形结构和之前提到额二叉树这种树形结构有些不同。之前的树形结构都是由指针指向自己的孩子。但是对于并查集的树形结构来说，指针是指向它的父亲的。

例如，3和2连接在一起，可以表示成：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/101.PNG)

（其实2和3的位置换一下是一样的，因为2和3连接在一起就相当于3和2连接在一起）

再比如一个更复杂一些的树：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/102.PNG)

可知，这些节点都是连接在一起的（因为每个节点的根都是2。因为2没有父亲，所以指向它自己）

#### 实现思路

因为每个节点只需要保存它的父亲是什么即可，所以，不需要像二叉树那样使用两个指针来指向自己的两个孩子。因此可以使用数组来表示这种树形结构。

在初始情况下，每个元素都不互相连接，所以它们没有父亲（即指向自己）：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/103.PNG)

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/104.gif)

**只要两个元素（节点）它们的根是一样的，那么这两个元素（节点）就是相连的**

注意，在连接的时候，我们要让树的根指向树的根。因为这样合并树之后，树的高度会尽可能的小。其实我们是可以让树的根指向另一棵树的任意一个节点（因为合并之后，树的根还是一样的。但是这样可能会是树的高度更大一些，此时对树进行查找、合并的时间就会更多）

### 14、图的表示

**一个图的核心**其实就是一个一个的**节点**以及连接节点之间的**边**

#### 邻接矩阵

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/105.PNG)

##### 适用情况

适合表示稠密图（也就是**图的边比较多**）

完全图是典型的稠密图

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/108.PNG)

##### 优点

可以使用O(1)的方式来判断两个顶点是否有边

##### 代码实现

```c
#include <iostream>
#include <vector>

using namespace std;

// 稠密图 - 邻接矩阵
class DenseGraph {
private:
    int n, m; // 存放图的顶点数和边数
    bool directed; // 标识这个图是有向图还是无向图
    vector<vector<bool>> g; // 使用vector嵌套vertor的形式来表示二维矩阵。元素的值表示是否有这条边

public:
	/*
    参数1：有多少个顶点
    参数2：是有向图还是无向图
	*/
	DenseGraph(int n, bool directed) {
		this->n = n;
		this->m = 0;
		this->directed = directed;

		for (int i = 0; i < n; i++) {
			g.push_back(vector<bool>(n, false)); // 创建了一个n*n的矩阵，元素的值都是false
		}
	}
    
    /*
    返回值：图中的顶点个数
    */
	int V() {
		return this->n;
	}
    
    /*
    返回值：图中的边数
    */
	int E() {
		return this->m;
	}
    
    /*
    作用：让顶点v和w相连
    参数1：其中的一个顶点
    参数2：另一个顶点
    */
	void addEdge(int v, int w) {
        if (v < 0 && v >= n) { // 判断数组下标是否越界
        	exit(-1);
        }
        if (w < 0 && w >= n) { // 判断数组下标是否越界
        	exit(-1);
        }

        if (hasEdge(v, w)) { // 如果已经有边了，那么就直接返回就行了
        	return;
        }

        g[v][w] = true;
        if (!directed) { // 如果这个图不是有向图（也就是它是无向图）
        	g[w][v] = true;
        }
        m++; // 因为无论是有向图还是无向图，都只是增加一条边
	}

	bool hasEdge(int v, int w) {
		if (v < 0 && v >= n) {
			exit(-1);
		}
		if (w < 0 && w >= n) {
			exit(-1);
		}

		return g[v][w];
	}

};
```

#### 邻接表

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/106.PNG)

从红色的部分开始看：

第一行的0后面有一个1，代表0和1相连

第二行的1后面有0、2、3，代表1和0、1和2、1和3相连

后面的以此类推

其中，**每一行都是一个链表**

##### 适用情况

适合表示稀疏图（也就是**图的边比较少**）

稀疏图：每个节点边的条数远远小于它可以拥有的最大边的条数

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/107.PNG)

可以看出，图中任意一个节点拥有的边数也就是7、8条

##### 代码实现

```c
#include <iostream>
#include <vector>

using namespace std;

class SparseGraph {
private:
	int n, m; // 存放图的顶点数和边数
    bool directed; // 标识这个图是有向图还是无向图
	vector<vector<int>> g; 
public:
	SparseGraph(int n, bool directed) {
		this->n = n;
		this->m = 0;
		this->directed = directed;

		for (int i = 0; i < n; i++) {
			g.push_back(vector<int>()); // 因为开始的时候，所有顶点都不相连，所以为空
		}
	}

	~SparseGraph();

	int V() {
		return this->n;
	}

	int E() {
		return this->m;
	}

	void addEdge(int v, int w) {
		if (v < 0 && v >= n) {
			exit(-1);
		}
		if (w < 0 && w >= n) {
			exit(-1);
		}

		g[v].push_back(w);
		if (v != w && !directed) { // 处理自环边的问题
			g[w].push_back(v);
		}

		m++;
	}

	bool hasEdge(int v, int w) {
		if (v < 0 && v >= n) {
			exit(-1);
		}
		if (w < 0 && w >= n) {
			exit(-1);
		}

		for (int i = 0; i < g[v].size(); i++) {
			if (g[v][i] == w) {
				return true;
			}
		}
		return false;
 	}
};
```

#### 遍历邻边

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84---%E6%85%95%E8%AF%BE%E7%BD%91/109.PNG)

从图中可以看出，遍历邻边的话，使用邻接表会快得多

























































































































































































































































































































































































