# session和cookie

## session

### 流程

在早期web应用中，通常使用服务端session来管理用户的会话

1、**服务端session是用户第一次访问应用时，服务器就会创建的对象**，代表用户的一次会话过程，可以用来存放数据。**服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象**。

2、服务器在创建完session后，会把**sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器**，以便服务器能够根据sessionid找到与该用户对应的session对象。

3、**session通常有失效时间的设定**，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。

4、**session在一开始并不具备会话管理（也就是登录之后对用户权限进行的管理）的作用。它只有在用户登录认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证，才能用来管理会话**。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉。所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。

![](http://oklbfi1yj.bkt.clouddn.com/session%E5%92%8Ccookie/1)

### session的一些问题

1、**这种方式将会话信息存储在web服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存**。

2、**当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题**。因为session是由单个服务器创建的，但是**处理用户请求的服务器不一定是那个创建session的服务器**，这样他就拿不到之前已经放入到session中的登录凭证之类的信息了。

3、多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。

针对问题1和问题2，可以**采用redis这种中间服务器**来管理session的增删改查，**一来减轻web服务器的负担，二来解决不同web服务器共享session的问题**。

## cookie

由于使用session的方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接**把用户的登录凭证直接存到客户端**的方案，当用户登录成功之后，把登录凭证写到cookie里面，并给cookie设置有效期，后续请求直接验证存有登录凭证的cookie是否存在以及凭证是否有效，即可判断用户的登录状态

### 流程

1、**用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证**，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户id，凭证创建时间和过期时间三个值。

2、**服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie**。**cookie的名字必须固定（如ticket），因为后面再获取的时候，还得根据这个名字来获取cookie值**。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止cookie被别人截取的时候，无法轻易读到其中的用户信息。

3、**用户登录后发起后续请求，服务端根据上一步存登录凭证的cookie名字，获取到相关的cookie值。然后先做解密处理，再做数字签名的认证**，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。

![](http://oklbfi1yj.bkt.clouddn.com/session%E5%92%8Ccookie/2)

### 优点

这种方式最大的优点就是**实现了服务端的无状态化，彻底移除了服务端对会话的管理的逻辑，服务端只需要负责创建和验证登录cookie即可，无需保持用户的状态信息**。

由于把登录凭证直接存放客户端，并且**需要cookie传来传去**，所以有如下缺点。

### 缺点

1、**cookie有大小限制，存储不了太多数据**，所以要是登录凭证存的消息过多，导致加密签名后的串太长，就会引发别的问题，比如其它业务场景需要cookie的时候，就有可能没那么多空间可用了；所以用的时候得谨慎，得观察实际的登录cookie的大小；比如太长，就要考虑是非是数字签名的算法太严格，导致签名后的串太长，那就适当调整签名逻辑；比如如果一开始用4096位的RSA算法做数字签名，可以考虑换成1024、2048位。

2、**每次传送cookie，增加了请求的数量，对访问性能也有影响**。

3、也有跨域问题，毕竟还是要用cookie。





































