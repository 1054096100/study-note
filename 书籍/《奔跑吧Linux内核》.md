# 《奔跑吧Linux内核》

## 第一章 处理器体系结构

离开了处理器体系结构讨论Linux内核，就犹如空中楼阁，毕竟操作系统只是为处理器服务的一种软件而已。

### 大小端字节序

如何检查处理器是大端模式还是小端模式?联合体Union的存放顺序是**所有成员都从低地址开始存放**的，利用该特性可以轻松获取CPU对内存采用大端模式还是小端模式读写。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/1.png)

如果输出结果是true,则是小端模式，否则是大端模式。

## 第二章 内存管理

比较早期的操作系统是没有虚拟内存这个概念的，为什么现代操作系统都有虚拟内存这个概念，包括Windows和Linux?要弄明白虚拟内存，你可能需要了解什么是MMU、页表、物理内存、物理页面、建立映射关系、按需分配、缺页中断和写时复制等机制和概念。

当了解MMU时，除了要了解MMU工作原理外，还会接触到**Linux内核如何建立页表映射**，其中也包括用户空间页表的建立和内核空间页表的建立，以及内核是如何查询页表和修改页表的。

当了解物理内存和物理页面时,会接触到struct pg_data_t、struct zone和struct page等数据结构，这3个数据结构描述了系统中物理内存的组织架构。struct page数据结构除了描述一个4KB大小(或者其他大小)的物理页面外，还包含很多复杂而有趣的成员。

当了解怎么分配物理页面时，会接触到伙伴系统机制和页面分配器(pageallocator),页面分配器是内存管理中最复杂的代码之一。

有了物理内存，那怎么和虚拟内存建立映射关系呢?在Linux内核中，**描述进程的虚拟内存用struct vm_ are_ struct 数据结构**。**虚拟内存和物理内存采用建立页表的方法来完成建立映射关系**。为什么和进程地址空间建立映射的页面有的叫匿名页面，而有的叫page cache页面呢?

当了解malloc()怎么分配出物理内存时，会接触到缺页中断，缺页中断也是内存管理中最复杂的代码之一。

这时，**虚拟内存和物理内存已经建立了映射关系，这是以页为基础的，可是有时内核需要小于一个页面大小的内存，那么slab机制就诞生了**。

上面已经建立起虚拟内存和物理内存的基本框图，但是如果用户持续分配和使用内存导致物理内存不足了怎么办?此时页面回收机制和反向映射机制就应运而生了。

虚拟内存和物理内存的映射关系经常是建立后又被解除了，时间长了，系统物理页面布局变得凌乱不堪，**碎片化严重，这时内核如果需要分配大块连续内存就会变得很困难**，那么内存规整机制(Memory Compaction)就诞生了。

### 2.1 物理内存初始化

#### 2.1.1 内存管理概述

内存管理是一个很复杂的系统，涉及的内容很多。如果用分层来描述，内存空间可以分成3个层次，分别是用户空间层、内核空间层和硬件层，如图2.1所示。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/2.png)

**用户空间层可以理解为Linux内核内存管理为用户空间暴露的系统调用接口**，例如brk、mmap等系统调用。通常libc库会封装成大家常见的C语言函数，例如malloc()和mmap()等。

内核空间层包含的模块相当丰富。用户空间和内核空间的接口是系统调用，因此内核空间层首先需要处理这些内存管理相关的系统调用，例如sys_brk、sys_mmap、sys_madvise 等。接下来就包括VMA管理、缺页中断管理、匿名页面、page cache、页面回收、反向映射、slab 分配器、页表管理等模块了。

最下面的是硬件层，包括处理器的MMU、TLB和cache部件，以及板载的物理内存，例如LPDDR或者DDR。

#### 2.1.3 物理内存映射

在内核使用内存前，需要初始化内核的页表，初始化页表主要在map_lowmem()函数中。在映射页表之前，需要把页表的页表项清零。

#### 2.1.4 zone初始化

对页表的初始化完成之后，内核就可以对内存进行管理了，但是内核并不是统一对待这些页面，而是采用区块zone的方式来管理。

#### 2.1.5 空间划分

**在32bitLinux中，一共能使用的虚拟地址空间是4GB，用户空间和内核空间的划分通常是按照3:1来划分，也可以按照2:2来划分**。

#### 2.1.6 物理内存初始化

在内核启动时，内核知道物理内存DDR的大小并且计算出高端内存的起始地址和内核空间的内存布局后，物理内存页面page就要加入到伙伴系统中，那么物理内存页面如何添加到伙伴系统中呢?

##### 伙伴系统

伙伴系统(Buddy System)是操作系统中最常用的一种动态存储管理方法，在用户提出申请时，分配一块大小合适的内存块给用户，反之在用户释放内存块时回收。**在伙伴系统中，内存块是2的order次幂**。Linux内核中order的最大值用MAX_ORDER来表示，通常是11,也就是把所有的空闲页面分组成11个内存块链表，每个内存块链表分别包括1、2、4、8、16、32、... 1024个连续的页面。1024个页面对应着4MB大小（一个page是4KB，所以1024个page是4MB）的连续物理内存。

物理内存在Linux内核中分出几个zone来管理，zone根据内核的配置来划分，例如在ARM Vexpress平台中，zone分为ZONE_NORMAL和ZONE_HIGHMEM。

伙伴系统的空闲页块的管理如图2.2所示，zone数据结构中有一个free_area 数组，数组的大小是MAX_ORDER。free_area 数据结构中包含了MIGRATE_TYPES个链表，这里相当于zone中根据order的大小有0到MAX_ORDER - 1个free_area， 每个free_area 根据MIGRATE_TYPES类型有几个相应的链表。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/3.png)

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/4.png)

大部分物理内存页面都存放在MIGRATE_MOVABLE链表中。**大部分物理内存页面初始化时存放在2的10次幂的链表中**。

#### 2.2 页表的映射过程

#### 2.2.1 ARM32页表映射

在32bit的Linux内核中一般采用3层的映射模型，第1层是页面目录(PGD),第2层是页面中间目录(PMD)，第3层才是页面映射表(PTE)。**但在ARM32系统中只用到两层映射**（PGD和PTE），因此在实际代码中就要在3层的映射模型中合并1层。在ARM32架构中，可以按段(section)来映射，这时采用单层映射模式。使用页面映射需要两层映射结构，页面的选择可以是64KB的大页面或4KB的小页面，如图2.4所示。Linux内核通常默认使用4KB大小的小页面。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/5.png)

如果采用单层的段映射（不是图2.4），内存中有个段映射表，表中有4096个表项，每个表项的大小是4Byte,所以这个段映射表的大小是16KB，而且其位置必须与16KB边界对齐。每个段表项可以寻址1MB大小的地址空间。当CPU访问内存时，32位虚拟地址的高12位(bit[31:20])用作访问段映射表的索引，从表中找到相应的表项。**每个表项提供了一个12位的物理段地址**，**以及相应的标志位，如可读、可写等标志位**。**将这个12位物理地址和虚拟地址的低20位拼凑在一起，就得到32位的物理地址**。

如果采用页表映射的方式（图2.4所示），段映射表就变成一级映射表(First Level table,在Linux内核中称为PGD)，其表项提供的不再是物理段地址,而是二级页表的基地址。32位虚拟地址的高12位(bit[31:20]) 作为访问一级页表的索引值，找到相应的表项，每个表项指向一个二级页表。以虚拟地址的次8位(bit[19:12])作为访问二级页表的索引值，得到相应的页表项，从这个页表项中找到20位的物理页面地址。最后将这20位物理页面地址和虚拟地址的低12位拼凑在一起，得到最终的32位物理地址。**这个过程在ARM32架构中由MMU硬件完成，软件不需要接入**。

#### 2.3 内核内存的布局图

##### 2.3.1 ARM32内核内存布局图

编译器在编译目标文件并且链接完成之后，就可以知道**内核映像文件**最终的大小，接下来打包成二进制文件，该操作由arch/arm/kermel/vmlinux.ld.S控制，其中也划定了内核的内存布局。

内核image本身占据的内存空间从`_text`段到`_end`段，并且分为如下几个段。

代码段:`_text`和`_etext`为代码段的起始和结束地址，包含了编译后的内核代码。
init段:` __init_begin`和`__init_end`为init段的起始和结束地址，包含了大部分模块初始化的数据。
数据段:`_sdata`和`_edata`为数据段的起始和结束地址，保存大部分内核的变量。
BSS段: `__bss_start`和`__bss_stop`为BSS段的开始和结束地址，包含初始化为0的所有静态全局变量。

用户空间和内核空间使用3:1的划分方法时，内核空间只有1GB大小。这1GB的映射空间,其中有一部分用于**直接映射**物理地址，这个区域称为**线性映射区**。在ARM32平台上，**物理地址[0:760MB]的这一部分内存被线性映射到[3GB:3GB + 760MB]的虚拟地址上**。线性映射区的虚拟地址和物理地址相差PAGE_OFFSET，即3GB。

**为什么内核只线性映射760MB呢**?剩下的264MB的虚拟地址空间用来做什么呢?

那是保留给vmalloc、fixmap和高端向量表等使用的。内核很多驱动使用vmalloc来分配连续虚拟地址的内存，**因为有的驱动不需要连续物理地址的内存**。

**内核通常把物理内存低于760MB的称为线性映射内存( Normal Memory)，而高于760MB以上的称为高端内存(High Memory)**。由于32位系统的寻址能力只有4GB，对于物理内存高于760MB而低于4GB的情况，我们可以从保留的240MB的虚拟地址空间（指的是内核的虚拟地址空间）中划出一部分用于动态映射高端内存，这样内核就可以访问到全部的4GB内存了。

#### 2.4 分配物理页面（页面分配器）

##### 2.4.1 伙伴系统分配内存

之前有提到伙伴系统是Linu观内核中最基本的内存分配系统。伙伴系统的概念不难理解，但是一直以来，分配物理内存页面是内存管理中最复杂的部分，它涉及到**页面回收、内存规整、直接回收内存**等相当错综复杂的机制。本节关注在内存充足的情况下如何分配出连续物理内存。读者阅读完本书中的内存管理全部内容后，可以思考在最糟糕情况下页面分配器是如何分配出连续物理页面的。

内核中常用的分配物理内存页面的接口函数是`alloc_pages()`,用于分配一个或者多个连续的物理页面，**分配的页面个数只能是2的整数次幂**。**相比于多次分配离散的物理页面，分配连续的物理页面有利于降低系统内存的碎片化程度**，内存碎片化是一个很让人头疼的问题。

在`__rmqueue_smallest()`函数中，首先从order开始查找zone中空闲链表。如果zone的当前order对应的空闲区free area 中相应migratetype类型的链表里没有空闲对象，那么就会查找下一级order。

为什么会这样?因为在系统启动时，空闲页面会尽可能地都分配到`MAX_ORDER - 1`的链表中，这个可以在系统刚起来之后，通过`“cat /proc/pagetypeinfo”`命令看出端倪。**当找到某一个order的空闲区中对应的migratetype类型的空闲链表中有空闲内存块时，就会从中把一个内存块摘下来，然后调用expand()函数来“切蛋糕”。因为通常摘下来的内存块要比需要的内存大，切完之后需要把剩下的内存块重新放回伙伴系统中**。

expand()函数就是实现“切蛋糕”的功能。这里参数high就是current_order ，通常current_order要比需求的order要大。每比较一次，area减1，相当于退了一级order,最后通过list_add把剩下的内存块添加到低一级的空闲链表中。

##### 2.4.2 释放页面

释放内存页面的核心功能是把页面添加到伙伴系统中适当的free_area链表中。**在释放内存块时，会查询相邻的内存块是否空闲，如果也空闲，那么就会合并成一个大的内存块，放置到高一阶的空闲链表free_area中**。**如果还能继续合并邻近的内存块，那么就会继续合并，转移到更高阶的空闲链表中，这个过程会一直重复下去，直至所有可能合并的内存块都已经合并**。

假设现在要释放一个内存块A,大小为2个page,内存块的page的开始页帧号是0x8e010, order为1,如图2.8所示:

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/6.png)

(1)首先计算得出page_idx等于0x10。 也就是说，这个内存块位于pageblock的0x10的位置。

(2)在第一次while循环中，计算buddy_idx。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/7.png)

(3)那么buddy就是内存块A的临近内存块B了，内存块B在pageblock的起始地址为0x12。

(4)接下来通过page_is_buddy())函数来检查内存块B是不是空闲的内存块。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/8.png)

内存块在buddy中并且order也相同，该函数返回1。

(5)如果发现内存块B也是空闲内存，并且order也等于1，那么我们找到了一块志同道合的空闲伙伴块，把它从空闲链表中摘下来，以便和内存块A合并到高一阶的空闲链表中。

(6)这时combined_idx指向内存块A的起始地址。order++表示继续在附近寻找有没有可能合并的相邻的内存块，这次要查找的order等于2（因为A、B的order都是1，合并之后，得到的内存块的order是2，所以，现在要查找的order是2），也就是4个page大小的内存块。

(7)重复步骤(2)，查找附近有没有志同道合的order为2的内存块。

(8) 如果在0x14位置的内存块C不满足合并条件，例如内存块C不是空闲页面，或者内存块C的order不等于2。如图2.8所示，内存块C的order等于3，显然不符合我们的条件。如果没找到order为2的内存块，那么只能合并内存块A和B了，然后把这个内存块添加到空闲页表中。

#### 2.5 slab分配器

伙伴系统用于分配内存时是以page为单位的，在实际中有很多内存需求是以Byte为单位的，那么如果我们需要分配以Byte为单位的小内存块时，该如何分配呢? slab 分配器就是用来**解决小内存块分配问题**的，也是内存分配中非常重要的角色之一。**slab 分配器最终还是由伙伴系统来分配出实际的物理页面，只不过slab分配器在这些连续的物理页面上实现了自己的算法**，以此来对小内存块进行管理。

##### 2.5.4 kmalloc分配函数

内核中常用的kmalloc()函数的核心是slab机制。类似伙伴系统机制，按照内存块的2^order来创建多个slab描述符，例如16B、32B、 64B、128B、 ...、 32MB等大小，系统会分别创建名为kmalloc-16、kmalloc-32、 kmalloc-64 ... 的slab描述符。例如分配30Byte 的一个小内存块，可以用`“kmalloc(30, GFP_KERNEL)”`，那么系统会从名为`“kmalloc-32”`的slab描述符中分配一个
对象出来。

##### 2.5.5 小结

通过阅读.上面的代码，我们知道slab系统由slab描述符、slab 节点、本地对象缓冲池、共享对象缓冲池、3个slab链表、n个slab,以及众多slab缓存对象组成，如图2.10所示。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/9.png)

为什么slab要有一个cache colour着色区? cache colour着色区让每一个slab对应大小不同的cache行，着色区大小的计算为colour_next * colour_off， 其中colour_next从0到这个slab描述符中计算出来的colour最大值，colour_off 为L1 cache的cache行大小。**这样可以使不同slab上同一个相对位置slab对象的起始地址在高速缓存中相互错开，有利于改善高速缓存的效率**。

#### 2.6 vmalloc

kmalloc基于slab分配器，slab 缓冲区建立在一个连续物理地址的大块内存之上，所以其缓存对象也是物理地址连续的。如果在内核中不需要连续的物理地址，而仅仅需要内核空间里连续虚拟地址的内存块，该如何处理呢?这时vmalloc()就派上用场了。

#### 2.8 malloc

malloc()函数是C函数库封装的一个核心函数，C函数库会做一些处理后调用Linux内核系统去调用brk,所以大家并不太熟悉brk的系统调用，原因在于很少有人会直接使用系统调用brk向系统申请内存,而总是通过malloc()之类的C函数库的API函数。**如果把malloc()想象成零售，那么brk就是代理商。malloc函数的实现为用户进程维护一个本地小仓库,当进程需要使用更多的内存时就向这个小仓库要货，小仓库存量不足时就通过代理商brk向内核批发**。

##### 2.8.1 brk实现

在32位Linux内核中，每个用户进程拥有3GB的虚拟空间。内核如何为用户空间来划分这3GB的虚拟空间呢?**用户进程的可执行文件由代码段和数据段组成**，数据段包括所有的静态分配的数据空间，例
如全局变量和静态局部变量等。**这些空间在可执行文件装载时，内核就为其分配好这些空间，包括虚拟地址和物理页面，并建立好二者的映射关系**。如图2.15所示:

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/10.png)

用户进程的用户栈从3GB虚拟空间的顶部开始，由顶向下延伸，而brk分配的空间是从数据段的顶部end_data 到用户栈的底部。所以动态分配空间是从进程的end_data 开始，每次分配一块空间，就把这个边界往上推进一段，同时内核和进程都会记录当前的边界的位置。

(图中内核空间的布局是2.3节所说的布局)

##### 2.8.3 小结

malloc函数其实是为用户空间分配进程地址空间，用内核术语来说就是分配一块VMA，相当于一个空的纸箱子。

#### 2.10 缺页中断处理

在之前介绍malloc()和mmap()两个用户态API函数的内核实现时，我们发现**它们只建立了进程地址空间，在用户空间里可以看到虚拟内存，但没有建立虚拟内存和物理内存之间的映射关系。当进程访问这些还没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常(也称为“缺页中断”)**，Linux 内核必须处理此异常。缺页异常是内存管理当中最复杂和重要的一部分，需要考虑很多的细节，包括匿名页面、KSM页面、page cache页面、写时复制、私有映射和共享映射等。

缺页异常处理依赖于处理器的体系结构，因此缺页异常底层的处理流程在内核代码中特定体系结构的部分。

## 第三章 进程管理

### 3.1 进程的诞生

进程是Linux内核最基本的抽象之一，它是处于执行期的程序，或者说“进程=程序+执行”。但是**进程并不仅局限于一段可执行代码(代码段)，它还包括进程需要的其他资源**，例如**打开的文件**、挂起的信号量、**内存管理**、**处理器状态**、**一个或者多个执行线程**和数据段等。Linux内核通常把进程叫作是任务( task), 因此进程控制块( processing control block, PCB)也被命名为struct task_struct。

线程被称为轻量级进程，它是操作系统调度的最小单元，通常一个进程可以拥有多个线程。线程和进程的区别在于进程拥有独立的资源空间，而线程则共享进程的资源空间。Linux内核并没有对线程有特别的调度算法或定义特别的数据结构来标识线程,线程和进程都使用相同的进程PCB数据结构。内核里使用clone方法来创建线程，其工作方式和创建进程fork方法类似，但会确定哪些资源和父进程共享，哪些资源为线程独享。

#### 3.1.2 fork

在Linux系统中，进程或线程是通过fork、vfork 或clone等系统调用来建立的。在内核中,这3个系统的调用都是通过同一个函数来实现，即do_fork()函数,该函数定义在fork.c文件中。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/11.png)

do_fork()函数有5个参数，具体含义如下。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/12.png)

clone_flags定义在sched.h文件中。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/13.png)

CLONE_VM:  父进程和子进程运行在同一个虚拟地址空间，--个进程对全局变量改动，另外一个进程也可以看到。

CLONE_FS:  父进程和子进程共享文件系统信息，例如根目录、当前工作目录等。其中一个进程对文件系统信息进行改变，将会影响到另外一个进程，例如调用chroot()或chdir()等。

CLONE_FILES:  父进程和子进程共享文件描述符表。文件描述符表里面保存进程打开文件描述符的信息，因此一个进程打开的文件，在另外一个进程用同样的描述符也可以访问。一个进程关闭了一个文件或者使用fcntl()改变了一个文件属性，另外一个进程也能看到。

CLONE_SIGHAND:  父进程和子进程共享信号处理器函数表。一个进程改变了某个信号处理函数，这个改动对于另外一个进程也有效。

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7Linux%E5%86%85%E6%A0%B8%E3%80%8B/14.png)

上面4种实现都是通过调用do_fork()函数来完成的，只是调用的参数不一样。**fork只使用SIGCHLD标志位，在子进程终止后发送SIGCHLD信号通知父进程**。fork 是重量级调用，为子进程建立了一个基于父进程的完整副本，然后子进程基于此运行。**为了减少工作量采用写时复制技术(copy on write, COW)，子进程只复制父进程的页表，不会复制页面内容**（但是本质上，fork创建出来的进程最终是不与父进程共享物理内存的）。当子进程需要写入新内容时才触发写时复制机制，为子进程创建一个副本。vfork 的实现比fork多了两个标志位，分别是CLONE_VFORK和CLONE_VM。CLONE_VFORK表示父进程会被挂起，直至子进程释放虚拟内存资源。CLONE_VM表示父子进程运行在相同的内存空间中。clone用于创建线程，并且参数通过寄存器从用户空间传递下来，通常会指定新的栈地址(newsp)。





























































































