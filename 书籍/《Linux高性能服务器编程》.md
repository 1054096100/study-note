# Linux高性能服务器编程

1、网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，因此网络层必须先将目标机器的IP地址转化物理地址，才能使用数据链路层提供服务

2、WAN(广域网)通常使用众多分级的路由器来连接分散的主机或LAN(局域网)，因此，通信的两主机一般不是直接相连的，而是通过多个中间节点(路由器)连接的。网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径

3、传输层为两台主机上的应用程序提供端对端的通信。与网络层使用的逐级跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/1.PNG)

4、TCP协议(传输控制协议)为应用层提供可靠的、面向连接的和基于流的服务(基于流的数据没有边界(长度)限制)，它源源不断地通信的一端流入另一端

5、UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址(IP地址等信息)

6、数据链路层、网络层和传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间实现。而应用层则在用户空间实现

7、经过TCP封装好的数据称为TCP报文段，或者简称TCP段

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/2.PNG)

8、经过数据链路层封装的数据称为**帧(frame)**。**帧才是最终在物理网络上传送的字节序列**

9、DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的

10、我们要访问DNS服务器，就必须先知道DNS服务器的IP地址。Linux使用 `/etc/resolv.conf`文件来存放DNS服务器的IP地址

​	Linux下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器查询机器`www.baidu.com`的IP地址：

```
host -t A www.baidu.com
```

得到：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/3.PNG)

`host`命令的输出告诉我们，机器名`www.baidu.com`是`www.a.shifen.com`的别名，并且该机器名对应两个IP地址。`host`命令使用DNS协议和DNS服务器通信，其`-t`选项告诉DNS协议使用哪种查询(-t 是type的简写)，我们这里使用的是A类型，即通过机器的域名获得其IP地址(但实际返回的资源记录中还包括机器的别名)

关于类型，有那么常见的几种：

​	类型A，值是1，表示获取目标主机的IP地址

​	类型CNAME，值是5，表示获得目标主机的别名

​	类型PTR，值是12，表示反向查询

11、因为数据链路层、网络层、传输层协议是在内核中实现的，因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API主要是`socket`

12、**IP协议**为上层协议提供**无状态、无连接、不可靠**的服务

​	**无状态**是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接受都是相互独立、没有上下文关系的这种服务最大的缺点就是无法处理乱序和重复的IP数据报。而这些无序的IP数据报可以让TCP协议来处理，因此，递交给TCP上层协议的内容绝对是有序、正确的

​	UDP和HTTP协议也是无状态的

​	无状态的优点是：简单、高效

​	无连接是指IP通信双方都不长久维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对方的IP地址

​	不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力

13、TCP协议更靠近应用层，因此在应用程序中具有更强的可操作性。一些重要的socket选项都和TCP协议相关

14、TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流

15、TCP数据流控制。为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。TCP数据控制流的两个方面：**超时重传和拥塞控制**

16、TCP相对于UDP协议的特点是：**面向连接、字节流和可靠传输**

​	可靠性：发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功；TCP协议还采用超时重传机制

​	UCP协议和IP协议一样，提供不可靠服务(它们都**需要上层协议来处理数据确认和超时重传**)

17、使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。

​	TCP连接是**全双工的，即双方的数据读写可以通过一个连接进行**。完成数据交换之后，通信双方都必须断开连接以释放系统资源

​	**TCP协议的这种连接是一对一的**，所以基于广播和多播(目标是多个主机地址)的应用程序不能使用TCP服务

18、字节流和数据报的区别：通信双方是否必须执行相同次数的读、写操作(从实际编程的角度来看)

​	TCP模块发送出的TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/4.PNG)

​	UDP则不然，发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作，否则就会丢包

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/5.PNG)

19、所有知名服务使用的端口号都定义在`/etc/services`文件中

20、TCP头部构造

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/6.PNG)

32位确认号：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值(ISN,初始序号值)加1

6位标志：

​	URG标志，表示紧急指针(urgent pointer)是否有效

​	ACK标志，表示确认号是否有效。我们称ACK标志的TCP报文段为确认报文段

​	PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间

​	RST标志，表示要求对方重新建立连接

​	SYN标志，表示请求建立一个连接

​	FIN标志，表示通知对方本端要关闭连接了

### 31、TCP连接的建立和关闭时序图(三次握手和四次挥手)

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/7.PNG)

实际上，仅用于确认目的的确认报文段5是可以省略的，因为结束报文段6也携带了该确认信息。确认报文段5是否出现在连接的过程中，取决于TCP的延迟特性

32、半关闭状态

TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，通信的一端可以发送结束报文给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，知道对方也发送结束报文段以关闭连接

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/8.PNG)

(这幅图和上面那副握手和挥手的有区别)

33、如果客户端访问一个距离它很远的服务器，或者由于网络繁忙，导致服务器对于客户端发送的请求连接的报文段没有应答，此时客户端程序将会进行重连(可能执行多次)，如果重连仍然无效，则通知应用程序连接超时

34、`telnet`是用来建立`TCP`连接的

### 35、服务器的典型状态转移过程

服务器通过`listen`系统调用进入LISTEN状态，被动等待客户端连接。服务器一旦监听到某个连接请求，就将该连接放入内核等待队列中

​	**当客户端主动关闭连接时**(通过 close 或 shutdown 系统调用向服务器发送结束报文段)，服务器通过返回确认报文段使连接进入 CLOSE_WAIT 状态。这个状态的含义很明确：等待服务器应用程序关闭连接。**通常，服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接**。这将使连接转移到 LAST_ACK 状态，以等待客户端对结束报文段的最后一次确认。一旦完成确认，连接就彻底关闭

### 36、客户端的典型状态转移过程

客户端通过`connect`系统调用自动与服务器建立连接。connect系统调用首先给服务器发送一个请求连接的报文段，是连接转移到`SYN_SENT`状态。此后，connect系统调用可能因为如下两个原因失败返回：

​	一、如果connect连接的目标端口不存在(未被任何进程监听)，或者该端口仍被处于`TIME_WAIT`状态的连接所占用，则服务器将给客户端发送一个复位报文段，connect调用失败

​	二、如果目标端口存在，但connect在超时时间内未收到服务器的确认报文段，则connect调用失败

### 37、TCP连接的建立和断开过程中客户端和服务器的状态变化

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/9.PNG)

客户端连接在收到服务器的结束报文段(TCP报文段6)之后，并没有直接进入CLOSED状态，而是转移到TIME_WAIT状态。在这个状态，客户端连接要等待一段长为2MSL(报文段最大生存时间)的时间，才能完全关闭。**MSL是TCP报文段在网络中的最大生存时间**，标准文档RFC1122的建议值是 **2min**

​	**TIME_WAIT状态存在的原因有两点：**

​	**1、可靠地终止TCP连接**

​	**2、保证让迟来的TCP报文段有足够的时间被识别并丢弃**

第一个原因很好理解。假设图 3-9 中用于确认服务器结束报文段6的TCP报文段7丢失，那么服务器将重发结束报文段。因此客户端需要停留在某个状态以处理重复收到的结束报文段(即向服务器发送确认报文段)。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段

在Linux系统上，一个TCP端口不能被同时打开多次(两次及以上)。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新的连接。反过来思考，如果不存在TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接(指具有相同的IP地址和端口号)。这个新的、和原来相似的连接被称为原来的连接的化身。新的化身可能接收到属于原来的连接的、携带程序数据的TCP报文段(迟到的报文段)，这显然是不应该发生的。这就是TIME_WAIT状态存在的第二个原因

另外，因为TCP报文段的最大生存时间是MSL，所以坚持2MSL时间的TIME_WAIT状态能够确保网络上两个传输方向上尚未被接收到、迟到的TCP报文段都已经消失(被中转路由器丢弃)。因此，一个连接的新的化身可以在2MSL时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据，这就是TIME_WAIT状态要持续2MSL时间的原因

有时候我们希望避免TIME_WAIT状态，因为当程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端口，程序无法启动(知道2MSL超时时间结束)。此时，我们可以通过socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT状态的连接占用的端口

### 38、拥塞控制

提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。这就是所谓的拥塞控制

### 39、HTTP协议是一种应用层协议，它默认使用的传输层协议是TCP协议

### 40、通过代理服务器访问Internet上的Web服务器的一个例子图

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/10.PNG)

### 41、代理服务器按照其使用方式和作用，分为正向代理服务器、反向代理服务器、透明代理服务器

​	正向代理要求客户端自己设置代理服务器的地址，客户端的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源

​	反向代理则被设置在服务器端，因而客户端无须进行任何设置。反向代理是指用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从内部服务器上得到的结果返回给客户端。这种情况下，代理服务器对外就表现为一个真实的服务器。各大网站通常分区域设置了多个代理服务器，所以在不同的地方ping同一个域名可能得到不同的IP地址，因为这些IP地址实际上是代理服务器的IP地址

​	透明代理只能设置在网关上(可以看成正向代理的一种特殊情况)

​	正向代理服务器和客户端主机处于同一个逻辑网络中。反向代理服务器和真正的web服务器也位于同一个逻辑网络中，这通常有提供网站的公司来配置和管理

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/11.PNG)

### 42、本地名称查询

一般来说，通过域名来访问Internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果我们通过主句名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址

​	Linux将目标主机名及其对应的IP地址存储在 /etc/hosts 配置文件中

​	如果程序在 /etc/hosts 文件中未找到目标机器名对应的IP地址，它将求助于DNS服务

​	用户可以通过修改 /etc/host.conf 文件来自定义系统解析主机名的方法和顺序(一般是访问本地文件 /etc/hosts，再访问 DNS 服务)

​	**(注意：一个主机名可以对应多个IP)**

### 43、短连接和长连接

**短连接**

​	在旧的HTTP协议中，web客户端和web服务器之间的一个TCP连接只能为一个HTTP请求服务。当处理完客户的一个HTTP请求之后，web服务器就(主动)将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP请求的话，必须与服务器建立一个新的TCP连接。也就是说，同一个客户的多个连续的HTTP请求不能共用同一个TCP连接

**长连接**

​	多个请求可以使用同一个TCP连接。它极大地减少了网络上为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。**HTTP请求和应答中的“Connection”头部字段就是专门用于告诉对方一个请求完成之后该如何处理连接的**，比如立即关闭连接(该头部字段的值为“close”)或者保持一段时间以等待后序请求(该头部字段的值为“keep-alive”)

### 44、cookie

cookie是服务器发送给客户端的特殊信息(通过HTTP应答的头部字段“Set-Cookie”)，客户端每次向服务器发送请求的时候都需要带上这些信息(通过HTTP请求的头部字段“Cookie”)。这样服务器就可以区分不同的用户了。基于浏览器的自动登录就是用Cookie实现的

### 45、字节序

字节序分为大端字节序和小端字节序。大端字节序是指一个整数的高位字节(23 ~ 31bit)存储在内存的地地址，低位字节(0 ~ 7bit)存储在内存的高地址。小端字节序则是指整数的高位字节存储在内存的高地址，而低位字节则存储在内存的低地址处

现代PC大多采用小端字节序，因此**小端字节序又被称为主机字节序**

举个例子：

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
	int hoge = 0x12345678;
	unsigned char *hoge_p = (unsigned char*)&hoge;

    for (int i = 0; i < 4; i++) {
        printf("%x\n", hoge_p[i]);
    }

	return 0;
}
```

输出结果：

```shell
78
56
34
12
```

可以看出位于整数的高位字节（12）存储在内存的高地址（因为索引更大，所以在内存中的地址会更高）

当格式化的数据(比如32bit 整型数和16bit短整型数)在两台使用不同字节序的主机之间传递时，接收端必然错误地解释之。解决问题的方法是：发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换(小端机转换，大端机不转换)。因此，**大端字节序也称为网络字节序**

### 46、创建socket

**socket连接是全双工的**

socket地址的两个要素，即**IP地址和端口号**

UNIX/Linux 的一个哲学是：**所有的东西都是文件**。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符

​	下面的 socket系统调用可创建一个 socket：

```c++
#include <sys/types.h>
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```

socket系统调用成功时返回一个socket文件描述符，失败则返回 -1 并设置 errno

`domain`参数告诉系统使用哪个底层协议族。对 TCP/IP协议族而言，该参数应该设置为PF_INET （Protocol Family of Internet，用于IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该参数应该设置PF_UNIX

`type`参数指定服务类型。服务类型主要有SOCK_STREAM服务 (流服务) 和 SOCK_UGRAM（数据报）服务。对TCP/IP协议族而言，其取值 SOCK_STREAM表示传输层使用TCP协议，去 SOCK_DGRAM表示传输层使用UDP协议

`protocol`参数是在前面两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的(前面两个参数已经完全决定了它的值)。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议

### 47、命名socket

将一个socket与socket地址绑定称为给socket命名

命名socket的系统调用是 bind，其定义如下：

```c++
#include <sys/types.h>
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);
```

### 48、监听socket

socket 被命名之后，还不能马上接受客户连接，我们需要使用系统调用来创建一个监听队列以存放待处理的客户连接：

```c++
#include <sys/socket.h>
int listen(int sockfd, int backlog);
```

sockfd 参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理信的客户连接

### 49、接受连接

下面的系统调用从listen监听队列中接受一个连接：

```c++
#include <sys/types.h>
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

sockfd参数是执行过listen系统调用的监听socket。addr参数用来获取被接受连接的远端socket地址

accept 成功时返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信

**accept只是从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化**

### 50、发起连接

如果说服务器通过listen 调用来被动接受连接，那么客户端需要通过如下系统调用来主动与服务器建立连接：

```c++
#include <sys/types.h>
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);
```

一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信

### 51、关闭连接

```c++
#include <unistd.h>
int close(int fd);
```

fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1。只有当fd的引用计数为0时，才真正关闭连接。多进程程序中，一次fork系统调用默认将父进程中打开的socket的引用计数加1，因此我们**必须在父进程和子进程中都对该socket执行close才能将连接关闭**

如果无论如何都要立即终止连接(而不是将socket的引用计数减1)，可以使用如下的shutdown系统调用(相对close来说，它是专门为网络编程设计的)：

```c++
#include <sys/socket.h>
int shutdown(int sockfd, int howto);
```

sockfd参数是待关闭的socket。howto参数决定了shutdown的行为

### 52、守护进程

Linux服务器程序一般以后台进程形式运行。**后台进程又称为守护进程**。它没有控制终端，因而也不会以外接收到用户输入。守护进程的父进程通常是init进程(PID为1的进程)

53、Linux服务器程序一般以某个专门的非root身份运行。比如 mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户 mysql、apache和syslog（这些账户是系统用户）

54、Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。**绝大多数服务器程序都有配置文件，并存放在 /etc 目录下**

55、Linux服务器进程通常会在启动的时候生成一个PID文件并存入 /var/run目录中，以**记录该后台进程的PID**

### 56、用户信息

用户信息对于服务器程序的安全性来说是很重要的，比如大部分服务器就必须以root身份启动，但不能以 root身份运行

**真实用户ID(UID)、有效用户ID(EUID)、真实组ID(GID)和有效组(EGID)**

**一个进程拥有两个用户ID：UID和EUID**。EUID存在的目的是方便资源访问：**它使得运行程序的用户拥有该程序的有效用户的权限**。比如 su 程序，任何用户都可以使用它来修改自己的账户信息，但修改账户时su程序不得不访问 /etc/passwd 文件，而访问该文件是需要root权限的。用ls 命令可以查看到，su程序的所有者是root，并且它被设置了set-user-id标志。这个标志表示，**任何普通用户运行su程序时，其有效用户就是该程序的所有者root**(因此，此时的用户具有了su程序的拥有者<root>的权限)

所以我们可以利用su程序的例子来很好的理解(解释)有效用户(EUID)的含义：**运行程序(su)的用户(huanghantao)拥有该程序(su)的有效用户(root)的权限(例如，访问 /etc/passwd文件)**

### 57、进程间的关系

**进程组**

​	Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID(PGID)

​	每个进程组都有一个**首领进程，其PGID和PID相同**。进程组将一直存在，知道其中所有进程都退出，或者加入到其他进程组

**会话**

​	一些有关联的进程组将形成一个会话

**用`ps`命令来查看进程、进程组和会话之间的关系**

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/12.PNG)

我们是在bash shell下执行 ps 和 less 命令的，所以 ps 和 less 命令的父进程是bash命令，这可以从PPID(父进程PID)一列来看。这三条命令创建了1个会话(SID是 1943)和2个进程组(PGID分别是1943和2298)。bash命令的PID、PGID和SID都相同，很明显它既是会话首领，也是组1943的首领。ps命令则是组2298的首领，因为其PID也是2298。三者的关系：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/13.PNG)

### 58、工作目录和根目录

有些服务器程序还需要改变**工作目录和根目录**，比如web服务器。一般来说，web服务器的逻辑根目录并非文件系统的根目录“/”，而不是站点的根目录(**对于Linux的web服务来说，该目录一般是 /var/www/**)

### 59、服务器模型

**C/S模型**

​	![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/14.PNG)

由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。I/O模型有多种，服务器使用的是I/O复用技术之一的select系统调用。当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。逻辑单元可以新创建的子进程、子线程或者其他

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/15.PNG)

C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，其缺点也很明显：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应

**P2P模型**

​	P2P(Peer to Peer，点对点)模型比C/S模型更符合网络通信的实际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的低位

​	P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。云计算机群可以看作P2P模型的一个典范。但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络的负载将加重

​	P2P存在一个很明显的问题，即主机之间很难互相发现。所以实际使用的P2P模型通常带有一个专门的发现服务器。这个发现服务器通常还提供查找服务(甚至还可以提供内容服务)，是每个客户都能尽快找到自己需要的资源

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/16.PNG)

从编程角度来讲，**P2P模型可以看作C/S模型的扩展：每台主机既是客户端，又是服务器**

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/17.PNG)

该图既能用来描述一台服务器，也能用来描述一个服务器机群

### 60、服务器模块的功能描述

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/18.PNG)

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/19.PNG)

I/O处理单元通常要完成的工作：等待并接受信的客户连接，接受客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定在I/O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。对于一个服务器机群来说，I/O处理单元是一个专门的接入服务器。它**实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务**

**一个逻辑单元通常是一个进程或线程。它分析处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端**(具体使用哪种方式取决于事件处理模式)。对服务器机群而言，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理

网络存储单元不是必须的，比如**ssh、telnet等登录服务就不需要这个单元**

请求队列是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件

61、我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。

​	针对**阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止**。例如，客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。**socket的基础API中，可能被阻塞的系统调用包括accept、send、recv和connect**

​	针对**非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否发生。如果事件没有立即发生，这些系统调用就返回 -1** ，和出错的情况一样。很显然，我们只有在事件已经发生的情况下操作非阻塞I/O(读、写等)，才能提高程序的效率。因此，**非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号**

### 62、池

既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是**以空间换时间，即“浪费”服务器的硬件资源，以换取其运行效率**。这就是池的概念。池是一组资源的集合，这组**资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无效动态分配**。从最终的效果来看，池相当于服务器管理系统资源的应用层设施，它避免了服务器对内核的频繁访问

根据不同的资源类型，池可以分为多种，常见的有内存池、进程池、线程池和连接池

**内存池**

​	**内存池通常用于socket的接收缓存和发送缓存**。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够(比如5000字节)的接收缓存区是很合理的。当客户请求的长度超过接收缓存区的大小时，我们可以选择丢弃请求或者动态扩大接收缓存区

**进程池和线程池**

​	**进程池和线程池都是并发编程常用的“伎俩”**。当我们需要一个工作进程或工作线程来处理新的客户请求时，我们可以从进程池或线程池中取得一个执行实体，而无需动态地调用fork或pthread_create等函数来创建进程和线程

**连接池**

​	连接池通常用于服务器或服务器机群的内部永久连接。简单做法是：逻辑单元每次需要访问数据库的时候，就向数据库程序发起连接，而访问完毕后释放连接。很显然，这种做法的效率太低。一种解决方案是使用连接池。连接池是服务器预先和数据库程序建立的一组连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑单元再将连接返回给连接池

### 63、数据复制

应该避免不必要的数据复制，尤其是当数据复制发生在用户代码和内核之间的时候。如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没必要将这些数据从内核缓存区复制到应用程序缓存区。这里说的“直接处理”指的是应用程序不关心这些数据的内容，不需要对它们做任何分析。比如ftp服务器，当客户请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调用send函数来来发送，而是可以使用“零拷贝”函数sendfile来直接将其发送给客户端(例如nginx反向代理服务器)

此外，用户代码内部(不访问内核)的数据复制也是应该避免的。举例来说，当两个工作进程之间要传递大量的数据时，我们就应该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递

### 64、I/O复用

**I/O复用使得程序能同时监听多个文件描述符(fd)**

I/O复用虽然能同时监听多个文件描述符，但它本身是**阻塞的**。并且当多个文件描述符同时就绪时，**如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个描述符，这使得服务器程序看起来像是串行工作的**。**如果要实现并发，只能使用多进程或多线程等编程手段**

### 65、select系统调用

用途是：在一段时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件

### 66、poll系统调用

poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者

### 67、epoll系列系统调用

epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符或事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表

### 68、三组I/O复用函数的比较

从实现原理上来说，select和poll采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是O(n)

epoll_wait则不同，它采用采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法复杂度是O(1)。**但是，当活动连接比较多的时候，epoll_wait的效率未必比select和poll高，因此此时回调函数被触发得过于频繁。所以epoll_wait适用于连接数量多，但活动连接较少的情况**

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/20.PNG)

### 69、使用I/O复用同时处理TCP和UDP服务

在实际应用中，有不少服务器程序能同时监听多个端口，比如超级服务inetd和android的调试服务adbd。

从bind系统调用的参数来看，一个socket只能与一个socket地址绑定，即一个socket只能用来监听一个端口。因此，服务器如果要同时监听多个端口，就必须创建多个socket，并将它们分别绑定到各个端口上。这样一来，服务器程序就需要同时管理多个监听socket，I/O复用技术就有了用武之地

另外，即使是同一个端口，如果服务器要同时处理该端口上的TCP和UDP请求，则也需要创建两个不同的socket：一个是流socket，另一个是数据报socket，并将它们绑定到该端口上

### 70、信号

信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常

### 71、fork系统调用

该函数的每次调用都返回两次，在父进程中返回的是子进程的PID，在子进程中则返回0。该返回值是后续代码判断当前进程是父进程还是子进程的依据

### 72、exec系列系统调用

有时我们需要在子进程中执行其他程序即替换当前映像，这就需要使用如下 exec系列函数之一

一般情况下，exec函数是不返回的，除非出错

### 73、处理僵尸进程

对于僵尸进程而言，父进程一般需要跟踪子进程的退出状态。因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程退出信息的查询(如果父进程还在运行)。在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程处于僵尸态。另外一种使子进程进入僵尸态的情况是：父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被操作系统设置为1，即init进程。init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态

由此可见，无论哪种情况，如果父进程没有正确地处理子进程的返回信息，子进程都将停留在僵尸态，并占据这内核资源。这是绝对不能容许的，毕竟内核资源有限

### 74、管道

管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符(fd[0]和fd[1])都保持打开。一对这样的文件描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]。比如，我们要使用管道实现从父进程向子进程写数据，就可以按照下图来操作：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/21.PNG)

显然，如果要实现父、子进程之间的双向数据传输，就必须使用两个管道

socket编程接口提供了一个创建全双工管道的系统调用：socketpair。squid服务器程序就是利用socketpair创建管道，以实现在父进程和日志服务子进程之间传递日志信息

### 75、信号量

当多个进程同时访问系统上的某个资源的时候，比如同时修改某个文件，就需要考虑进程的同步问题，以确保任一时刻只有一个进程可以拥有对资源的独占访问。通常，程序对共享资源的访问的代码知识很短的一段，但就是这一段代码引发了进程之间的竞态条件。我们称这段代码为关键代码段，或者临界区。对进程同步，也就是确保任一时刻只有一个进程能进入关键代码段

在Linux/Unix中，“等待”和“信号”这两种对信号的操作更采用的称呼是P、V操作。**P代表进入临界区，V代表退出临界区**。假设有**信号量SV**，则对它的P、V操作含义如下：

P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂起进程的执行

V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1

信号量的取值可以是任何自然数。但最常用的、最简单的信号量是二进制信号量，它只能取0和1这两个值。

使用二进制信号量同步两个进程，以确保关键代码段的独占式访问的一个典型例子：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22.PNG)

**当关键代码可用时，二进制信号量SV的值为1**，进程A和B都有机会进入关键代码段。如果此时进程A执行了P(SV)操作将SV减1，则进程B若再执行P(SV)操作就会被挂起。直到进程A离开关键代码段，并执行V(SV)操作将SV加1，关键代码段才重新变得可用。如果此时进程B因为等待SV而处于挂起状态，则它将被唤醒，并进入关键代码段。同时，这时如果进程A再执行P(SV)操作，则也只能被操作系统挂起以等待进程B退出关键代码段

### 76、共享内存

共享内存是最高效的IPC(Inter-Process Communication，进程间通信)机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存通常和其他进程间通信方式一起使用

### 77、消息队列

它是**两个进程之间传递二进制块数据的一种简单有效的方式**(也是一种IPC机制)。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道和命名管道那样必须以先进先出的方式接收数据

### 78、线程模型

线程是程序中完成一个独立任务的完整执行序列，即一个可调度的实体。根据运行环境和调度者的身份，线程可分为内核线程和用户线程。内核线程，运行在内核空间，有内核来调度；用户线程运行在用户空间，由线程库来调度。当进程的一个内核线程获得CPU的使用权时，它就加载并运行一个用户线程。可见，内核线程相当于用户线程运行的“容器”。一个进程可以拥有M个内核线程和N个用户线程，其中 M <= N。并且在一个系统的所有进程中，M和N的比值都是固定的。按照M:N的取值，线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度

完全在用户空间实现的线程无须内核的支持，内核甚至根本不知道这些线程的存在。完全在用户空间实现的线程的优点是：创建和调度线程都无须内核的干预，因此速度相当快。并且由于它不占用额外的内核资源，所以即使一个进程创建了很多线程，也不会对系统性能造成明显的影响。其缺点是：对于多处理器系统，一个进程的多个线程无法运行在不同的CPU上，因为内核是按照其最小调度单位来分配CPU的。此外，线程的优先级只对同一个进程的线程有效，比较不同进程中的线程的优先级没有意义

一个进程的所有执行线程共享该进程的时间片，它们对外表现出相同的优先级。因此对这种实现方式而言，N=1，即M个用户空间线程对应一个内核线程，而该内核线程实际上就是进程本身

### 79、进程池和线程池

我们可以动态创建子进程(或子线程)来实现并发服务器。但是，这样做有如下缺点：

一、动态创建进程(或线程)是比较耗费时间的，这将导致较慢的客户响应

二、动态创建的子进程(或子线程)通常只用来为一个客户服务(除非我们做特殊的处理)，这将导致系统上产生大量的细微进程(或线程)。**进程(或线程)间的切换将消耗大量地CPU时间**

三、**动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源**，否则子进程可能复制这些资源，从而是系统的可用资源急剧下降，进而影响服务器的性能

进程池是由服务器预先创建的一组子进程，这些子进程的数目在3~10个之间(当然，这是典型情况)。比如，httpd守护进程就是使用包含7个子进程的进程池来实现并发的。线程池中的线程数量应该和CPU数量差不多

进程池中的所有子进程都运行这相同的代码，并具有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，即它们没有打开不必要的文件描述符(从父进程继承而来)，也不会错误的使用大块的堆内存(从父进程复制得到)

当有新的任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。

当选择好了进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是，在父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信。

在父线程和子线程之间传递数据就要简单得多，因为我们可以把这些数据定义为全局的，那么它们本身就是被所有线程共享

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/23.PNG)























































