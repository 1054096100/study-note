# C专家编程

### 1、数组和指针的区别

#### 什么是声明，什么是定义

定义：只能出现在一个地方。确定对象的类型并分配内存，用于创建新的对象。例如：`int my_array[100];`

声明：可以多次出现。描述对象的类型，用于指代其他地方定义的对象（例如在其他文件里）。例如：`extern int my_array[];`。extern对象声明告诉编译器对象的类型和名字，对象的内存分配则在别处进行。**由于并未在声明中为数组分配内存，所以并不需要提供关于数组长度的信息**

只要记住下面的内容即可分清定义和声明：

声明相当于普通的声明：它所说明的并非自身，而是**描述其他地方的创建的对象**

定义相当于特殊的声明：它**为对象分配内存**

#### 数组和指针是如何访问的

![](http://oklbfi1yj.bkt.clouddn.com/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/1.PNG)

所以，我们可以看出，地址（左值）和地址的内容（右值）都是用"同一个"符号（比如这里的X，它实际上可以是代表地址，也可以代表地址的内容，但是根据上下文环境，X代表地址）来表示的。但是代表的含义确实不同的，一个代表地址，一个代表地址的内容，这是**编译器根据上下文环境判断**同一个符号的具体含义的

C语言引入了“可修改的左值”这个术语。它表示左值（可修改的左值）允许出现在赋值语句的左边。这个奇怪的术语是为了与数组名区分，数组名也可用于确定对象在内存中的位置，也是左值，但它不可以作为赋值的对象。因此，数组名是个左值但不是可修改的左值。标准规定赋值符必须用可修改的左值作为它左边一侧的操作数

编译器为每个变量分配一个地址（左值）。这个地址在编译时可知，而且该变量在运行时一直保存于这个地址。相反，存储在变量中的值（它的右值）只有在运行时才可知道。如果需要用到变量中存储的值，编译器就发出指令从指定地址读入变量值并将它存于寄存器中

这里的关键之处在于每个符号的地址在编译时可知。所以，如果编译器需要一个地址（可能还要加上偏移量）来执行某种操作，它就可以直接进行操作，并不需要增加指令首先取得具体的地址。相反，对于指针，必须首先在运行时取得它的当前值（也就是指针变量存储的值--地址），然后才能对它进行解除引用操作

##### 数组的下标引用：

对内存**直接**引用

此时，数组名a的地址是字符串的起始地址

![](http://oklbfi1yj.bkt.clouddn.com/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/3.PNG)

##### 对指针的引用

对内存进行**间接**引用

指针的访问要灵活得多，但需要增加一次额外的提取：

![](http://oklbfi1yj.bkt.clouddn.com/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/2.PNG)

##### 对指针进行下标引用：

此时指针变量p的地址不是字符串的地址

![](http://oklbfi1yj.bkt.clouddn.com/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/4.PNG)

这种情况也就是定义一个指针，却以数组的方式对其引用（我们以为是会对内存直接引用，但是，这时编译器所执行的却是对内存间接引用。因为我们告诉编译器我们拥有的是一个指针）

所以，图C实质是图A和图B访问方式的组合（先进行图B的间接引用，后进行图A的下标偏移访问）

#### 使声明与定义相匹配

文件1：

```c
int mango[100];
```

文件2：

```c
extern int mango[];
```

mango数组的定义分配了100个int的空间。而指针定义：

```c
int *raisin;
```

则申请一个地址容纳该指针（也就是地址里面存了一个地址）。指针变量raisin本身始终位于同一个地址，但**指针的内容在任何时候都可以改变**，指向不同地址的int变量。这些不同的int变量可以有不同的值。**mango数组的地址并不能改变**，在不同的时候它的内容可以不同，但**它总是表示100个连续的内存空间**

#### 数组和指针的其他区别

数组和指针都可以在它们的定义中用字符串常量进行初始化

数组和指针都可以在它们的定义中用字符串常量进行初始化，但是底层的机制却不相同

定义指针时，编译器并不为指针所指向的对象分配空间，它只是分配指针本身的空间，除非在定义指针的同时赋给指针一个字符串常量进行初始化。例如，下面的定义创建了一个**字符串**常量（为其分配了内存）：

```c
char *p = "breadfruit";
```

注意，只有对**字符串**常量才是如此。不能为浮点数之类的常量分配空间：

```c
char *pi = 3.14; //错误，无法通过编译
```

数组也可以用字符串常量初始化：

```c
char a[] = "gooseberry";
```

**字符串常量初始化的数组是可以修改的**

### 2、内存泄漏

有些程序并不需要管理它们的动态内存的使用。当需要内存时，它们简单地通过分配来获得，从来不用担心如何释放它。这类程序包括编译器和其他一些运行一段固定的（或有限的）时间然后终止的程序。当这种类型的程序终止时，所有内存会被自动回收。细心查验每块内存是否需要回收纯属浪费时间，因为它们不会再被使用

其他程序的生存时间要长一点。有些工具如日历管理器、邮件工具以及操作系统本身经常需要数日乃至数周连续运行，并需要管理动态内存的分配和回收。由于C语言通常并不使用垃圾收集器（自动确认并且回收不再使用的内存块），这些C程序在使用malloc()和free()时不得不非常慎重。**堆**经常会出现两种类型的问题：

1、释放或改写仍在使用的内存（称为“内存损坏”）

2、**未释放不再使用的内存**（称为“内存泄漏”）

如果每次已分配的内存块不再使用而程序员并不释放它们，进程就会一边分配越来越多的内存，一边却并不释放不再使用的那部分内存

#### 避免内存泄漏

每次调用malloc分配内存时，注意在以后要调用相应的free来释放它

如果不知道如何调用free与先前的malloc相对应，那么很可能已经造成了内存泄漏

一种简单的方法就是在可能的时候使用alloca()来分配动态内存，以避免上述情况。当离开调用alloca的函数时，它所分配的内存会被自动释放

显然，这并不适用于那些比创建它们的函数生命周期更长的结构。但如果对象的生命周期在该函数结束前便已终止，这种建立在堆栈上的动态内存分配是一种开销很小的选择。有些人不提倡使用alloca，因为它并不是一种可移植的方法。如果处理器在硬件上不支持堆栈，alloca()就很难高效地实现

我们使用“内存泄漏”这个词是因为稀有的资源正在被一个进程榨干。**内存泄漏的主要可见症状就是进程的速度会减慢。原因是体积大的进程更有可能被系统换出，让别的进程运行，而且大的进程在换进换出时花费的时间也更多**。即时（从定义上说）泄漏的内存本身并不被引用，但它仍可能存在与页面中（内容自然是垃圾），这样就增加了进程的工作页数量，降低性能。另外需要注意的一点是，**泄漏的内存往往比释放的数据结构要大，因为malloc()所分配的内存通常会变为下一个大于申请数量的2的整数次方**（如申请212B，会变为256B）。

### 3、数组和指针相同的情况

![](http://oklbfi1yj.bkt.clouddn.com/C%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/5.PNG)

注意：对于编译器而言，一个数组就是一个地址，一个指针就是一个地址的地址

#### 什么时候数组和指针是相同的

**规则1**：表达式中的数组名（与声明不同）被编译器当作一个指向该数组第一个元素的指针

**规则2**：下标总是与指针的偏移量相同

**规则3**：**在函数参数的声明中**，数组名被编译器当作指向该数组第一个元素的指针

##### 规则1

上面的规则1和规则2合在一起理解，就是对数组下标的引用总是可以写成“一个指向数组起始地址的指针加上偏移量”。例如：

```c
int a[10], *p, i = 2;
```

然后，可以通过以下任何一种方法来访问`a[i]`：

```c
p = a;
p[i];
```

```c
p = a;
*(p + i);
```

```c
p = a + i;
*p;
```

对数组的引用`a[i]`在编译时总是被编译器改写成`*(a + i)的形式`

只需要记住：**在表达式中**，指针和数组是可以互换的，因为它们在编译器里的最终形式都是指针，并且都可以进行取下标操作

指针有类型限制的原因：编译器需要知道对指针进行解除引用操作时应该取几个字节，以及每个下标的步长应取几个字节

##### 规则2

记住：数组下标是定义在指针的基础上的，所以优化器常常可以把它转换为更有效率的指针表达形式，并生成相同的机器指令

不论是指针还是数组，在连续的内存地址上移动时，编译器都必须计算每次前进的步长

##### 规则3

标准规定，作为“类型的数组”的形参的声明应该调整为“类型的指针”。在函数形参定义这个特殊情况下，**编译器必须把数组形式改写成指向数组第一个元素的指针形式**。**编译器只向函数传递数组的地址**，而不是整个数组的拷贝。

让我们重点观察一下数组，隐性转换意味着三种形式都是完全等同的。因此，在`my_function()`的调用上，无论实参是数组还是真的指针都是合法的：

```c
my_function(int *turnip) { ... }
my_function(int turnip[]) { ... }
my_function(int turnip[200]) { ... }
```

C语言允许程序员把形参声明为数组（程序员打算传递给函数的东西）或者指针（函数实际所接收到的东西）。编译器知道何时形参是作为数组声明的，但事实上在函数内部，编译器始终把它作为一个指向数组第一个元素（元素长度未知）的指针。这样，编译器可以产生正确的代码，并不需要对数组和指针这两种情况作仔细区分

不管程序员实际所写的是哪种形式，函数并不自动知道指针所指的数组共有多少个元素

























