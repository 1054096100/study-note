# TCP-IP详解卷1：协议

## 1、概述

UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的**可靠性必须由应用层来提供** 

大多数的网络应用程序都被设计成**客户—服务器模式** 

局域网上运行FTP的两台主机所涉及的所有协议

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/1.PNG)

我们注意到**应用程序通常是一个用户进程，而下三层则一般在（操作系统）内核中执行**。尽管这不是必需的，但通常都是这样处理的，例如 U N I X操作系统 

顶层与下三层之间还有另一个关键的不同之处。**应用层关心的是应用程序的细节，而不是数据在网络中的传输活动**(通信细节)。下三层对应用程序一无所知，但它们要处理所有的通信细节 

网络接口层是用来**处理有关通信媒介的细节**(以太网、令牌环网等)

### 构造互联网的方法

**构造互联网最简单的方法是把两个或多个网络通过路由器进行连接。它是一种特殊的用于网络互连的硬件盒**(这些盒子也称作IP路由器 )。路由器的好处是为不同类型的物理网络提供连接：以太网、令牌环网、点对点的链接和F D D I（光纤分布式数据接口）等等 

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/2.PNG)

图1 - 3是一个包含两个网络的互连网：一个以太网和一个令牌环网，通过一个路由器互相连接。尽管这里是两台主机通过路由器进行通信，实际上以太网中的任何主机都可以与令牌环网中的任何主机进行通信 

**连接网络的另一个途径是使用网桥**。**网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连**。网桥使得多个局域网（LAN）组合在一起，这样对上层来说就好像是一个局域网 

大多数的 TCP/IP实现也允许一个多接口主机来担当路由器的功能，但是主机为此必须进行特殊的配置。在这种情况下，我们既**可以称该系统为主机（当它运行某一应用程序时，如 FTP或Telnet），也可以称之为路由器（当它把分组从一个网络转发到另一个网络时）** 

​	**多接口主机具有多个 IP地址，其中每个接口都对应一个 IP地址** 

TCP和UDP是两种最为著名的运输层协议，二者都使用 IP作为网络层协议 

### TCP/IP协议族中不同层次的协议

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/3.PNG)

**应用层是可以直接访问IP的**。这是很少见的，但也是可能的（一些较老的选路协议就是以这种方式来实现的。当然
新的运输层协议也有可能使用这种方式） 

**ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息**。Ping和Traceroute，它们都使用了ICMP 

互联网上的每个接口必须有一个唯一的 Internet地址（也称作 IP地址） 

由于TCP、UDP、ICMP和IGMP都要向IP传送数据，因此 IP必须在生成的IP首部中加入某种标识，以表明数据属于哪一层。为此，IP在首部中存入一个长度为8bit的数值，称作协议域。1表示为ICMP协议，2表示为IGMP协议， 6表示为TCP协议， 17表示为UDP协议 

类似地，许多应用程序都可以使用TCP或UDP来传送数据。运输层协议在生成报文首部时要存入一个应用程序的标识符。**TCP和UDP都用一个16bit的端口号来表示不同的应用程序(**服务器一般都是通过知名端口号来识别的 )。**TCP和UDP把源端口号和目的端口号分别存入报文首部中** 

**TCP/UDP 端口号可以唯一区分一个application，所以把TCP/UDP和 application 抽象在一起，作为一个抽象的application**

### 客户-服务器模型分为两种类型：重复型或并发型

**重复型服务器通过以下步骤进行交互：** 

I1. 等待一个客户请求的到来。
I2. 处理客户请求。
I3. 发送响应给发送请求的客户。
I4. 返回I 1步。
重复型服务器主要的问题发生在 I2状态。在这个时候，它不能为其他客户机提供服务 

**并发型服务器采用以下步骤：** 

C1. 等待一个客户请求的到来。
C2. 启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器对客户的全部请求进行处理。处理结束后，终止这个新服务器。
C3. 返回C 1步。
**并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。也就是说，每个客户都有它自己对应的服务器**。**如果操作系统允许多任务，那么就可以同时为多个客户服务** 

### 标准的简单服务

标准的简单服务以及其他标准的 TCP/IP服务（如Telnet、FTP、SMTP等）的端口号时，我们发现它们都是奇数。这是有历史原因的，因为这些端口号都是从NCP端口号派生出来的（NCP，即网络控制协议，是ARPANET的运输层协议，是TCP的前身）。 NCP是单工的，不是全双工的，因此每个应用程序需要两个连接，需预留一对奇数和偶数端口号。当 TCP和UDP成为标准的运输层协议时，每个应用程序只需要一个端口号，因此就使用了NCP中的奇数 

### 端口号

**端口号用来标识互相通信的应用程序**。服务器使用知名端口号，而客户使用临时设定的端口号 

## 2、链路层

### 以太网

以太网这个术语一般是指数字设备公司、英特尔公司和Xerox公司在1 9 8 2年联合公布的一个标准。**它是当今 TCP/IP采用的主要的局域网技术** 

### 环回接口 

大多数的产品都支持环回接口（Loopback Interface），以**允许运行在同一台主机上的客户程序和服务器程序通过 T C P / I P进行通信**。 A类网络号 1 2 7就是为环回接口预留的。根据惯例，大多数系统把 I P地址127.0.0.1分配给这个接口，并命名为localhost。**一个传给环回接口的 IP数据报不能在任何网络上出现** 

我们想象，一旦传输层检测到目的端地址是环回地址时，应该可以省略部分传输层和所有网络层的逻辑操作(因为都是同一台主机，没必要进行传输层和网络层的操作了)。**但是大多数的产品还是照样完成传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己** 

### 最大传输单元MTU

**以太网**对数据帧的长度有一个限制，其最大值是1500。链路层的这个特性称作MTU，最大传输单元。**如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片，把数据报分成若干片，这样每一片都小于MTU**。

### IP：网际协议

IP是TCP/IP协议族中最为核心的协议。**所有的 TCP、UDP、ICMP及IGMP数据都以I P数据报格式传输** 

**不可靠**

​	它不能保证 I P数据报能成功地到达目的地。 I P仅提供最好的传输服务。**如果发生某种错误时**，如某个路由器暂时用完了缓冲区， **IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）** 

**无连接**

​	意思是 IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明， I P数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是 B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B可能在A到达之前先到达 

**(也就是说，只管发送出去就行了)**

### IP路由选择

IP路由选择是简单的，特别对于主机来说。**如果目的主机与源主机直接相连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么I P数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由上，由路由器来转发该数据报**。大多数的主机都是采用这种简单机制 

IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。 IP路由选择是逐跳进行的。**IP并不知道到达任何目的的完整路径（当然，除了那些与主机直接相连的目的）**。所有的IP路由选择只为数据报传输提供下一站路由器的 I P地址 

### 子网寻址

现在所有的主机都要求支持子网编址（RFC 950 [Mogul and Postel 1985]）。不是把I P地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号 

例如，这里有一个B类网络地址（140.252），在剩下的16 bit中， 8 bit用于子网号， 8 bit用于主机号，格式如图 3 - 5所示。这样就允许有254个子网，每个子网可以有254台主机 

**(由于全0或全1的主机号都是无效的，因此我们把总数减去 2 )**

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/4.PNG)

大多数的子网例子都是 B类地址。其实，子网还可用于 C类地址，只是它可用的比特数较少而已。很少出现 A类地址的子网例子是因为 A类地址本身就很少（但是，大多数 A类地址都是进行子网划分的） 

### 子网掩码

除了I P地址以外，主机还需要知道有多少比特用于子网号及多少比特用于主机号。这是在引导过程中通过子网掩码来确定的。这个掩码是一个 32 bit的值，其中**值为 1的比特留给网络号和子网号，为 0的比特留给主机号** 

图 3 - 7是一个B类地址的两种不同的子网掩码格式 

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/5.PNG)

**(注意，分给子网号和主机号的位数不一定都是8位)**

### ifconfig命令 

ifconfig命令一般在引导时运行，以配置主机上的每个接口 

环回接口被认为是一个网络接口。它是一个A类地址，没有进行子网划分

### ICMP： Internet控制报文协议 

ICMP经常被认为是 I P层的一个组成部分。**它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（TCP或UDP）使用**。一些 ICMP报文把差错报文返回给用户进程 

ICMP报文是在 I P数据报内部被传输的：

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/6.PNG)

### Ping程序 

“ping”这个名字源于声纳定位操作。作用是**测试另一台主机是否可达** 

该程序发送一份 ICMP回显请求报文给主机，并等待返回 ICMP回显应答 

一般来说，**如果不能 Ping到某台主机，那么就不能 Telnet或者FTP到那台主机**(但这不是一定的，因为一台主机的可达性可能不只取决于I P层是否可达，还取决于使用何种协议以及端口号。Ping程序的运行结果可能显示某台主机不可达，但我们可以用Telnet远程登录到该台主机的25号端口（邮件服务器）)。反过来，如果不能 Telnet到某台主机，那么通常可以用 Ping程序来确定问题出在哪里。 Ping程序还能测出到这台主机的往返时间，以表明该主机离我们有“多远” 

### IP选路

选路是IP最重要的功能之一。需要进行选路的数据报可以由本地主机产生，也可以由其他主机产生。**在后一种情况下，主机必须配置成一个路由器，否则通过网络接口接收到的数据报，如果目的地址不是本机就要被丢弃**（例如，悄无声息地被丢弃） 

#### 选路原理

##### IP搜索路由表的步骤

1) 搜索匹配的**主机地址**
2) 搜索匹配的**网络地址**
3) 搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为 0） 

### DNS：域名系统 

域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和 IP地址之间的转换及有关电子邮件的选路信息 

从应用的角度上看，对 DNS的访问是通过一个地址解析器（resolver）来完成的。在 Unix主机中，该解析器主要是通过两个库函数 gethostbyname 和gethostbyaddr 来访问的，它们在编译应用程序时与应用程序连接在一起。前者接收主机名字返回 IP地址，而后者接收IP地址来寻找主机名字 

解析器通常是应用程序的一部分(在客户程序与服务器建立 TCP连接之前，名字解析器就能通过名字服务器获取IP地址 )。解析器并不像 TCP/IP协议那样是操作系统的内核。该图指出的另一个基本概念就是：在一个应用程序请求 TCP打开一个连接或使用UDP发送一个数据报之前。心须将一个主机名转换为一个 IP地址。操作系统内核中的 TCP/IP协议族对于DNS一点都不知道 

DNS的名字空间和 Unix的文件系统相似，也具有层次结构。图 14-1 显示了这种层次的组织形式 

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/7.PNG)

这颗树的树根是没有任何标识的特殊结点。命名标识中一律不区分大写和小写。命名树上任何一个结点的域名就是将从该结点到最高层的域名串连起来，中间使用一个点“.”分隔这些域名（注意这和 Unix文件系统路径的形成不同，文件路径是由树根依次向下的形成的）。域名树中的每个结点必须有一个唯一的域名，但域名树中的不同结点可使用相同的标识 

## 11、UDP：用户数据报协议

UDP是一个简单的面向数据报的运输层协议：**进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报**。

### UDP首部

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/8.PNG)

端口号表示发送进程和接收进程。

**TCP和UDP用目的端口号来分用来自IP层的数据的过程**。由于**IP层已经把IP数据报分配给TCP或UDP**（根据IP首部中协议字段值），因此**TCP端口号由TCP来查看，而UDP端口号有UDP来查看**。**TCP端口号与UDP端口号是相互独立的**。

尽管相互独立，如果TCP和UDP同时提供某种知名服务，**两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本身的要求**。

### IP分片

IP数据报是指 IP 层端到端的传输单元（在分片之前和重新组装之后），分组是指在 IP 层和链路层之间传送的数据单元。一个分组可以是一个完整的 IP 数据报，也可以是I P数据报的一个分片。

物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，**它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU**。IP把MTU与数据报长度进行比较，如果需要则进行分片。**分片可以发生在原始发送端主机上，也可以发生在中间路由器上**。

**把一份 IP数据报分片以后，只有到达目的地才进行重新组装**（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。**重新组装由目的端的 IP 层来完成。IP 首部中包含的数据为分片和重新组装提供了足够的信息**。

回忆IP首部

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/9.PNG)

下面这些字段用于分片过程。对于发送端发送的每份 I P数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制到每个片中（我们现在已经看到这个字段的用途）。**标志字段用其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置 1**。**片偏移字段指的是该片偏移原始数据报开始处的位置。另外，当数据报被分片后，每个片的总长度值要改为该片的长度值**。

当 IP 数据报被分片后，每一片都成为一个分组，具有自己的 IP 首部，并在选择路由时与其他分组独立。这样，当数据报的这些片到达目的端时有可能会失序，但是在 IP 首部中有足够的信息让接收端能正确组装这些数据报片。

尽管 IP 分片过程看起来是透明的，但有一点让人不想使用它：**即使只丢失一片数据也要重传整个数据报**。为什么会发生这种情况呢？**因为 IP 层本身没有超时重传的机制——由更高层来负责超时和重传（T C P有超时和重传机制，但 U D P没有。一些UDP应用程序（属于应用层）本身也执行超时和重传）**。当来自TCP报文段的某一片丢失后， TCP在超时后会重发整个TCP报文段，该报文段对应于一份 IP 数据报。**没有办法只重传数据报中的一个数据报片**。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。

使用U D P很容易导致I P分片（在后面我们将看到， T C P试图避免分片，但对于应用程序来说几乎不可能强迫 T C P发送一个需要进行分片的长报文段） 

### 最大UDP数据报长度

理论上， I P数据报的最大长度是 65535字节，这是由I P首部（图3 - 1） 16比特总长度字段所限制的。去除 **20 字节的 IP 首部和 8个字节的 UDP首部**， **UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。**

我们将遇到两个限制因素。第一，**应用程序可能会受到其程序接口的限制**。 socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于 UDP socket，**这个长度与应用程序可以读写的最大 UDP 数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于 8192 字节的 UDP 数据报**（使用这个默认值是因为 8192是NFS读写用户数据数的默认值）。

**第二个限制来自于 TCP / IP 的内核实现**。可能存在一些实现特性（或差错），使IP数据报长度小于65535字节。

### UDP服务器的设计

#### 客户IP地址及端口号

来自客户的是 UDP 数据报。 IP 首部包含源端和目的端 IP 地址， UDP 首部包含了源端和目的端的 UDP 端口号。**当一个应用程序接收到 UDP 数据报时，操作系统必须告诉它是谁发送了这份消息，即源IP地址和端口号。这个特性允许一个交互 UDP 服务器对多个客户进行处理**。给每个发送请求的客户发回应答。

#### 目的IP地址

一些应用程序需要知道数据报是发送给谁的，即目的 IP 地址。

#### UDP输入队列

大多数 UDP 服务器是交互服务器。这意味着，单个服务器进程对单个 UDP 端口上（服务器上的名知端口）的所有客户请求进行处理。通常程序所使用的每个 UDP 端口都与一个有限大小的输入队列相联系。这意味着，来自不同客户的差不多同时到达的请求将由 UDP 自动排队。接收到的 UDP 数据报以其接收顺序交给应用程序（在应用程序要求交送下一个数据报时）。

然而，**排队溢出造成内核中的 UDP 模块丢弃数据报的可能性是存在的**。

## 12、广播和多播

有三种 I P地址：单播地址、广播地址和多播地址。

**广播和多播仅应用于 UDP** ，它们对需将报文同时传往多个接收者的应用来说十分重要。**TCP 是一个面向连接的协议，它意味着分别运行于两主机（由 IP 地址确定）内的两进程（由端口号确定）间存在一条连接**。

考虑包含多个主机的共享信道网络如以太网。**每个以太网帧包含源主机和目的主机的以太网地址**（48 bit）。**通常每个以太网帧仅发往单个目的主机，目的地址指明单个接收接口，因而称为单播**( unicast )。在这种方式下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）。

然而，有时**一个主机要向网上的所有其他主机发送帧，这就是广播**。通过 ARP 和 RARP 可以看到这一过程。**多播(multicast) 处于单播和广播之间：帧仅传送给属于多播组的多个主机**。

为了弄清广播和多播，需要了解主机对由信道传送过来帧的过滤过程。如图：

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/10.PNG)

首先，网卡查看由信道传送过来的帧，确定是否接收该帧，若接收后就将它传往设备驱动程序。通常网卡仅接收那些目的地址为网卡物理地址或广播地址的帧。

如果网卡收到一个帧，这个帧将被传送给设备驱动程序（如果帧检验和错，网卡将丢弃该帧）。设备驱动程序将进行另外的帧过滤。首先，帧类型中必须指定要使用的协议（ IP、ARP 等等）。其次，**进行多播过滤来检测该主机是否属于多播地址说明的多播组**。

设备驱动程序随后将数据帧传送给下一层，比如，当帧类型指定为 IP 数据报时，就传往IP 层。 IP 根据 IP 地址中的源地址和目的地址进行更多的过滤检测。如果正常，就将数据报传送给下一层（如TCP或UDP）。

每次 UDP 收到由 IP 传送来的数据报，就根据目的端口号，有时还有源端口号进行数据报过滤。**如果当前没有进程使用该目的端口号，就丢弃该数据报并产生一个 ICMP 不可达报文（TCP根据它的端口号作相似的过滤）**。

使用广播的问题在于它增加了对广播数据不感兴趣主机的处理负荷。拿一个使用 UDP 广播应用作为例子。如果网内有 50 个主机，但仅有 20 个参与该应用，每次这 20 个主机中的一个发送 UDP 广播数据时，其余 30 个主机不得不处理这些广播数据报。**一直到 UDP 层，收到的UDP 广播数据报才会被丢弃**。这 30 个主机丢弃 UDP 广播数据报是因为**这些主机没有使用这个目的端口**。

**多播的出现减少了对应用不感兴趣主机的处理负荷**。使用多播，**主机可加入一个或多个多播组。这样，网卡将获悉该主机属于哪个多播组，然后仅接收主机所在多播组的那些多播帧**。

## 14、DNS：域名系统

域名系统（DNS）是一种用于 TCP / IP应用程序的分布式数据库，它提供主机名字和 IP地址之间的转换信息。

从应用的角度上看，对 DNS 的访问是通过一个地址解析器（resolver）来完成的。在 Unix主机中，该解析器主要是通过两个库函数 `gethostbyname() `和 `gethostbyaddr()` 来访问的，它们在编译应用程序时与应用程序连接在一起。前者接收主机名字返回 IP 地址，而后者接收IP地址来寻找主机名字。解析器通过一个或多个名字服务器来完成这种相互转换。

解析器并不像 TCP / IP 协议那样是操作系统的内核。**操作系统内核中的 TCP / IP 协议族对于 DNS 一点都不知道**。

### DNS 基础

DNS 的名字空间和 U n i x的文件系统相似，也具有层次结构。

### 高速缓存

为了减少 Internet 上DNS的通信量，所有的名字服务器均使用高速缓存。

在标准的 Unix 实现中，**高速缓存是由名字服务器而不是由名字解析器维护的**。既然名字解析器作为每个应用的一部分，而应用又不可能总处于工作状态，因此将高速缓存放在只要系统（名字服务器）处于工作状态就能起作用的程序中显得很重要。

### 用UDP还是用TCP

注意到DNS名字服务器使用的熟知端口号无论对 UDP还是TCP都是53。这意味着 **DNS 均支持UDP和TCP访问**。

## 15、TFTP：简单文件传送协议

TFTP即**简单文件传送协议**，最初打算用于引导无盘系统（通常是工作站或 X终端）。与使用 TCP 的文件传送协议（FTP）不同，为了保持简单和短小， **TFTP使用UDP**。 TFTP的代码（和它所需要的 U D P、 I P和设备驱动程序）都能适合只读存储器。

## 17、TCP：传输控制协议

**尽管TCP和UDP都使用相同的网络层（IP）**， TCP却向应用层提供与UDP完全不同的服务。**TCP提供一种面向连接的、可靠的字节流服务**。

在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP。

### TCP提供可靠性的方式

1、**应用数据被分割成 TCP认为最适合发送的数据块**。这和 UDP完全不同，应用程序产生的数据报长度将保持不变。由 TCP传递给I P的信息单位称为报文段或段。

2、**当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段**。如果不能及时收到一个确认，将重发这个报文段。

3、**当TCP收到发自 TCP连接另一端的数据，它将发送一个确认**。这个确认不是立即发送，通常将推迟几分之一秒。

4、**TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错， TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）**。

5、既然TCP报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序（因为分片后所走的路由可能不同，因此到达的时间也会不同），因此 TCP 报文段的到达也可能会失序。如果必要， TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。

6、**TCP还能提供流量控制。 TCP连接的每一方都有固定大小的缓冲空间**。 TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将**防止较快主机致使较慢主机的缓冲区溢出**。

### 发送方发送次数和接收方接收次数可以不同

两个应用程序通过TCP连接交换8 bit字节构成的字节流。 TCP不在字节流中插入记录标识符。我们将这称为字节流服务。如果一方的应用程序先传 10字节，又传20字节，再传 50字节，**连接的另一方将无法了解发方每次发送了多少字节**（所以接收端接收的次数和发送端发送的次数可能会不同）。收方可以分 4次接收这 80个字节，每次接收 20字节。一端将字节流放到 TCP连接上，同样的字节流将出现在TCP连接的另一端。

### TCP首部

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/11.PNG)

每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。

有时，一个 IP 地址和一个端口号也称为一个**插口**（socket）。**插口对**（socket pair） (包含客户IP地址、客户端口号、服务器 IP 地址和服务器端口号的四元组 )**可唯一确定互联网络中每个TCP连接的双方**。

**序号用来标识从TCP发端向TCP收端发送的数据字节流**，它表示在这个报文段中的的第一个数据字节。**如果将字节流看作在两个应用程序间的单向流动，则 TCP用序号对每个字节进行计数**。序号是32 bit的无符号数，序号到达`2的32次方－1`后又从0开始。

当建立一个新的连接时， S Y N标志变1。

既然**每个传输的字节都被计数**，**确认序号包含发送确认的一端所期望收到的下一个序号**。**因此，确认序号应当是上次已成功收到数据字节序号加 1**。只有A C K标志（下面介绍）为 1时确认序号字段才有效。

TCP为应用层提供**全双工**服务。这意味**数据能在两个方向上独立地进行传输**。因此，**连接的每一端必须保持每个方向上的传输数据序号**。

**TCP的流量控制由连接的每一端通过声明的窗口大小来提供**。**窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节**。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。

## 18、TCP连接的建立与终止

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/12.PNG)

发送第一个 SYN 的一端将执行主动打开（active open）。接收这个 SYN 并发回下一个 SYN 的另一端执行被动打开。

当一端为建立连接而发送它的 SYN 时，它为连接选择一个初始序号。 ISN 随时间而变化，因此每个连接都将具有不同的 ISN。

### 连接终止协议

建立一个连接需要三次握手，而终止一个连接要经过 4次握手。这由 TCP的半关闭造成的。既然一个 **TCP 连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭**。这原则就是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向连接。当一端收到一个 FIN，它必须通知应用层另一端已经终止了那个方向的数据传送。发送FIN通常是应用层进行关闭的结果。

首先进行关闭的一方（即发送第一个 FIN）将执行主动关闭，而另一方（收到这个 FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭。

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/13.PNG)

### 2MSL等待状态

TIME_WAIT状态也称为 2MSL等待状态。每个具体 TCP 实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。**它是任何报文段被丢弃前在网络内的最长时间**。我们知道这个时间是有限的，因为 TCP 报文段以I P数据报在网络内传输，而 I P数据报则有限制其生存时间的TTL字段。 

对一个具体实现所给定的 MSL 值，处理的原则是：**当 TCP 执行一个主动关闭，并发回最后一个 ACK，该连接必须在TIME_WAIT状态停留的时间为 2倍的MSL**。这样可让 TCP 再次发送最后的ACK**以防这个ACK丢失**。

**这种2MSL等待的另一个结果是这个 TCP 连接在 2MSL 等待期间，定义这个连接的插口（socket，客户的 IP 地址和端口号，服务器的 IP 地址和端口号）不能再被使用**。这个连接只能在 2MSL 结束后才能再被使用。

### TCP服务器设计

**大多数的 TCP 服务器进程是并发的**。当一个新的连接请求到达服务器时，服务器接受这个请求，并调用一个新进程来处理这个新的客户请求。不同的操作系统使用不同的技术来调用新的服务器进程。在 Unix 系统下，常用的技术是使用 fork 函数来创建新的进程。如果系统支持，也可使用轻型进程，即线程（thread）。

## 19、TCP的交互数据流

## 20、TCP的成块数据流

TCP协议作为一个可靠的面向流的传输协议，其可靠性和流量控制由滑动窗口协议保证，而拥塞控制则由控制窗口结合一系列的控制算法实现。

### TCP滑动窗口

TCP的精髓：滑动窗口协议。

#### 滑动窗口协议

1、**“窗口”**对应的是一段可以被**发送者发送的字节序列**，**其连续的范围称之为“窗口”**；

2、 **“滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”**。

#### 理解的前提

1、TCP协议的两端分别为发送者A和接收者B，**由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区**，由于对等性（A发B收和B发A收），我们**以A发送B接收的情况作为例子**。
2、**发送窗口是发送缓存中的一部分**，是可以被TCP协议发送的那部分，其实**应用层需要发送的所有数据都被放进了发送者的发送缓冲区**。

3、发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据。

4、**每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送**。



TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为‘20’。

字节31-50为发送窗口：

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/14.png)

A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组：

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/15.png)

只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递：

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/16.png)

#### 流量控制

 流量控制方面主要有两个要点需要掌握。一是**TCP利用滑动窗口实现流量控制的机制**；二是**如何考虑流量控制中的传输效率**。

所谓流量控制，主要是**接收方传递信息给发送方，使其不要发送数据太快**，是一种端到端的控制。主要的方式就是**返回的ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送**：

![](http://oklbfi1yj.bkt.clouddn.com/TCP-IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE/17.png)

#### 持续计算器

这里面涉及到一种情况，如果B已经告诉A自己的缓冲区已满，于是A停止发送数据；等待一段时间后，B的缓冲区出现了富余，于是给A发送报文告诉A我的rwnd（滑动窗口）大小为400，但是这个报文（通知A，我这个B的滑动窗口大小的报文）不幸丢失了，于是就出现A等待B的通知||B等待A发送数据的死锁状态。为了处理这种问题，TCP引入了持续计时器（Persistence timer），**当A收到对方的零窗口通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待**。

### 拥塞控制

网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，**当网络的需求超过它们的工作极限时，就出现了拥塞**。**拥塞控制就是防止过多的数据注入到网络中**，这样可以使网络中的路由器或链路不致过载。常用的方法就是：

1、慢开始、拥塞控制

2、快重传、快恢复



































































































































































































