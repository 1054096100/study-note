# UNIX网络编程卷一

## 第一章：简介

### 1.2、一个简单的时间获取客户程序

#### 创建TCP套接字

socket函数创建一个网际(AF_INET) 字节流(SOCK_STREAM) 套接字，它是TCP套接字的花哨名字。该函数返回一个小整数描述符，以后的所有函数调用(如随后的connect和read) 就用该描述符来标识这个套接字。

if语句包含3个操作: 调用socket函数，把返回值赋给变量sockfd,再测试所赋的这个值是否小于0：

```C
if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    err_sys("socket error");
}
```

虽然我们可以把该语句分割成两条C语句:

```c
sockfd = socket(AF_INET, SOCK_TREAM, 0);
if (sockfd < 0)
```

但是把这两行合并成一行却是常见的C语言习惯用法。按照C语言的优先规则(小于运算符的优先级高于赋值运算符)，函数调用和赋值语句外边的那对括号是必需的。作为一种编码风格，作者总是在这样的两个左括号间加一个空格，提示比较运算的左侧同时也是一个赋值运算。(这种风格借鉴自Minix源代码[Tenenbaum 1987 ]。) 该程序稍后的whi le语句也使用相同的样式。

#### 读入并输出服务器的应答

我们使用read函数读取服务器的应答，并用标准的IO函数fputs输出结果。使用TCP时必须小心，因为TCP是一个没有记录边界的字节流协议。服务器的应答通常是如下格式的26字节字符串:

```shell
Mon May 26 20:58:40 2003\r\n
```

其中，`\r`是ASCI回车符，`\n`是ASCII换行符。**使用字节流协议的情况下**，这26个字节，可以有多种返回方式: **既可以是包含所有26个字节的单个TCP分节,也可以是每个分节只含1个字节的26个TCP分节**，还可以是总共26个字节的任何其他组合。**通常服务器返回包含所有26个字节的单个分节,但是如果数据量很大，我们就不能确保一次read调用能返回服务器的整个应答**。因此从TCP套接字读取数据时，我们**总是需要把read编写在某个循环中**，当read返回0 (表明对端关闭连接) 或负值(表明发生错误) 时终止循环。

TCP本身并不提供记录结束标志:如果应用程序需要确定记录的边界，它就要自已去实现，已有一些常用的方法可供选择。

### 1.4、包裹函数

任何现实世界的程序都**必须检查每个函数调用是否返回错误**。

我们约定包裹函数名是实际函数名的首字母大写形式。

例如：

```c
int
Socket(int family, int type, int protocol) {
    int n;
    if ((n = socket(family, type, protocol)) < 0) {
        err_sys("socket error");
    }
    
    return n;
}
```

这些包裹函数不见得多节省代码量，但当我们在第26章中讨论线程时，将会发现**线程函数遇到错误时并不设置标准Unix的errno变量，而是把errno的值作为函数返回值返回调用者**。**这意味着每次调用以pthread开头的某个函数时，我们必须分配一个变量来存放函数返回值，以便在调用err_ sys前把errno变量设置成该值**。例如`pthread_mutex_lock`的包裹函数：

```c
void
Pthread_mutex_lock(pthread_mutex_t* mptr) {
    int n;
    
    if ((n = pthread_mutex_lock(mptr)) == 0) {
        return;
    }
    
    errno = n;
    err_sys("pthread_mutex_lock error");
}
```

要是仔细推敲C代码的编写，我们可以用宏来替代函数，从而稍微提高运行时效率，不过包裹函数很少是程序性能的瓶颈所在。

选择首字母大写一个函数名作为其包裹函数名是一种折中的方法。其他方法也考虑过，譬如给函数名加一个“e”前缀(如[ Kernighan and Pike 1984]一书第182页所示)，给函数名加一个“_e”后缀，等等。这些方法都能明显地提示调用了其他函数，但我们的这种风格看来是最少分散注意力的。

#### Unix errno值

只要一个Unix函数(例如某个套接字函数) 中有错误发生，全局变量errno就被置为一个指明该错误类型的正值，函数本身则通常返回 -1。err_sys查看errno变量的值并输出相应的出错消息,例如当errno值等于ETIMEDOUT吋,将输出“Connection timed out" (连接超吋)。

**在全局变量中存放errno值对于共享所有全局变量的多个线程并不适合**。

### 1.5、一个简单的时间获取服务器程序

我们指定IP地址为INADDR_ANY,这样**要是服务器主机有多个网络接口，服务器进程就可以在任意网络接口上接受客户连接**。以后我们将了解怎样限定服务器进程只在单个网络接口上接受客户连接。

```c
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
```

调用**listen函数把socket创建的套接字转换成一个监听套接字**。这样，来自客户的外来连接就可在该套接字上**由内核接受**。

#### 接受客户连接，发送应答

通常情况下，服务器进程在accept调用中被投入睡眠，等待某个客户连接的到达并被内核接受。TCP连接使用所谓的三路握手(three-way handshake) 来建立连接。握手完毕时accept返回，其返回值是一个称为已连接描述符(connected descriptor) 的新描述符(本例中为connfd)。该描述符用于与新近连接的那个客户通信。accept 为每个连接到本服务器的客户返回一个新描述符。

如果你尚不习惯改用snprintf代替较早的sprintf函数，那么现在是学习的时候了。**调用sprintf无法检查目的缓冲区是否溢出。相反，snprintf要求其第二个参数指定目的缓冲区的大小，因此可确保该缓冲区不溢出**。

```C
snprintf(buff, sizeof(buff), "%.24s\r\n", ctime());
```

值得注意的是，许多网络入侵是由黑客通过发送数据，导致服务器对`sprintf`的调用使其缓冲区溢出而发生的。必须小心使用的函数还有`gets`、`strcat`和`strcpy`，通常应分别改为调用`fgets`、`strncat`、`strncpy`，更好的代替函数是后来才引入的`strlcat`和`strlcpy`，它们确保结果是正确终止的字符串。

#### 终止连接

服务器通过调用close关闭与客户的连接。该调用引发正常的TCP连接终止序列: 每个方向上发送一个FIN,每个FIN又由各自的对端确认。2.6节将详细讲述TCP的三路握手

### 1.7、OSI模型

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/1.png)

网络层由IPv4和IPv6这两个协议处理,我们将在附录A中讲述它们。可以选择的传输层有TCP或UDP,我们将在第2章中讲述它们。图1-14中TCP与UDP之间留有间隙，表明**网络应用绕过传输层直接使用IPV4或IPV6是可能的**。这就是所谓的**原始套接字**(rawsocket)。

### 1.11、64位体系结构

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/2.png)

ANSI C创造了size_ t数据类型，它用于作为malloc的唯一参数(待分配的字节数)，或者作为read和write的第三个参数(待读或写的字节数)。**在32位系统中size_比是一个32位值，但是在64位系统中它必须是一个64位值，以便发挥更大寻址模型的优势**。这意味着64位系统中也许含有一个把size_ t定义为unsigned long的typedef指令。

## 第二章：传输层: TCP、UDP和SCTP

UDP是一个简单的、不可靠的数据报协议，而TCP是一个复杂、可靠的子节流协议。**SCTP与TCP类似之处在于它也是个可靠的传输协议，但它还提供消息边界、传输级别多宿(multihoming) 支持以及将头端阻塞(head-of-lineblocking) 减少到最小的一种方法**。我们必须了解由这些传输层协议提供给应用进程的服务，这样才能弄清这些协议处理什么，应用进程中又需要处理什么。

**使用诸如netstat等普遍可用的工具来调试客户和服务器程序**。

### 2.2、总图

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/3.png)

#### UDP

用户数据报协议(User Datagram Protocol )。UDP是一个无连接协议。UDP套接字是一种数据报套接字(datagram socket)。UDP数据报不能保证最终到达它们的目的地。与TCP一样，UDP既可以使用IPv4,也可以使用IPV6。

**UDP不保证每个数据报只到达其最终目的地一次**。

如果想要确保一个数据报到达其目的地，可以往应用程序中添置一大堆的特性: 来自对端的确认、本端的超时与重传等。

每个UDP数据报都有一个长度。如果一个数据报正确地到达其目的地，那么该数据报的长度将随数据一道传递给接收端应用进程。我们已经提到过TCP是一个字节流(byte -stream)协议，没有任何记录边界,这一点不同于UDP。

我们也说UDP提供无连接的(connectionless) 服务，因为UDP客户与服务器之间不必存在任何长期的关系。举例来说，一个UDP客户可以创建一个套接字并发送一个数据报给一个给定的服务器，然后立即**用同一个套接字发送另一个数据报给另一个服务器**。同样地，**一个UDP服务器可以用同一个UDP套接字从若干个不同的客户接收数据报，每个客户一个数据报**。

**UDP可以是全双工的**。

#### TCP

TCP含有用于**动态估算客户和服务器之间的往返时间**(round-rip time,RTT) 的算法，**以便它知道等待一个确认需要多少时间**。**举例来说，RTT在一个局域网上大约是几毫秒，跨越一个广域网则可能是数秒钟**。另外，因为RTT受网络流通各种变化因素影响，TCP还持续估算一个给定连接的RTT。

TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序(sequencing)。举例来说，假设一个应用写2048字节到一个TCP套接字，导致TCP发送2个分节: 第一个分节所含数据的序列号为1~ 1024,第二个分节所含数据的序列号为1025~2048。(**分节是TCP传递给IP的数据单元**。) 如果这些分节非顺序到达，接收端TCP将先根据它们的序列号重新排序，再把结果数据传递给接收应用。如果接收端TCP接收到来自对端的重复数据(譬如说对端认为一个分节已丢失并因此重传,而这个分节并没有真正丢失，只是网络通信过于拥挤)，它可以(根据序列号)判定数据是重复的，从而丢弃重复数据。

滑动窗口大小为0是有可能的: 当TCP对应某个套接字的接收缓冲区已满，导致它必须等待应用从该缓冲区读取数据时，方能从对端再接收数据。

TCP连接是全双工的(full-duplex)。建立一个全双工连接后，需要的话可以把它转换成一个单工连接。

#### SCTP

流控制传输协议(Stream Control Transmission Protocol )。SCTP是一个提供可靠全双工关联的面向连接的协议，我们使用“关联”一词来指称SCTP中的连接，因为SCTP是多宿的，从而每个关联的两端均涉及一组IP地址和一个端口号。**SCTP提供消息服务，也就是维护来自应用层的记录边界**。

#### ICMP

网际控制消息协议(Internet Control Message Protocol )。**ICMP处理在路由器和主机之间流通的错误和控制消息。这些消息通常由TCP/IP网络支持软件本身(而不是用户进程) 产生和处理**，不过图中展示的ping和traceroute程序同样使用ICMP。

#### ARP

地址解析协议(Address Resolution Protocol )。ARP把一个IPV4地址映射成一个硬件地址(如以太网地址)。ARP**通常用于诸如以太网、令牌环网和FDDI等广播网络，在点到点网络上并不需要**。

#### BPF

BSD分组过滤器(BSDpacket filter)。该接口**提供对于数据链路层的访问能力**，
通常可以在源自Berkeley的内核中找到。

### 2.5、流控制传输协议（SCTP）

SCTP在客户和服务器之间提供关联(association)， 并像TCP那样给应用提供可靠性、排序、流量控制以及全双工的数据传送。SCTP中使用“关联”词取代“连接”是为了避免这样的内涵:一个连接只涉及两个IP地址之间的通信。**一个关联指代两个系统之间的一次通信，它可能因为SCTP支持多宿而涉及不止两个地址**。

与TCP不同的是，SCTP是面向消息的，它提供各个记录的按序递送服务。与UDP一样，由发送端写入的每条记录的长度随数据一道传递给接收端应用。

SCTP能够在所连接的端点之间提供多个流，每个流各自可靠地按序递送消息。一个流上某个消息的丢失不会阻塞同一关联其他流上消息的投递。这种做法与TCP正好相反，**就TCP而言，在单一字节流中任何位置的字节丢失都将阻塞该连接上其后所有数据的递送，直到该丢失被修复为止**。

SCTP还提供多宿特性,使得单个SCTP端点能够支持多个IP地址。该特性可以增强应对网络故障的健壮性。一个端点可能有多个冗余的网络连接，每个网络又可能有各自接入因特网基础设施的连接。当该端点与另一个端点建立一个关联后，如果它的某个网络或某个跨越因特网的通路发生故障,SCTP就可以通过切换到使用已与该关联相关的另一个地址来规避所发生的故障。

### 2.6、TCP 连接的建立和终止

#### 2.6.2、TCP选项

##### MSS选项

发送SYN的TCP一端使用本选项通告对端它的最大分节大小(maxi mum segment size) 即MSS,也就是它在本连接的每个TCP分节中愿意接受的最大数据量。使用`TCP_MAXSEG`套接字选项提取和设置这个TCP选项。

##### 窗口规模选项

TCP连接任何一端能够通告对端的最大窗口大小是65535， 因为在TCP
首部中相应的字段占16位。然而当今因特网上业已普及的高速网络连接(45 Mbit/s或更快，如RFC 1323 [Jacobson,Braden,and Borman 1992] 所述)或长延迟路径(卫星链路)要求有更大的窗口以获得尽可能大的吞吐量。这个新选项指定TCP首部中的通告窗口必须扩大(即左移)的位数(0~14)，因此所提供的最大窗口接近1 GB (65535X2l4)。在一个TCP连接，上使用窗口规模的前提是它的两个端系统必须都支持这个选项。**使用SO RCVBUF套接字选项影响这个TCP选项**。

#### 2.6.3、TCP连接终止

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/4.png)

图2-3展示了客户执行主动关闭的情形，不过我们指出，无论是客户还是服务器，任何一端都可以执行主动关闭。**通常情况是客户执行主动关闭**,但是**某些协议(譬如值得注意的HTTP/1.0)却由服务器执行主动关闭**。

#### 2.6.5、观察分组

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/5.png)

一旦建立一个连接，客户就构造一个请求并发送给服务器。这里我们假设该请求适合于单个TCP分节(即请求大小小于服务器通告的值为1460字节的MSS)。服务器处理该请求并发送一个应答，我们假设该应答也适合于单个分节(本例即小于536字节)。**图中使用粗箭头表示这两个数据分节**。注意,服务器对客户请求的确认是伴随其应答发送的。这种做法称为捎带(pigevbacking),它通常在服务器处理请求并产生应答的时间少于200ms时发生。如果服务器耗用更长时间，譬如说1s，那么我们将看到先是确认后是应答。

图2-5中值得注意的是，如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答,那么使用TCP有8个分节的开销？（不是7个吗？握手3个 + 挥手4个）如果改用UDP,那么只需交换两个分组:
一个承载请求，一个承载应答。

然而从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的一大堆细节从传输层(TCP) 转移到UDP应用进程。TCP提供的另一个重要特性即拥塞控制也必须由UDP应用进程来处理。尽管如此，我们仍然需要知道**许多网络应用是使用UDP构建的，因为它们需要交换的数据量较少，而UDP避免了TCP连接建立和终止所需的开销**。

### 2.7、TIME WAIT 状态

分组在网络中“迷途”通常是路由异常的结果。某个路由器崩溃或某两个路由器之间的某个链路断开时，路由协议需花数秒钟到数分钟的时间才能稳定并找出另一条通路。在这段时间内有可能发生路由循环(路由器A把分组发送给路由器B,而B再把它们发送回A)，我们关心的分组可能就此陷入这样的循环。假设迷途的分组是一个TCP分节，在它迷途期间,发送端TCP超时并重传该分组，而重传的分组却通过某条候选路径到达最终目的地。然而不久后(自迷途的分组开始其旅程起最多MSL秒以内)路由循环修复，早先迷失在这个循环中的分组最终也被送到目的地。这个原来的分组称为迷途的重复分组(lost duplicate) 或漫游的重复分组(wanderingduplicate)。TCP必须正确处理这些重复的分组。

TIME WAIT状态有两个存在的理由:
(1) 可靠地实现TCP全双工连接的终止;
(2) 允许老的重复分节在网络中消逝。

第一个理由可以通过查看图2-5并**假设最终的ACK丢失了来解释。服务器将重新发送它的最终那个FIN**,因此客户必须维护状态信息（因此需要一个时间段来维护状态信息），以允许它重新发送最终那个ACK。**要是客户不维护状态信息，它将响应以一个RST (另外一种类型的TCP分节)，该分节将被服务器解释成一个错误**（不是很明白为什么要发一个RST给服务器？）。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流(即全双工关闭)，那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。**本例子也说明了为什么执行主动关闭的那一端是处于TIME_WAIT状态的那一端:因为可能不得不重传最终那个ACK的就是那一端**。

（我的理解是每次收到了一个`FIN N`主动断开连接的那一方就会重新进入一个`TIME_WAIT`状态。而这个`TIME_WAIT`状态包含的时间范围是 ACK N + 1 加上 重传的 FIN N。）

为理解存在TIME_WAIT状态的第二个理由，我们假设在12.106.32.254的1500端口和206.168.112.219的21端之间有一个TCP连接。我们关闭这个连接，过一段时间后在相同的IP地址和端口之间建立另一个连接。后一个连接称为前一个连接的化身(incamnation),因为它们的IP地址和端口号都相同。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解成属于同一连接的某个新的化身。为做到这一点，TCP将不给处于TIME WAIT状态的连接发起新的化身。既然TIME WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。

TCP的TIME_ WAIT状态一直是一个造成网络编程人员混淆的来源。存在这一状态是**为了实现TCP的全双工连接终止(即处理最终那个ACK丢失的情形)，并允许老的重复分节从网络中消逝**。

### 2.8、SCTP关联的建立和终止

#### 2.8.1、四路握手

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/6.png)

SCTP的四路握手在很多方面类似于TCP的三路握手，差别主要在于作为SCTP整体一部分的cookie的生成。

在SCTP中使用四路握手是为了避免一种将在4.5节讨论的拒绝服务攻击。

#### 2.8.2、关联终止

SCTP不像TCP那样允许“半关闭”的关联。当一端关闭某个关联时，另一端必须停止发送新的数据。关联关闭请求的接收端发送完已经排队的数据(如果有的话) 后，完成关联的关闭。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/7.png)

### 2.10、TCP端口号与并发服务器

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/8.png)

下一步我们假设在客户主机上另有一个客户请求连接到同一个服务器。客户主机的TCP为这个新客户的套接字分配一个未使用的临时端口，譬如说1501，如图2-14所示。服务器上这两个连接是有区别的:第一个连接的套接字对和第二个连接的套接字对不一-样，因为客户的TCP给第二个连接选择了一个未使用的端口(1501)。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/9.png)

通过本例应注意，TCP无法仅仅通过查看目的端[ 1号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。图2-14中对于同一个本地端口(21)存在3个套接字。如果一个分节来自206.168.112.219端口1500,目的地为12.106.32.254端口21,它就被递送给第一个子进程。如果一个分节来自206.168.112.219端口1501,目的地为12.106.32.254端口21,它就被递送给第二个子进程。所有目的端口为21的其他TCP分节都被递送给拥有监听套接字的最初那个服务器(父进程)。

### 2.11、缓冲区大小及限制

在两个主机之间的路径中最小的MTU称为路径MTU (path MTU)。1500字节的以太网MTU是当今常见的路径MTU。两个主机之间相反的两个方向.上路径MTU可以不一致，因为在因特网中路由选择往往是不对称的[Paxson 1196],也就是说从A到B的路径与从B到A的路径可以不相同。

当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路MTU,IPv4和IPV6都将执行分片(fragmentation)。这些片段在到达最终目的地之前通常不会被重组(reassembling)。**IPV4主机对其产生的数据报执行分片，IPv4路由器则对其转发的数据报执行分片**。**然而IPV6只有主机对其产生的数据报执行分片，IPv6路由器不对其转发的数据报执行分片**。

TCP有一个MSS (maximum segment size,**最大分节大小**),用于**向对端TCP通告**对端在每个分节中能发送的最大TCP数据量。MSS的目的是告诉对端其重组缓冲区大小的实际值，**从而试图避免分片**。

#### 2.11.1、TCP输出

图2-15展示了某个应用进程写数据到一一个TCP套接字中时发生的步骤。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/10.png)

**每一个TCP套接字有一个发送缓冲区**，**我们可以使用SO_SNDBUF套接字选项来更改该缓冲区的大小**(见7.5节)。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据)，该应用进程将被投入睡眠。这里假设该**套接字是阻塞的，它是通常的默认设置**。**内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区**。因此，**从写一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据**。

这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP,其过程基于TCP数据传送的所有规则(TCPv1的第19章和第20章)。**对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达,本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据**。**TCP必须为已发送的数据保留一个副本，直到它被对端确认为止**。

#### 2.11.2、UDP输出

图2-16展示了某个应用进程写数据到一个UDP套接字中时发生的步骤。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/11.png)

这一次我们以虚线框展示套接字发送缓冲区，因为**它实际上并不存在**。任何UDP套接字都有发送缓冲区大小，不过它仅仅是可写到该套接字的UDP数据报的大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。**因为UDP是不可靠的，所以它不必保存应用进程数据的一个副本，因此无需一个真正的发送缓冲**区。(**应用进程的数据在沿协议栈向下传递时，通常被复制到某种格式的一个内核缓冲区中，然而当该数据被发送之后，这个副本就被数据链路层丢弃了**。)

如果某个UDP应用进程发送大数据报(譬如说2000字节的数据报),那么它相比TCP应用数据更有可能被分片，因为TCP会把应用数据划分成MSS大小的块，而UDP却没有对等的手段。

### 2.13、常见因特网应用的协议使用

因特网应用ping和traceroute是使用ICMP协议实现的网络诊断应用。**traceroute自行构造UDP分组来发送并读取所引发的ICMP应答**。

## 第三章：套接字编程简介

### 3.2、套接字地址结构

大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。**每个协议族都定义它自己的套接字地址结构**。这些结构的名字均以`sockaddr_`开头，并以对应每个协议族的唯一后缀结尾。

#### 3.2.1、IPv4套接字地址结构

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/12.png)

32位IPv4地址存在两种不同的访问方法。举例来说，如果serv定义为某个网际套接字地址结构，那么serv.sin_ addr将按in_ addr结构引用其中的32位IPv4地址，而serv.sin_ addr.s_addr将按in_addr_t (通常是一个无符号的32位整数)引用同一个32位IPv4地址。因此，**我们必须正确地使用IPv4地址，尤其是在将它作为函数的参数时，因为编译器对传递结构和传递整数的处理是完全不同的**。

sin_zero字段未曾使用，不过在填写这种套接字地址结构时，我们总是把该字段置为0。按照惯例，我们总是在填写前把**整个sockaddr_in结构**置为0，而不是单单把sin_zero字段置为0。

#### 3.2.2、通用套接字地址结构

当作为一个参数传递进任何套接字函数时，套接字地址结构总是以引用形式(也就是以指向该结构的指针)来传递。然而以这样的指针作为参数之一的任何套接字函数**必须处理来自所支持的任何协议族的套接字地址结构**。

在如何声明所传递指针的数据类型上存在一个问题。有了ANSI C后解决办法很简单: void*是通用的指针类型。然而套接字函数是在ANSIC之前定义的，在1982年采取的办法是在<sys/socket. h>头文件中定义一个通用的套接字地址结构，
如图3-3所示。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/13.png)

#### 3.2.3、IPv6套接字地址结构

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/14.png)

IPv6的地址族是AF_ INET6, 而IPv4的地址族是AF_ INET。

### 3.3、值-结果参数

我们提到过，当往一个套接字函数传递一个套接字地址结构时，该结构总是以引用形式来传递，也就是说传递的是指向该结构的一个指针。该结构的长度也作为一个参数来传递，不过其传递方式取决于该结构的传递方向:是从进程到内核，还是从内核到进程。

(1)从进程到内核传递套接字地址结构的函数有3个: bind、connect和sendto.这些函数的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小，例如:

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/15.png)

既然指针和指针所指内容的大小都传递给了内核，于是内核知道到底需从进程复制多少数据进来。图3-7展示了这个情形。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/16.png)

(2)从内核到进程传递套接字地址結杓的函数有4个: accept、recvfrom、getsockname和getpeername。这4个函数的其中两个参数是指向某个套接字地址结构的指针和指向表示该结构大小的整数变量的指针。

把套接字地址结构大小这个参数从一个整数改为指向某个整数变量的指针，其原因在于:当函数被调用时，结构大小是一~个值(value)， 它告诉内核该结构的大小，这样内核在写该结构时不至于越界;当函数返回时，结构大小又是一个结果(result),它告诉进程内核在该结构中究竟存储了多少信息。这种类型的参数称为值-结果(value-result) 参数。图3-8展示了这个情形。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/17.png)

### 3.9、readn、writen和read1ine函数

在网络编程的读取/写入数据，通常会需要用到一个读/写指定字节才返回的函数。

字节流套接字(例如TCP套接字)上的read和write函数所表 现的行为不同于通常的文件I/O。字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少，然而这不是出错的状态。这个现象的原因在于内核中用于套接字的缓冲区可能已达到了极限。此时所需的是调用者再次调用reaa或write函数，以输入或输出剩余的字节。有些版本的Unix在往一个管道中写多于4096字节的数据时也会表现出这样的行为。这个现象在read一个字节流套接字时很常见，但是在write一个字节流套接字时只能在该套接字为非阻塞的前提下才出现。

## 第四章：基本TCP套接字编程

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/18.png)

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/19.png)

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/20.png)

### 4.3、connect函数

调用connect函数将激发TCP的三路握手过程。而且仅在连接建立成功或者出错时才返回，其中出错返回可能有以下几种情况。

(1)若TCP客户没有收到SYN分节的响应，则返回ETIMBDOUT错误。举例来说，调用connect函数时，4.4BSD内核发送一个SYN，若无响应则等待6s后再发送一个，若仍无响应则等待24s后再发送一个(TCPv2第828页)。若总共等了75s后仍未收到响应则返回本错误。

(2)**若对客户的SYN的响应是RST** (表示复位)，则表明该服务器主机在我们指定的端口上没有进程在等待与之连接(例如服务器进程也许没在运行)。这是一种硬错误(hard error),客户一接收到RST就**马上返回**ECONNREFUSED错误。

RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是:目的地为某端口的SYN到达（也就是说，**SYN到达了目的主机的那个端口**），然而该端口上没有正在监听的服务器(如前所述); TCP想取消一个已有连接; TCP接收到一个根本不存在的连接上的分节。

按照TCP状态转换图(图2-4)，connect函数导致当前套接字从CLOSED状态(该套接字自从由socket函数创建以来一直所处的状态)转移到SYN SENT状态，若成功则再转移到ESTABLISHED状态。**若connect失败则该套接字不再可用，必须关闭，我们不能对这样的套接字再次调用connect函数**。在图11-10中我们将看到，当循环调用函数connect为给定主机尝试各个IP地址直到有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket.

### 4.4、bind函数

这个规则的例外是远程过程调用( Remote Procedure Call,RPC)服务器。它们通常就由内核为它们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。客户在connect这些服务器之前，必须与端口映射器联系以获取它们的临时端口。这种情况也适用于使用UDP的RPC服务器。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/21.png)

捆绑(binding) 操作涉及三个对象: 套接字(在XTI AP1中为端点)、地址及端口。其中**套接字是拥绑的主体，地址和端口是捆绑在套接字上的客**体。

如果指定端口号为0,那么内核就在bind被调用时选择一个临时端口。然而如果指定IP地址为通配地址，那么内核将等到套接字E连接(TCP)或已在套接字上发出数据报(UDP)时才选择一个本地IP地址。

对于IPv4来说，通配地址由常值INADDR_ ANY来指定，其值~一般为0。它告知内核去选择IP地址：

```c
struct sockaddr_ in servaddr;
servaddr.sin_ addr.s_ addr = htonl (INADDR_ ANY) ;
```

如果让内核来为套接字选择一个临时端口号，那么必须注意，函数bind并不返回所选择的值。实际上，由于bind函数的第二个参数有const限定词，它无法返回所选之值。为了得到内核所选择的这个临时端口值，必须调用函数get sockname来返回协议地址。

### 4.5、listen函数

listen函数仅由TCP服务器调用，它做两件事情。

(1)当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是说，它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。根据TCP状态转换图(图2-4)，**调用listen导致套接字从CLOSED状态转换到LISTEN状态**。

(2)本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。

我们必须认识到内核为任何一个给定的监听套接字维护两个队列：

(1) 未完成连接队列(incomplete connection queue),每个这样的SYN分节对应其中一项:已由某个客户发出并**到达服务器**，而**服务器正在等待完成相应的TCP三路握手过程**。这些套接字处于SYN_RCVDA状态。

(2)已完成连接队列(completed connection queue),每个已完成TCP三路握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/22.png)

每当在未完成连接队列中创建一项时， 来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。图4-8展示了用这两个队列建立连接时所交换的分组。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/23.png)

如果三路握手正常完成，该项就从未完成连接队列转移到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项将返回给进程，或者如果该队列为空，那么进程将被投入**睡眠**（假定套接字为默认的阻塞方式），直到tcp在该队列中放入一项才唤醒它。

**当一个客户SYN到达时，若这些队列是满的, TCP就忽略该分节**(TCPv2第930~931页),也就是不发送RST。这么做是因为: 这种情况是暂时的，客户TCP将重发SYN，期望不久就能在这些队列中找到可用空间。**要是服务器TCP立即响应以一个RST,客户的connect调用就会立即返回一个错误，强制应用进程处理这种情况，而不是让TCP的正常重传机制来处理**。另外，客户无法区别响应SYN的RST究竟意味着“该端口没有服务器在监听”，还是意味着“该端口有服务器在监听，不过它的队列满了”。

### 4.6、accept函数

如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，**代表与所返回客户的TCP连接**。在讨论accept函数时，我们称它的第一个参数为**监听套接字**(listening socket)描述述符(由socket创建，随后用作bind和listen的第-一个参数的描述符)，称它的返回值为**已连接套接字**(connected socket)描述符。

### 4.7、fork 和 exec 函数

fork在子进程返回0而不是父进程的进程ID的原因在于: 任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以有许多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID,那么它必须记录每次调用fork的返回值。

**父进程中调用fork之前打开的所有描述符在fork返回之后与子进程共享**。我们将看到网络服务器利用了这个特性:父进程调用accept之后调用fork。所接受的已连接套接字随后就在父进程与子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字。

**存放在硬盘上的可执行程序文件能够被Unix执行的唯一方法是:由一个现有进程调用六个exec函数中的某一个**。(当这6个函数中是哪一个被调用并不重要时，我们往往把它们统称为exec函数。) exec把当前进程映像替换成新的程序文件，而且**该新程序通常从main函数开始执行。进程ID并不改变**。我们称调用exec的进程为调用进程(calling process), 称新执行的程序为新程序(new program)。

（**较老的手册和书本不确切地称新程序为新进程(new process) ,这是错误的，因为其中并没有创建新的进程**。）

这6个exec函数之间的区别在于: (a) 待执行的程序文件是由文件名(filename) 还是由路径名(pathname) 指定; (b) 新程序的参数是一一列出还是由一个指针数组来引用; (c)把调用进程的环境传递给新程序还是给新程序指定新的环境。

这6个函数间的关系如图4- 12所示。一般来说，只有execve是内核中的系统调用，其他5个都是调用execve的库函数。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/24.png)

注意这6个函数的下列区别。
(1)上面那行的3个函数把新程序的每个参数字符串指定成exec的一个独立参数，并**以一个空指针结束可变数量的这些参数**（用来指示后面已经没有参数了）。下面那行的3个函数都有一个作为exec参数的argv数组，其中含有指向新程序各个参数字符串的所有指针。**既然没有指定参数字符串的数目，这个argv数组必须含有一个用于指定其末尾的空指针**。

(2)左列2个函数指定一个filename参数。exec将使用当前的PATH环境变量把该文件名参数转换为一个路径名。然而一旦这2个函数的flename参数中含有一个斜杠(/)，就不再使用PATH环境变量。右两列4个函数指定一个全限定的pathname参数。

(3)左两列4个函数不显式指定一个环境指针。相反，它们使用外部变量environ的当前值来构造一个传递给新程序的环境列表。右列2个函数显式指定一个环境列表，其envp指针数组必须以一个空指针结束。

**进程在调用exec之前打开着的描述符通常跨exec继续保持打开。我们使用限定词“通常”是因为本默认行为可以使用fcnt1设置FD_ _CLOEXEC描述符标志禁止掉**。

### 4.8、并发服务器

一个典型的并发服务器程序的轮廓：

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/25.png)

我们在2.6节说过，对一个TCP套接字调用close会导致发送一个FIN，随后是正常的TCP连接终止序列。为什么图4-13中父进程对connfa调用close没有终止它与客户的连接呢?为了便于理解，我们必须知道每个文件或套接字都有一个引用计数。引用计数在文件表项中维护，它是当前打开着的引用该文件或套接字的描述符的个数。图4-13中，socket返回后与listenfa关联的文件表项的引用计数值为1。accept返回后与connfd关联的文件表项的引用计数值也为1。然而fork返回后，这两个描述符就在父进程与子进程间共享(也就是被复制)，因此与这两个套接字相关联的文件表项各自的访问计数值均为2。这么一来，当父进程关闭connfd时，它只是把相应的引用计数值从2减为1.该套接字真正的清理和资源释放要等到其引用计数值到达0时才发生。这会在稍后子进程也关闭connfa时发生。

我们还可以将图4-13中出现的套接字和连接用图示直观地表现出来。首先，图4-14给出 了在服务器阻塞于accept调用且来自客户的连接请求到达时客户和服务器的状态。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/26.png)

从accept返回后，我们立即就有图4- 15所示状态。连接被内核接受，新的套接字connfd被创建。这是一个已连接套接字，可由此跨连接读写数据。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/27.png)

并发服务器的下一步是调用fork,图4-16给出了从fork返回后的状态。

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/28.png)

注意,此时listenfd和connfd这两个描述符都在父迸程和子迸程之间共享〈被复制)。再下一步是由父迸程关闭已连接套接字,由子迸程关闭监听套接字,如图4-17所示：

![](http://oklbfi1yj.bkt.clouddn.com/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/29.png)

这是这两个套接字所期望的最终状态。子进程处理与客户的连接，父进程则可以在监听套接字上再次调用accept来处理下一个客户连接。

### 4.9、close函数

close-一个TCP套接字的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。然而**TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列**(2.6节)。

#### 描述符引用计数

并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数值减1。既然引用计数值仍大于0,这个close调用并不引发TCP的四分组连接终止序列。对于父进程与子进程共享已连接套接字的并发服务器来说，这正是所期望的。**如果我们确实想在某个TCP连接上发送一个FIN，那么可以改用shutdowm函数(6.6节)以代替close**。







































































































































