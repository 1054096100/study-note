# 《算法竞赛入门经典》

一定要注意：**举特例**来解题（因为这样更好理解和发现规律）

### 1、短路运算符

C语言中的逻辑运算符都是短路运算符。 一旦能够确定整个表达式的值，就不再继续计算

### 2、算法竞赛的目标

算法竞赛的目标是编程对任意输入均得到正确的结果，而不仅是样例数据 

### 3、并列、不交叉

如果有**多个并列、 情况不交叉的条件**需要一一处理，可以用**else if**语句 

### 4、数组声明

在算法竞赛中，常常难以精确计算出需要的数组大小，**数组一般会声明得稍大一些**。 在空间够用的前提下，浪费一点不会有太大影响

### 5、数组放在main函数外面声明

只有在main函数外时，数组才可以开得很大；**放在main函数内时，数组稍大就会异常退出**（比较大的数组应尽量声明在main函数外，否则程序可能无法运行 ）

因为放在函数中（包括main函数）的变量是局部变量，而局部变量是放在堆栈段中的。栈溢出不一定是递归调用太多，也可能是**局部变量太大**。 只要总大小超过了栈空间允许的范围，就会产生栈溢出

### 6、数据、空格的格式输出

为了避免输出多余空格，设置了一个标志变量first，可以表示当前要输出的变量是否为第一个。 第一个变量前不应有空格，但其他变量都有

```c
int first = 1;
for (int i = 1; i <= n; i++) {
  if(a[i]) {
    if (first) {// 如果是输出第一个变量，那么不需要输出空格
      first = 0;
    }
    else {//如果不是第一个变量，那么需要输出空格
      printf(" ");
    }
    printf("%d", i);//输出变量
  }
}

	
```

其实也可以让第一个数据单独先输出来，之后的数据再按照先输出空格、再输出数据的格式

### 7、蛇形填数

其实，关键点就是要知道，**填数的每一步，都是数组的下标在改变**，而且，这下标的变化是有规律的（也就是说，把一个实际的问题模型化）

然后就是判断什么时候要填数字

### 8、先判断，再做事情

在很多情况下，最好是在做一件事之前检查是不是可以做，而不要做完再后悔。 因为“悔棋”往往比较麻烦 

### 9、C语言字符

C语言中的字符型用关键字char表示，它**实际存储的是字符的ASCII码**。 字符常量可以用单引号法表示。 **在语法上可以把字符当作int型使用**，所以，可以用两个字符做四则运算（例如：`'b' - 'a' = 1`）

### 10、不要滥用 ++

滥用“++”、 “—”、 “+=”等可以修改变量值的运算符很**容易带来隐蔽的错误**。 

**建议：**

**每条语句最多只用一次这种运算符**

**并且所修改的变量在整条语句中只出现一次**（例如，`i= i++`就是不允许的） 

### 11、读取包含空格的字符串

使用**fgetc(fin)可以从打开的文件fin中读取一个字符**。 一般情况下应当在检查它不是EOF后再将其转换成char值。 从标准输入读取一个字符可以用**getchar**，它等价于 `fgetc(stdin) `

如果字符串不包含空白字符，可以安全地使用scanf进行输入：

```c
while (scanf("%s", s) == 1) { //scanf返回成功赋值的数据项数，出错时则返回EOF
  /* coding */
}
```

### 12、读取完整的一行放在数组中

**fgets(buf, maxn, fin)将读取完整的一行放在字符数组buf中**。 应当保证buf足够存放下文件的一行内容。 除了在文件结束前没有遇到“\n”这种特殊情况外，buf总是以“\n”结尾。 当一个字符都没有读到时，fgets返回NULL 

### 13、避免写出操作系统相关的程序

在使用 fgetc 和 getchar 时，应该避免写出和操作系统相关的程序

### 14、常量数组

**常量数组并不需要指明大小，编译器可以完成计算**

```c
char s[] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";
```

注意，字符串中的`\\`不是两个`\\`，而是转义，所以是一个`\`

一般知道了所有的字符后，可以使用常量数组来解题

### 15、字典序

所谓字典序，就是字符串在字典中的顺序。一般地，对于两个字符串，从第一个字符开始比较，当某一个位置的字符不同时，该位置字符较小的串，字典序较小（例如，abc比bcd小）；如果其中一个字符串已经没有更多字符，但另一个字符串还没结束，则较短的字符串的字典序较小（例如，hi比history小）。 字典序的概念可以推广到任意序列，例如，序列1, 2, 4, 7比1, 2, 5小。

### 16、环状串

一般遇到环状串的问题，要考虑是否要使用取模`%`，因为这样可以避免数组越界的问题

### 17、计算机内部整数的表示

在多数计算机内部，整数采用的是**补码表示法**

### 18、main函数的返回值

main函数也是有返回值的，在算法竞赛中，除了有特殊规定之外，请总是让其返回0，以免评测系统错误地认为程序异常退出了（这个0代表“正常结束”）

main函数的返回值是返回给操作系统的

### 19、定义结构体的方法

```c
struct 结构体名称{ 域定义 }; //注意花括号的后面还有一个分号
```

举个例子：

```c
struct Point{ double x, y; };
double dist(struct Point a, struct Point b)
{
	return hypot(a.x-b.x, a.y-b.y);
}
```

这样用起来有些不合习惯：所有用到结构体的地方都得写一个 `struct`。 有一个方法可以避开这些 `struct`，让结构体用起来和int、 double这样的“原生”类型更接近

```c
typedef struct{ double x, y; } Point;
double dist(Point a, Point b)
{
	return hypot(a.x-b.x, a.y-b.y);
}
```

所以，为了使用方便，往往用`typedef struct { 域定义; }类型名;`的方式定义一个新类型名。这样，就可以像原生数据类型一样使用这个自定义类型

### 20、long long类型

这样定义一个变量的话，那么它的**取值范围会很大**

### 21、谓词

建议把谓词（用来判断某事物是否具有某种特性的函数）命名成 `is_xxx` 的形式，返回int值，非0表示真，0表示假 

### 22、调用栈

调用栈描述的是函数之间的调用关系。 它由多个栈帧（Stack Frame）组成，每个栈帧对应着一个未运行完的函数。 栈帧中保存了该函数的返回地址和局部变量，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证了不同函数间的局部变量互不相干——因为不同函数对应着不同的栈帧

在 `gdb `中可以用 `backtrace`（简称bt）命令打印所有栈帧信息。 若要用p命令打印一个非当前栈帧的局部变
量，可以用 `frame` 命令选择另一个栈帧

### 23、使用gdb来查看调用栈

**1.首先编译程序**，并且加入调试信息：`gcc -g file.c` （`-g`告诉编译器生成调试信息 ）

**2.启动GDB进行调试**：`gdb ./a.exe`（在windows下）或者 `gdb ./a.out`（在Linux下）

**3、查看源码**：`l`（注意，这是字母`l`，而不是数字1；并且，只按一次`l`不一定会把源码全部显示完全，需要多按几次）

**3.在函数D处打一个断点**：b 源代码的第几行（一个数字）

除了可以按行号设置外，也可以直接**指定函数名，断点将设置在函数的开头**

**4.运行程序**：r（`r`是`run`的意思，遇到断点停止运行）

**5.查看函数调用栈**：bt

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/1.PNG)

调用栈中包含两个栈帧：#0 和#1，其中0号是当前栈帧--swap函数，1号是其“上一个”栈帧main函数。 这里甚至能看到swap函数的返回地址`0x00401356 `

注意，因为我把断点设在了`func_a`函数里的位置，所以，程序是执行到了`func_a`函数的地方停止的，所以，当前栈帧是`func_a`函数

`up`命令可以选择上一个栈帧

6、打印栈帧中的变量：p a（其中，p命令可以打印变量值，而a则是栈帧中的一个变量）

注意：实参被赋值到形参之后，main函数中的a和b也完成了它们的使命。 swap函数甚至无法知道main函数中也有着和形参同名的a和b变量，当然也就无法对其进行修改

### 24、地址

C语言的变量都是放在内存中的，而**内存中的每个字节都有一个称为地址（address）的编号**。 每个变量都占有一定数目的字节（可用sizeof运算符获得），其中**第一个字节的地址称为变量的地址**

### 25、取内容运算符

`*`

*a是指“a指向的变量”，而不仅是“a指向的变量所拥有的值”

 理解这一点相当重要。 例如，*a = *a + 1就是让a指向的变量自增1

### 26、不要滥用指针

千万不要滥用指针，这不仅会把自己搞糊涂，还会让程序产生各种奇怪的错误

### 27、指向常数的“万能”的指针

```c
const void *
```

它**可以通过强制类型转换变成任意类型的指针**

例如：

```c
int cmp ( const void *a , const void *b ) {
	return *(int *)a - *(int *)b;
}
```

### 28、递归

C语言支持递归，即函数可以直接或间接地调用自己。 但要注意为递归函数编写终止条件，否则将产生无限递归

在C语言的函数中，调用自己和调用其他函数并没有任何本质区别，都是建立新栈帧，传递参数并修改当前代码行。 在函数体执行完毕后删除栈帧，处理返回值并修改当前代码行

在编写递归函数的时候，建议先**写终止条件**

### 29、段错误与栈溢出

“段”（segmentation）是指二进制文件内的区域，所有某种特定类型信息被保存在里面。可以用size程序得到可执行文件中各个段的大小

例如：

```c
#include <stdio.h>

void func_a();

int main(int argc, char const *argv[])
{
        func_a();
        return 0;
}

void func_a()
{
        printf("我是func_a()\n");
}
```

编译后，我们使用`size`程序：

```shell
size a.exe
```

结果：

![](http://oklbfi1yj.bkt.clouddn.com/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/2.PNG)

此结果表示a.exe由正文段、 数据段和bss段组成，总大小是3720，用十六进制表示为e88

在可执行文件中，正文段（Text Segment）用于**储存指令**，数据段（DataSegment）用于**储存已初始化的全局变量**，BSS段（BSS Segment）用于**储存未赋值的全局变量**所需的空间

而调用栈并不存在可执行文件中，而是在运行时创建。调用栈所在的段称为堆栈段（Stack Segment）。和其他段一样，堆栈段也有自己的大小，不能被越界访问，否则就会出现段错误

每次递归调用都需要往调用栈里增加一个栈帧，久而久之就越界了。 这种情况叫做**栈溢出**

在**运行时**，程序会**动态创建**一个**堆栈段**，里面**存放着调用栈**，因此**保存着函数的调用关系和局部变量**

栈空间的大小和操作系统相关，并且可以改变

### 30、写代码的顺序

#### 自顶向下

先写框架，再写细节（先写主程序，包括对函数的调用，再实现函数本身）

#### 自底向上

先写函数，再写主程序（对于编写复杂软件来说，自底向下的构建方式有它独特的优势。但在算法竞赛中，这样做的选手并不多见）

### 31、清空数组

使用`memset`清空数组是个好习惯

### 32、函数不能返回局部变量的地址

局部变量是在栈中，函数执行完毕后，局部变量就失效了。 严格地讲，指针里保存的地址仍然存在，但不再属于那个局部变量了。 这时如果修改那个指针指向的内容，程序有可能会崩溃，也可能悄悄地修改了另外一个变量的值，使程序输出一个莫名其妙的结果

### 33、使用C++来参加写算法

C＋＋能编译大多数C语言程序。 **虽然C语言中大多数头文件在C＋＋中仍然可以使用，但推荐的方法是在C头文件之前加一个小写的c字母，然后去掉.h后缀**

### 34、C++流

相比 scanf 的最大优势就是不再需要记忆%d、 %s等占位符，同时也避开了前面提到的“long long类型的输入输出占位符不统一”的问题

C＋＋流也不是完美的，其最大缺点就是运行太慢，以至于很多竞赛题目会在题面中的显著位置注明：本题的输入量很大，请不要使用C＋＋的流输入

### 35、命名空间

头文件 `iostream`和 `algorithm `里定义的内容放在std名称空间里

C＋＋中可以使用流简化输入输出操作。 标准输入输出流在头文件iostream中定义，存在于名称空间std中。 如果使用了using namespace std语句，则可以直接使用（而不需要写成`std：：cin `，可以直接使用`cin`）

### 36、引用

C＋＋提供了“引用”，虽然在**功能上比指针弱**，但是减少了出错的可能，提高了代码的可读性

### 37、不定长数组：vector 

它把一些常用操作“封装”在了vector类型内部。例如，若a是一个vector，可以用a.size( )读取它的大小，a.resize( )改变大小，a.push_back( )向尾部添加元素，a.pop_back( )删除最后一个元素，clear( )清空数组，empty( )测试是否为空

vector是一个**模板类**，所以需要用`vector<int>a`或者`vector<double>b`这样的方式来声明一个 vector，`vector<int>`是一个类似于的整数数组 `int a[]`，而而`vector<string>`就是一个类似于`string a[]`的字符串数组

vector之间**可以直接赋值**或者**作为函数的返回值**

把vector作为参数或者返回值时，应尽量改成用引用方式传递参数，以避免不必要的值被复制

### 38、集合：set

集合是个常用的容器。 set就是数学上的集合——每个元素最多只出现一次

### 39、迭代器：iterator 

类似于指针

### 40、映射：map

映射是个常用的容器（map也称为“关联数组” ）

map就是从键（key）到值（value）的映射（原理是重载了`[]`运算符 ）

例如：

用`map<string，int>month_name`表示“月份名字到月份编号”的映射，然后用`month_name["July"]=7`这样的方式来赋值

第一个参数代表键的类型，第二个参数代表值的类型

vector、 set和map都很快，其中vector的速度接近数组（但仍有差距）。尽管如此，在一些对时间要求非常高的题目中，**STL有时会成为性能瓶颈**

### 41、栈、 队列与优先队列

#### 栈

STL的栈定义在头文件`<stack>`中，可以用 `stack<int>s` 方式声明一个栈

用`push()`和`pop()`实现元素的入栈和出栈操作，`top()`取栈顶元素（但不删除）

#### 队列

STL的队列定义在头文件`<queue>`中，可以用`queue<int>s`方式声明一个队列

用`push()`和`pop()`进行元素的入队和出队操作,`front()`取队首元素（但不删除）

#### 优先队列

STL的优先队列定义在头文件`<queue>`里，用`priority_queue<int>pq`来声明。 这个`pq`是一个“越小的整数优先级越低的优先队列”。 由于出队元素并不是最先进队的元素，出队的方法由queue的front()变为了top()

#### 双端队列

如果要在“队列”两端进行插入和删除，可以用STL中的双端队列`deque`

### 42、随机数的生成

`cstdlib`中的`rand()`可生成闭区间[0，RAND_MAX]内均匀分布的随机整数，其中RAND_MAX至少为32767。如果要生成更大的随机整数，在精度要求不太高的情况下可以用rand()的结果“放大”得到

需要随机数的程序在最开始时一般会执行一次srand（time（NULL）），目的是初始化“随机数种子”。 简单地说，种子是伪随机数计算的依据。 种子相同，计算出来的“随机数”序列总是相同。 如果不调用srand而直接使用rand( )，相当于调用过一次srand（1），因此程序每次执行时，将得到同一套随机数

**注意：只在程序开头调用一次srand，而不要在同一个程序中多次调用**

### 43、assert宏 

```c
assert(表达式); //当表达式为 真时 无变化，但当表达式为 假时 强行 终止程序，并且给出错误提示
```

### 44、链表

在数组中**频繁移动元素**是很低效的，如有可能，可以使用链表

### 45、通过左移运算符计算2的次方

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
	int n = 3;
	printf("%d\n", (1 << n));
	return 0;
}
```

结果：

```shell
8
```

### 46、内存泄漏

如果程序**动态申请内存**，请**注意内存泄漏**。 **程序执行完毕后，操作系统会回收该程序申请的所有内存（包括泄漏的）**，所以在算法竞赛中内存泄漏往往不会造成什么影响。 但是，从专业素养的角度考虑，请从现在开始养成好习惯，对内存泄漏保持警惕 

例如，我有一个文件（`SortTestHelper.h`）：

```C++
#include <iostream>
#include <ctime>
#include <cassert>

using namespace std;

namespace SortTestHelper {
	/*
	生成有n个元素的随机数组，每个元素的随机范围为
	[rangeL, rangeR]
	*/

	int* generateRandomArray(int n, int rangeL, int rangeR) {
		assert(rangeL <= rangeR);

		int *arr = new int[n];
		srand(time(NULL));
		for (int i = 0; i < n; i++) {
			arr[i] = rand() % (rangeR - rangeL) + rangeL;
		}
		return arr;
	}
}
```

注意：因为**arr**得到的内存是**从堆中分配的，所以可以返回**。正是因为不会自动释放，所以，在用完了之后，要**记得手动释放**。但是，如果是在函数中直接声明的数组是不能直接返回的，因为是从栈空间分配的

因为`generateRandomArray`这个函数使用了`new`动态分配了内存，所以

那么我在使用这个文件里面这样写（释放从堆中分配的内存）：

```C++
#include <iostream>
#include <algorithm>
#include <string>
#include "Student.h"
#include "SortTestHelper.h"

using namespace std;

template<typename T>
void selectionSort(T arr[], int n) {
	for (int i = 0; i < n; i++) {
		int minIndex = i;
		for (int j = i + 1; j < n; j++) {
			if (arr[j] < arr[minIndex]) {
				minIndex = j;
			}
		}
		swap(arr[i], arr[minIndex]);
	}
}

int main(int argc, char const *argv[])
{
	int n = 10000;
	int *arr = SortTestHelper::generateRandomArray(n, 0, n);
	selectionSort(arr, n);
	SortTestHelper::printArray(arr, n);

	delete[] arr; //因为arr开的是数组空间，所以用delete[]
	return 0;
}
```

47、命名空间的使用

`SortTestHelper.h`文件

```c++
#include <iostream>
#include <ctime>
#include <cassert>

using namespace std;

namespace SortTestHelper {
	/*
	生成有n个元素的随机数组，每个元素的随机范围为
	[rangeL, rangeR]

	n: 生成的随机数的个数
	rangeL: 随机数的最小值
	rangeR: 随机数的最大值

	*/

	int* generateRandomArray(int n, int rangeL, int rangeR) {
		assert(rangeL <= rangeR);

		int *arr = new int[n];
		srand(time(NULL));
		for (int i = 0; i < n; i++) {
			arr[i] = rand() % (rangeR - rangeL) + rangeL;
		}
		return arr;
	}

	/*
	顺序打印数组

	arr[]: 接收一个数组
	n: 需要打印出几个数组元素
	*/

	template<typename T>
	void printArray(T arr[], int n) {
		for (int i = 0; i < n; i++) {
			cout << arr[i] << " ";
		}
		cout << endl;

		return;
	}
}
```



`main.cpp`

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include "Student.h"
#include "SortTestHelper.h"

using namespace std;

template<typename T>
void selectionSort(T arr[], int n) {
	for (int i = 0; i < n; i++) {
		int minIndex = i;
		for (int j = i + 1; j < n; j++) {
			if (arr[j] < arr[minIndex]) {
				minIndex = j;
			}
		}
		swap(arr[i], arr[minIndex]);
	}
}

int main(int argc, char const *argv[])
{
	int n = 10000;
	int *arr = SortTestHelper::generateRandomArray(n, 0, n);
	selectionSort(arr, n);
	SortTestHelper::printArray(arr, n);

	delete[] arr; //因为arr开的是数组空间，所以用delete[]
	return 0;
}
```

### 47、函数模板

函数模板可以用来**创建一个**（也就是一个模板只能针对一个函数）通用的函数，以支持多种不同的形参，**避免重载函数的函数体重复设计**。它的最大特点是把函数使用的数据类型作为参数

```c++
template<typename 数据类型参数标识符>

<返回类型><函数名>(参数表)
{
    函数体
}
```

### 48、数组索引越界

只要涉及到了索引，就要考虑越界的问题，所有要通过语句来限制

















































































































































































































































































































































































































































































































































































































