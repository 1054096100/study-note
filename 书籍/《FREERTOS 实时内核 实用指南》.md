# FREERTOS 实时内核 实用指南 

## 第一章：任务管理

桌面电脑的输入处理可以归类为”软实时”。为了保证用户的佳体验，计算机对每
个输入的响应应当限定在一个恰当的时间范围——但是如果响应时间超出了限定范围，
并不会让人觉得这台电脑无法使用。

硬实时功能必须在给定的时间限制之内完成——如果无法做到即意味着整个系统
的绝对失败。

在 FreeRTOS 中，每个执行线程都被称为”任务”。

### 1.2 任务函数 

FreeRTOS 任务不允许以任何方式从实现函数中返回——它们绝不能有一条”return”语句，也不能执行到函数末尾。如果一个任务不再需要，可以显式地将其删除。

一个任务函数可以用来创建若干个任务——创建出的任务均是独立的执行实例，拥有属于自己的栈空间，以及属于自己的自动变量(栈变量)，即任务函数本身定义的变量。

### 1.3、扩充“非运行态”

到目前为止所有用到的示例中，创建的每个任务都只顾不停地处理自己的事情而没
有其它任何事情需要等待——由于它们不需要等待所以总是能够进入运行态。这种”不
停处理”类型的任务限制了其有用性，因为它们只可能被创建在最低优先级上。如何它
们运行在其它任何优先级上，那么比它们优先级更低的任务将永远没有执行的机会。
为了使我们的任务切实有用，我们需要通过某种方式来进行事件驱动。一个事件驱
动任务只会在事件发生后触发工作(处理)，而在事件没有发生时是不能进入运行态的。
调度器总是选择所有能够进入运行态的任务中具有最高优先级的任务。一个高优先级但
不能够运行的任务意味着不会被调度器选中，而代之以另一个优先级虽然更低但能够运
行的任务。因此，**采用事件驱动任务的意义就在于任务可以被创建在许多不同的优先级**
**上，并且最高优先级任务不会把所有的低优先级任务饿死**。

#### 阻塞状态

如果一个任务正在**等待某个事件，则称这个任务处于”阻塞态**(blocked)”。**阻塞态是**
**非运行态的一个子状态**。
任务可以进入阻塞态以等待以下两种不同类型的事件：

1. **定时(时间相关)事件**——这类事件可以是延迟到期或是绝对时间到点。比如
  说某个任务可以进入阻塞态以延迟10ms。
2. **同步事件——源于其它任务或中断的事件**。比如说，某个任务可以进入阻塞
  态以等待队列中有数据到来。同步事件囊括了所有板级范围内的事件类型。

FreeRTOS 的队列，二值信号量，计数信号量，互斥信号量(recursive semaphore,
递归信号量，本文一律称为互斥信号量，因为其主要用于实现互斥访问)和互斥量都可
以**用来实现同步事件**。

任务可以在进入阻塞态以**等待同步事件时指定一个等待超时时间**，这样可以有效地实现阻塞状态下同时等待两种类型的事件（定时事件和同步事件）。比如说，某个任务可以等待队列中有数据到来，但最多只等10ms。如果10ms 内有数据到来（同步事件），或是10ms 过去了还没有数据到来（定时器时事件），这两种情况下该任务都将退出阻塞态。

#### 挂起状态

“挂起(suspended)”也是非运行状态的子状态。处于挂起状态的任务对调度器而言是不可见的。让一个任务进入挂起状态的唯一办法就是调用vTaskSuspend() API 函数；而把一个挂起状态的任务唤醒的唯一途径就是调用vTaskResume() 或vTaskResumeFromISR() API 函数。大多数应用程序中都不会用到挂起状态。

#### 就绪状态

如果任务处于非运行状态，但既没有阻塞也没有挂起，则这个任务处于就绪(ready，
准备或就绪)状态。处于就绪态的任务能够被运行，但只是”准备(ready)”运行，而当前
尚未运行。

**空闲任务是在调度器启动时自动创建的，以保证至少有一个任务可运行(至少有一**
**个任务处于就绪态)**

不使用阻塞的话，采用软延时（循环计数）的方式：

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/1.PNG)

这种方法的缺点是一个任务一直保持在运行态中执行空循环，可能将其它任务饿死。

采用阻塞的方法：

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/2.PNG)

图 4 展现的是当任务采用空循环进行延迟时的执行流程——结果就是任务总是可运行并占用了大量的机器周期。从图9 中的执行流程中可以看到，任务在整个延迟周期内都处于阻塞态，只在完成实际工作的时候才占用处理器时间(本例中任务的实际工作只是简单地打印输出一条信息)。

在图9 所示的情形中，任务离开阻塞态后，仅仅执行了一个心跳周期的一个片段，然后又再次进入阻塞态。所以大多数时间都没有一个应用任务可运行(即没有应用任务处于就绪态)，因此没有应用任务可以被选择进入运行态。这种情况下，空闲任务得以执行。**空间任务可以获得的执行时间量，是系统处理能力裕量的一个度量指标**。

### 1.7、空闲任务

处理器总是需要代码来执行——所以至少要有一个任务处于运行态。为了保证这一点，**当调用vTaskStartScheduler()时，调度器会自动创建一个空闲任务**。**空闲任务是一个非常短小的循环**。

**空闲任务拥有最低优先级(优先级0)以保证其不会妨碍具有更高优先级的应用任务进入运行态**——当然，没有任何限制说是不能把应用任务创建在与空闲任务相同的优先级上；如果需要的话，你一样可以和空闲任务一起共享优先级。

运行在最低优先级可以保证一旦有更高优先级的任务进入就绪态，调度器在下次调度任务的时候，空闲任务就会被切出运行态，进入就绪态。而优先级更高的任务就会被投入运行。

#### 空闲任务钩子函数

通过**空闲任务钩子函数(或称回调**，hook, or call-back)，可以直接在空闲任务中添加应用程序相关的功能。**空闲任务钩子函数会被空闲任务每循环一次就自动调用一次**。

通常空闲任务钩子函数被用于：

- 执行低优先级，后台或需要不停处理的功能代码。
- 测试处系统处理裕量(空闲任务只会在所有其它任务都不运行时才有机会执行，所
  以测量出空闲任务占用的处理时间就可以清楚的知道系统有多少富余的处理时间)。
- **将处理器配置到低功耗模式**——提供一种自动省电方法，使得在没有任何应用功能
  需要处理的时候，系统自动进入省电模式。

#### 空闲任务钩子函数的实现限制

空闲任务钩子函数必须遵从以下规则：

1. **绝不能阻塞或挂起**。空闲任务只会在其它任务都不运行时才会被执行(除非有应用任务共享空闲任务优先级)。**以任何方式阻塞空闲任务都可能导致没有任务能够进入运行态**！
2. 如果应用程序用到了 vTaskDelete() AP 函数，则空闲钩子函数必须能够尽快返回。**因为在任务被删除后，空闲任务负责回收内核资源**。**如果空闲任务一直运行在钩子函数中，则无法进行回收工作**。

空闲任务钩子函数必须如下函数名和函数原型：

```c
void vApplicationIdleHook( void );
```

也就是说，空闲任务必须命名为`vApplicationIdleHook`。

FreeRTOSConfig.h 中的配置常量`configUSE_IDLE_HOOK`必须定义为1，这样空闲任务钩子函数才会被调用。

### 1.10、调度算法

#### 优先级抢占式调度

- 每个任务都赋予了一个优先级。
- 每个任务都可以存在于一个或多个状态。
- 在任何时候都只有一个任务可以处于运行状态。
- 调度器总是在所有处于就绪态的任务中选择具有最高优先级的任务来执行。

这种类型的调度方案被称为”固定优先级抢占式调度”。所谓”固定优先级”是指每个任务都被赋予了一个优先级，这个优先级不能被内核本身改变(只能被任务修改)。**”抢占式”是指当任务进入就绪态或是优先级被改变时，如果处于运行态的任务优先级更低，则该任务总是抢占当前运行的任务**。

抢占式调度调度的行为方式如下图：

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/3.PNG)

1. 空闲任务
  空闲任务具有最低优先级，所以每当有更高优先级任务处于就绪态是，空闲任务就会被抢占—— 如图中 t3, t5 和t9 时刻。
2. 任务 3
  任务3 是一个事件驱动任务。其工作在一个相对较低的优先级，但优先级高于空闲任务。其大部分时间都在阻塞态等待其关心的事件。每当事件发生时其就从阻塞态转移到就绪态。**FreeRTOS 中所有的任务间通信机制(队列，信号量等)都可以通过这种方式用于发送事件以及让任务解除阻塞**。
  事件在 t3，t5 、t9、t12的某个时刻发生。发生在t3和t5时刻的事件可以立即被理，因为这些时刻任务3在所有可运行任务中优先级最高。发生在t9 至t12 之间某个时刻的事件不会得到立即处理，需要一直等到t12 时刻。因为具有更高优先级的任务1 和任务2 尚在运行中，只有到了t12 时刻，这两个任务进入阻塞态，使得任务3 成为具有最高优先级的就绪态任务。
3. 任务 2
  任务2 是一个周期性任务，其优先级高于任务3 并低于任务1。根据周期间隔，任务2 期望在t1，t6 和t9 时刻执行。
  在 t6 时刻任务3处于运行态，但是任务2 相对具有更高的优先级，所以会抢占
  任务3，并立即得到执行。任务2 完成处理后，在t7 时刻返回阻塞态。同时，
  任务3 得以重新进入运行态，继续完成处理。任务3 在t8 时刻进入阻塞状态。
4. 任务 1
  任务1 也是一个事件驱动任务。任务1 在所有任务中具有最高优先级，因此可
  以抢占系统中的任何其它任务。在图中看到，任务1 的事件只是发生在在t10
  时刻，此时任务1 抢占了任务2。只有当任务1 在t11 时刻再次进入阻塞态之
  后，任务2 才得以机会继续完成处理。

#### 选择任务优先级

作为一种通用规则，**完成硬实时功能的任务优先级会高于完成软实时功能任务的优先级**。但其它一些因素，比如执行时间和处理器利用率，都必须纳入考虑范围，以保证应用程序不会超过硬实时的需求限制。

单调速率调度(Rate Monotonic Scheduling, RMS)是一种常用的优先级分配技术。其根据任务周期性执行的速率来分配一个唯一的优先级。**具有最高周期执行频率的任务赋予高最优先级；具有最低周期执行频率的任务赋予最低优先级**。这种优先级分配方式被证明了可以最大化整个应用程序的可调度性(schedulability)，但是运行时间不定以及并非所有任务都具有周期性，会使得对这种方式的全面计算变得相当复杂。

#### 协作式调度

本书专注于抢占式调度。FreeRTOS 可以选择采用协作式调度。
**采用一个纯粹的协作式调度器，只可能在运行态任务进入阻塞态或是运行态任务显**
**式调用taskYIELD()时，才会进行上下文切换。任务永远不会被抢占，而具有相同优先**
**级的任务也不会自动共享处理器时间。**协作式调度的这作工作方式虽然比较简单，但可
能会导致系统响应不够快。

（类似于协程）

## 第二章：队列管理

### 2.2、队列的特性

#### 数据存储

#### 可被多任务存取

队列是具有自己独立权限的内核对象，并不属于或赋予任何任务。所有任务都可以
向同一队列写入和读出。一个队列由多方写入是经常的事，但由多方读出倒是很少遇到。

#### 读队列时阻塞

当某个任务试图读一个队列时，其可以指定一个阻塞超时时间。在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当其它任务或中断服务例程往其等待的队列中写入了数据，该任务将自动由阻塞态转移为就绪态。当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转移为就绪态。由于队列可以被多个任务读取，所以对单个队列而言，也可能有多个任务处于阻塞状态以等待队列数据有效。这种情况下，一旦队列数据有效，只会有一个任务会被解除阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级相同，那么被解除阻塞的任务将是等待最久的任务。

#### 写队列时阻塞

同读队列一样，任务也可以在写队列时指定一个阻塞超时时间。这个时间是当被写
队列已满时，任务进入阻塞态以等待队列空间有效的最长时间。

由于队列可以被多个任务写入，所以对单个队列而言，也可能有多个任务处于阻塞状态以等待队列空间有效。这种情况下，一旦队列空间有效，只会有一个任务会被解除阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级相同，那么被解除阻塞的任务将是等待最久的任务。

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/4.PNG)

### 2.3、使用队列

队列在使用前必须先被创建。

当创建队列时，FreeRTOS **从堆空间中分配**内存空间。分配的空间用于**存储队列数据结构本身以及队列中包含的数据单元**。

#### xQueueSendToBack() 与 xQueueSendToFront() API 函数

如 果 把 xTicksToWait 设置为portMAX_DELAY ， 并且在FreeRTOSConig.h 中设定INCLUDE_vTaskSuspend 为1，那么阻塞等待将没有超时限制。

#### xQueueReceive()与xQueuePeek() API 函数

xQueueReceive()用于从队列中接收(读取）数据单元。接收到的单元同时会从队列
中删除。
xQueuePeek()也是从从队列中接收数据单元，不同的是并不从队列中删出接收到
的单元。

#### 使用队列传递复合数据类型

一个任务从单个队列中接收来自多个发送源的数据。

可以通过变量识别传输过来的是什么数据。。一个简单的方式就是利用队列传递结构体，结构体成员中就包含了数据信息和来源信息

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/5.PNG)

### 2.4、工作于大型数据单元

如果队列存储的数据单元尺寸较大，那最好是利用队列来传递数据的指针而不是对数据本身在队列上一字节一字节地拷贝进或拷贝出。

但是，当你利用队列传递指针时，一定要十分小心地做到以下两点：

1. **指针指向的内存空间的所有权必须明确**
  **当任务间通过指针共享内存时，应该从根本上保证不会有任意两个任务同时修改共享内存中的数据**，或是以其它行为方式使得共享内存数据无效或产生一致性问题。**原则上，共享内存在其指针发送到队列之前，其内容只允许被发送任务访问；共享内存指针从队列中被读出之后，其内容亦只允许被接收任务访问**。

2. 指针指向的内存空间必须有效
  如果指针指向的内存空间是动态分配的，只应该有一个任务负责对其进行内存释放。当这段内存空间被释放之后，就不应该有任何一个任务再访问这段空间。

  切忌用指针访问任务栈上分配的空间。因为当栈帧发生改变后，栈上的数据将不再有效。

## 第三章：中断管理

事件

嵌入式实时系统需要对整个系统环境产生的事件作出反应。举个例子，**以太网外围部件收到了一个数据包(事件)，需要送到TCP/IP 协议栈进行处理(反应)**。更复杂的系统需要处理来自各种源头产生的事件，这些事件对处理时间和响应时间都有不同的要求。在各种情况下，都需要作出合理的判断，以达到最佳事件处理的实现策略：

1. 事件如何被检测到？通常采用中断方式，但是事件输入也可以通过查询获得。
2. 什么时候采用中断方式？**中断服务例程(ISR)**中的处理量有多大？以及ISR 外的任务量有多大？**通常情况下，ISR 应当越短越好**。
3. 事件如何通知到主程序(这里指非ISR 程序，而非main()程序)代码？这些代码要如何架构才能最好地适应异步处理？

### 3.2、延迟中断处理

#### 采用二值信号量同步

**二值信号量可以在某个特殊的中断发生时，让任务解除阻塞，相当于让任务（指的是下半部）与中断同步**。这样就可以让中断事件处理量大的工作在同步任务中完成，中断服务例程(ISR)中只是快速处理少部分工作。如此，中断处理可以说是被”推迟(deferred)”到一个”处理(handler)”任务。（其实就是我们所说的上半部和下半部）

**如果某个中断处理要求特别紧急，其延迟处理任务的优先级可以设为最高，以保证延迟处理任务随时都抢占系统中的其它任务。这样，延迟处理任务就成为其对应的ISR退出后第一个执行的任务，在时间上紧接着ISR 执行，相当于所有的处理都在ISR 中完成一样**。（而且这样子还保证了ISR占用时间尽可能的短）

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/6.PNG)

延迟处理任务对一个信号量进行带阻塞性质的”take”调用，意思是进入阻塞态以等待事件发生。当事件发生后，ISR 对同一个信号量进行”give”操作（是ISR增加了信号量的值吗？是的！！！），使得延迟处理任务解除阻塞，从而事件在延迟处理任务中得到相应的处理。

在这种中断同步的情形下，信号量可以看作是一个深度为1 的队列。这个队列由于最多只能保存一个数据单元，所以其不为空则为满(所谓”二值”)。延迟处理任务调用
xSemaphoreTake()时，等效于带阻塞时间地读取队列，如果队列为空的话任务则进入阻塞态。当事件发生后，ISR 简单地通过调用xSemaphoreGiveFromISR()放置一个令牌(信号量)到队列中，使得队列成为满状态。这也使得延迟处理任务切出阻塞态，并移除令牌，使得队列再次成为空。当任务完成处理后，再次读取队列，发现队列为空，又进入阻塞态，等待下一次事件发生。

如图27 所示，中断给出信号量，甚至是在信号量第一次被获取之前就给出；而任务在获取信号量之后再也不给回来。这就是为什么说这种情况与读写队列相似。这也经常会给大家造成迷惑，因为这种情形和其它信号量的使用场合大不相同。在其它场合下，任务获得(Take)了信号量之后，必须得给(Give)回来。

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/7.PNG)

按照图27可以知道，任务不需要把信号量放回去，因为让信号量的值增加的这个操作是由ISR（中断服务例程）来完成的。

### 3.3、计数信号量

二值信号量用于任务和中断同步的流程：

1. 中断产生。
2. 中断服务例程启动，给出信号量以使延迟处理任务解除阻塞。
3. 当中断服务例程退出时，延迟处理任务得到执行。延迟处理任务做的第一件事便是获取信号量。
4. 延迟处理任务完成中断事件处理后，试图再次获取信号量——如果此时信号量无效，任务将切入阻塞待等待事件发生。

在中断以相对较慢的频率发生的情况下，上面描述的流程是足够而完美的。如果在延迟处理任务完成上一个中断事件的处理之前，新的中断事件又发生了，等效于将新的事件锁存在二值信号量中，使得延迟处理任务在处理完上一个事件之后，立即就可以处理新的事件。也就是说，延迟处理任务在两次事件处理之间，不会有进入阻塞态的机会，因为信号量中锁存有一个事件，所以当xSempaphoreTake()调用时，信号量立即有效。这种情形将在图30 中进行展现。

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/8.PNG)

在图30 中可以看到，一个二值信号量最多只可以锁存一个中断事件。在锁存的事件还未被处理之前，如果还有中断事件发生，那么后续发生的中断事件将会丢失。如果用计数信号量代替二值信号量，那么，这种丢中断的情形将可以避免。

就如同我们可以把二值信号量看作是只有一个数据单元的队列一样，计数信号量可以看作是深度大于1 的队列。任务其实对队列中存储的具体数据并不感兴趣——其只关心队列是空还是非空。

计数信号量每次被给出(Given)，其队列中的另一个空间将会被使用。队列中的有效数据单元个数就是信号量的”计数(Count)”值。

![](http://oklbfi1yj.bkt.clouddn.com/FREERTOS%20%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%20%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/9.PNG)

计数信号量有以下两种典型用法：

1．事件计数
在这种用法中，每次事件发生时，中断服务例程都会“给出(Give)”信号量——信号量在每次被给出时其计数值加1。延迟处理任务每处理一个任务都会”获取(Take)”一次信号量——信号量在每次被获取时其计数值减1。**信号量的计数值其实就是已发生事件的数目与已处理事件的数目之间的差值**。这种机制可以参考图31。用于事件计数的计数信号量，在被创建时其计数值被初始化为0。

2．资源管理
在这种用法中，信号量的计数值用于表示可用资源的数目。一个任务要获取资源的控制权，其必须先获得信号量——使信号量的计数值减1。当计数值减至0，则表示没有可用资源。当任务利用资源完成工作后，将给出(归还)信号量——使信号量的计数值加1。用于资源管理的信号量，在创建时其计数值被初始化为可用资源总数。第四章涵盖了使用信号量来管理资源。

### 3.4、在中断服务例程中使用队列

**信号量用于事件通信。而队列不仅可以用于事件通信，还可以用来传递数据。**

### 3.5、中断嵌套

最新的 FreeRTOS 移植中允许中断嵌套，但是需要先在FreeRTOSConfig.h中进行配置。

## 第四章：资源管理

多任务系统中存在一种潜在的风险。当一个任务在使用某个资源的过程中，即还没有完全结束对资源的访问时，便被切出运行态，使得资源处于非一致，不完整的状态。如果这个时候有另一个任务或者中断来访问这个资源，则会导致数据损坏或是其它相似的错误。

以下便是一些例子：

1. 访问外设
2. 读-改-写操作

3. 变量的非原子访问
  更新结构体的多个成员变量，或是更新的变量其长度超过了架构体系的自然长度
  (比如，更新一个16 位机上的32 位变量)均是非原子操作的例子。如果这样的操作被中
  断，将可能导致数据损坏或丢失。

4. 函数重入
  **如果一个函数可以安全地被多个任务调用，或是在任务与中断中均可调用，则这个函数是可重入的**。
  每个任务都单独维护自己的栈空间及其自身在的内存寄存器组中的值。**如果一个函数除了访问自己栈空间上分配的数据或是内核寄存器中的数据外，不会访问其它任何数据，则这个函数就是可重入的**。

### 4.2 临界区与挂起调度器

#### 基本临界区

基本临界区是指宏 taskENTER_CRITICAL()与taskEXIT_CRITICAL()之间的代码区间。

临界区是提供互斥功能的一种非常原始的实现方法。**临界区的工作仅仅是简单地把中断全部关掉**，或是**关掉优先级在configMAX_SYSCAL_INTERRUPT_PRIORITY 及以下的中断**。

**临界区必须只具有很短的时间，否则会反过来影响中断响应时间**。在每次调用taskENTER_CRITICAL()之后，必须尽快地配套调用一个taskEXIT_CRITICAL()。从这个角度来看，对标准输出的保护不应当采用临界区(如程序清单61 所示)，因为写终端在时间上会是一个相对较长的操作。

临界区嵌套是安全的，因为内核有维护一个嵌套深度计数。临界区只会在嵌套深度为0 时才会真正退出。

#### 挂起(锁定)调度器

也可以通过挂起调度器来创建临界区。挂起调度器有些时候也被称为锁定调度器。**基本临界区保护一段代码区间不被其它任务或中断打断。由挂起调度器实现的临界区只可以保护一段代码区间不被其它任务打断，因为这种方式下，中断是使能的**。

如果一个临界区太长而不适合简单地关中断来实现，可以考虑采用挂起调度器的方式。但是唤醒(resuming, or un-suspending)调度器却是一个相对较长的操作。

在调度器处于挂起状态时，不能调用 FreeRTOS API 函数。

### 4.3 互斥量(及二值信号量)

互斥量是一种特殊的二值信号量，用于控制在两个或多个任务间访问共享资源。

在用于互斥的场合，互斥量从概念上可看作是与共享资源关联的令牌。一个任务想要合法地访问资源，其必须先成功地得到(Take)该资源对应的令牌(成为令牌持有者)。当令牌持有者完成资源使用，其必须马上**归还**(Give)令牌。只有归还了令牌，其它任务才可能成功持有，也才可能安全地访问该共享资源。一个任务除非持有了令牌，否则不允许访问共享资源。

虽然互斥量与二值信号量之间具有很多相同的特性，但图36 展示的情形(互斥量用于互斥功能)完全不同于图30 展示的情形(二值信号量用于同步)。两者间最大的区别在于信号量在被获得之后所发生的事情：

- **获得用于互斥的信号量的任务必须归还这个信号量**。
- **获得用于同步的信号量通常是完成同步之后便丢弃，不再归还**（而增加信号量值的这个操作可以由ISR，也就是中断服务例程来完成）。











































































































































































































































































































