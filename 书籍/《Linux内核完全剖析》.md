# Linux内核完全剖析

## 第二章：微型计算机组成结构

操作系统与所运行的硬件环境密切相关。如果想彻底理解操作系统运行全过程，那么就需要了解它的运行硬件环境。

### 2.2、IO端口寻址和访问控制方式

#### 2.2.1、I/O端口和寻址

CPU为了访问I/O接口控制器或控制卡.上的数据和状态信息，需要首先指定它们的地址。这种地址就称为I/O端口地址或者简称端口。通常，一个I/O控制器包含访问数据的**数据端口**、输出命令的**命令端口**和访问控制器执行状态的**状态端口**。端口地址的设置方法-一般有两种:统一编址和独立编址。

### 2.3、主存储器、BIOS和CMOS存储器

1981年IBM PC刚推出时系统只带有640KB的RAM主存储器(简称内存)。由于所采用的8088/8086CPU只有20根地址线，因此内存寻址范围最高1024KB (1MB)。

目前的计算机通常都配置有512MB或者更多的物理内存容量，并且都采用Intel 32位CPU,即都是PC/AT计算机。因此CPU的物理内存寻址范围已经高达4GB (通过采用CPU的新特性，系统甚至可以寻址64GB的物理内存容量)。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/1.png)

但是**为了与原来的PC在软件上兼容，系统1MB以下物理内存使用分配上仍然保持与原来的PC基本一致**，只是原来系统ROM中的基本输入输出程序BIOS一直处于CPU能寻址的内存最高端位置处。

当计算机上:电初始化时，物理内存被设置成从地址0开始的连续区域。除了地址从0xA0000~0xFFFFF (640KB~1MB，共384KB）和0XFFFE0000～0XFFFFFFFF（4GB处的最后64KB）范围以外的所有内存都可用做系统内存。这两个特定范围被用于I/O设备和BIOS程序。假如我们的计算机中有16MB的物理内存，那么在Linux0.1x系统中，0~640KB将被用做存放内核代码和数据。**Linux内核不使用BIOS功能，也不使用BIOS设置的中断向量表**。640KB~1MB之间的384KB仍然保留用作图中指明的用途。**1MB~16MB将被内核用做可分配的主内存区**。另外高速缓冲区和内存虚拟盘也会占用内核代码和数据后面的一部分内存区域。该区域通常会跨越640KB~1MB的区域。

#### 2.3.2、基本输入/输出程序BIOS

存放在ROM中的系统BIOS程序**主要用于计算机开机时执行系统各部分的自检,建立起操作系统需要使用的各种配置表，如中断向量表、硬盘参数表**。并且把处理器和系统其余部分初始化到一个已知状态，而且还为DOS等操作系统提供硬件设备接口服务。但是**由于BIOS提供的这些服务不具备可重入性(即其中程序不可并发运行)**，并且从访问效率方面考虑，因此**除了在初始化时会利用BIOS提供一些系统参数以外，Linux操作系统在运行时并不使用BIOS中的功能**。

**当计算机系统上电开机或者按了机箱上的复位按钮时**，CPU会自动把代码段寄存器CS设置为0xF000，其段基地址则被设置为0xFFFF0000， 段长度设置为64KB。而IP被设置为0xFFF0,因此此时CPU代码指针指向0xFFFFFFF0处，即4GB空间的最后64KB的最后16B处。由图2-4可知，**这里正是系统ROM BIOS 存放的位置**，并且BIOS会在这里存放一条跳转指令JMP，跳转到BIOS代码中64KB范围内的某一-条指令开始执行。由于目前PC/AT中BIOS容量人多有1MB~2MB,并存储在闪存(Flash Memory) ROM中，因此为了能够执行或访问BIOS中超过64KB范围而又远远不在0~1MB地址空间中的其他BIOS代码或数据，BIOS程序会首先使用32位访问方式把数据段寄存器的访问范围设置成4GB (而非原来的64KB)，这样CPU就可以在0~4GB范围内执行和操作数据。此后，BIOS在执行了一些列硬件检测和初始化操作之后，就会把与原来PC兼容的64KB BIOS代码和数据复制到内存低端1MB末端的64KB处，然后跳转到这个地方并让CPU真正运行在实地址模式下，如图2-5所示。最后BIOS就会从硬盘或其他块设备把操作系统引导程序加载到内存0x7c00处，并跳转到这个地方继续执行引导程序。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/2.png)

#### 2.3.3、CMOS存储器

在PC/AT中，除需要使用内存和ROM BIOS以外，还使用只有很少存储容量的(只有64B或128B) CMOS 存储器来存放计算机的实时时钟信息和系统硬件配置信息。**这部分内存通常和实时时钟芯片(RealTime Chip)做在一块集成电路中。CMOS内存的地址空间在基本内存地址空间之外，需要使用I/O指令来访问**。

### 2.4、控制器和控制卡

#### 2.4.1、中断控制器

IBM PC/AT 80x86 兼容机使用两片级联的8259A可编程中断控制芯片组成一个中断控制器，用于实现I/O设备的中断控制数据存取方式,并且能为15个设备提供独立的中断控制功能。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/3.png)

#### 2.4.2、DMA控制器

如前所述，DMA控制器的主要功能是通过**让外部设备直接与内存传输数据**来增强系统的性能。通常它由机器上的Intel 8237芯片或其兼容芯片实现。**通过对DMA控制器进行编程，外设与内存之间的数据传输能在不受CPU控制的条件下进行**。因此在数据传输期间，**CPU可以做其他事情**。

#### 2.4.3、定时/计数器

Intel 8253/8254是一个可编程定时/计数器(Programmable Interval Timer, PIT)芯片，用于处理计算机中的精确时间延迟。该芯片提供了3个独立的16位计数器通道。每个通道可工作在不同的工作方式下，并且这些工作方式均叮以使用软件来设置。**在软件中进行延时的一种方法是执行循环操作语句，但这样做很耗CPU时间。若机器中采用了8253/8254 芯片，那么程序员就可以配置8253以满足自己的要求并且使用其中一个计数器通道达到所期望的延时。在延时到后，8253/8254将会向CPU发送一个中断信号**。

对于PC/AT及其兼容机系统采用的是8254芯片。3个定时/计数器通道被分别用于**时钟计时中断信号**、动态内存DRAM刷新定时电路和主机扬声器音调合成。**Linux0.12 操作系统只对通道0进行了重新设置**，使得该计数器工作在方式3下，并且**每间隔10ms发出一个信号以产生中断请求信号(IRQ0)**。这个间隔定时产生的中断请求就是Linux 0.12内核工作的脉搏，它**用于定时切换当前执行的任务和统计每个任务使用的系统资源量(时间)**。

#### 2.4.5、串行控制卡

##### 1.异步串行通信原理

两台计算机/设备进行数据交换，即通信，必须像人们对话一样使用同一种语言。在计算机通信术语中，我们把计算机/设备与计算机/设备之间的“语言”称为通信协议。通信协议规定了传送一个有效数据长度单位的格式。通常使用术语“帧”来描述这种格式。为了能让通信双方确定收/发的顺序和进行一些错误检测操作，除了必要的数据以外，在传输的1帧信息中还包含起始同步和错误检测作用的其他信息。
例如，在开始传输数据信息之前先发送起始同步或通信控制信息，并且在发送完需要的数据信息之后再传输一一些校验信息等，如图2-8所示。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/4.png)

## 第三章：内核编程语言和环境

### 3.1、as86汇编器

#### 3.1.1、as86汇编器语言语法

汇编器编译产生的目标文件objfile通常至少包含3个段或区(section),即**正文段(.text)、数据段(.data) 和未初始化数据段(.bss)**。 正文段(或称为代码段)是一个已初始化过的段，通常其中包含程序的执行代码和只读数据。数据段也是一个已初始化过的段，其中包含可读/写的数据。而**未初始化数据段是一个未初始化的段**。**通常汇编器产生的输出目标文件中不会为该段保留空间，但在目标文件链接成执行程序被加载时操作系统会把该段的内容全部初始化为0**。

### 3.2、GNU as汇编

由于操作系统许多关键代码要求有很高的执行速度和效率，因此在一个操作系统源代码中通常就会包含大约10%的起关键作用的汇编语言代码。**Linux操作系统也不例外，它的32位初始化代码、所有中断和异常处理过程接口程序以及很多宏定义都使用了as汇编语言程序或扩展的嵌入汇编语句**。

#### 3.2.4、区与重定位

区(Section) (也称为段、节或部分)用于表示一个地址范围，操作系统将会以相同的方式对待和处理在该地址范围中的数据信息。例如，可以有一个“只读”的区，只能从该区中读取数据而不能写入。区的概念主要用来表示编译器生成的目标文件(或可执行程序)中不同的信息区域，例如目标文件中的正文区或数据区。

链接器ld会把输入的目标文件中的内容按照一定规律组合生成一个可执行程序。**当as汇编器输出一个目标文件时，该目标文件中的代码被默认设置成从地址0开始。此后ld将会在链接过程中为不同目标文件中的各个部分分配不同的最终地址位置。ld 会把程序中的字节块移动到程序运行时的地址处**。这些块是作为固定单元进行移动的。它们的长度以及字节次序都不会被改变。这样的固定单元就被称做区(或段、部分)。而**为区分配运行时刻的地址的操作就被称为重定位(Relocation)操作，其中包括调整目标文件中记录的地址，从而让它们对应到恰当的运行时刻地址上**。

另外，还有一种名为“未定义的”区(Undefined Section)。在汇编时不能确定所在区的任何地址都被设置成{undefinedU},其中U将会在以后填上。因为数值总是有定义的，所以出现未定义地址的唯一途径仅涉及未定义的符号。对一个称为公共块(Common Block)的引用就是这样一种符号:在汇编时它的值未知，因此它在undefined区中。

**链接器ld会把程序所有目标文件中的text区放在相邻的地址处。我们习惯上所说的程序的text区实际上是指其所有目标文件text区组合构成的整个地址区域**。对程序中data和bss区的理解也同样如此。

##### 1.链接器涉及的区

链接器ld只涉及如下4类区：

- text区、data区。这两个区用于保存程序。as和ld会分别独立而同等地对待它们。对其中text区的描述也同样适合于data区。然而**当程序在运行时，通常text 区是不会改变的。text区通常会被进程共享，其中含有指令代码和常数等内容**。**程序运行时data区的内容通常是会变化的，例如，C变量一般就存放在data区中**。
- bss区。**在程序开始运行时这个区中含有0值字节**。该区用于存放未初始化的变量或作为公共变量存储空间。虽然程序每个目标文件bss区的长度信息很重要，但是由于该区中存放的是0值字节，因此**无须在目标文件中保存bss区**。**设置bss区的目的就是为了从目标文件中明确地排除0值字节**。
- absolute区。该区的地址0总是“重定位”到运行时刻地址0处。如果你不想让ld在重定位操作时改变你所引用的地址，那么就使用这个区。从这种观点来看，我们可以把绝对地址称做“不可重定位的”，即在重定位操作期间它们不会改变。
- undefined区。对不在先前所述各个区中对象的地址引用都属于本区。

图3-2中是3个理想化的可重定位区的例子：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/5.png)

这个例子使用传统的区名称:.text和.data。其中水平轴表示内存地址。

##### 3.bss区

bss区用于**存储局部公共变量**。**你可以在bss区中分配空间，但是在程序运行之前不能在其中放置数据。因为当程序刚开始执行时，bss 区中所有字节内容都将被清零。**

#### 3.2.5、符号

在程序编译和链接过程中，符号(Symbol) 是一个比较重要的概念。程序员使用符号来命名对象，**链接器使用符号进行链接操作**，而调试器利用符号进行调试。

### 3.3、C语言程序

#### 3.3.1、C程序编译和链接

使用gcc汇编器编译C语言程序时通常会经过4个处理阶段，即预处理阶段、编译阶段、汇编阶段和链接阶段：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/6.png)

在预处理阶段中，gcc 会把C程序传递给C前处理器cpp,对C语言程序中指示符和宏进行替换处理，输出纯C语言代码;在编译阶段，gcc把C语言程序编译生成对应的与机器相关的as汇编语言代码;在汇编阶段，as汇编器会把汇编代码转换成机器指令，并以特定二进制格式输出保存在目标文件中;最后GNU ld 链接器把程序的相关目标文件组合链接在一起，生成程序的可执行映像文件。调用gcc的命令行格式与编译汇编语言的格式类似:

```shell
gcc [选项] [-o outfile] infile ...
```

对于某次编译过程，并非一定要全部执行这4个阶段，使用命令行选项可以令gcc编译过程在某个处理阶段后就停止执行。例如，使用“-S”选项可以让gcc在输出了C程序对应的汇编语言程序之后就停止运行;
使用“-c”选项可以让gcc只生成目标文件而不执行链接处理：

```shell
gcc -o hello hello.c    // 编译hello.c程序，生成可执行文件hello
gcc -S -o hello.s hello.c    // 编译hello.c程序，生成对应汇编程序hello.s
gcc -c -o hello.o hello.c    // 编译hello.c程序，生成对应目标文件hello.o而不链接 
```

#### 3.3.2、嵌入汇编

在C语言中写汇编代码：

```c
asm("汇编语句"
    : 输出寄存器
    : 输入寄存器
    : 会被修改的寄存器
);
```

除第1行以外，后面带冒号的行若不使用就都可以省略。

#### 3.3.5、内联函数

内联函数嵌入调用者代码中的操作是**一种优化操作**，因此只有进行优化编译时才会执行代码嵌入处理。**若编译过程中没有使用优化选项“-O”，那么内联函数的代码就不会被真正地嵌入到调用者代码中，而是只作为普通函数调用来处理**。

函数中的某些语句用法可能会使得内联函数的**替换操作无法正常进行**，或者不适合进行替换操作。例如**使用了可变参数**、内存分配函数malloca()、叮变长度数据类型变量、非局部goto语句以及**递归函数**。编译时可以**使用选项-Winline让gcc对标志成inline 但不能被替换的函数给出警告信息以及不能替换的原因**。

### 3.4、C与汇编程序的互相调用

#### 3.4.1、C函数调用机制

在Linux内核程序boot/head.s执行完基本初始化操作之后，就会跳转去执行init/main.c 程序（即init进程的main函数）。那么head.s程序是如何把执行控制转交给init/main.c 程序的呢?即汇编程序是如何调用执行C语言程序的?这里我们首先描述一下C函数的调用机制、控制权传递方式，然后说明head.s程序跳转到C程序的方法。

##### 1.栈帧结构和控制权转移方式

大多数CPU .上的程序实现使用栈来支持函数调用操作。栈被用来传递函数参数、存储返回信息、临时保存寄存器原有值以备恢复以及用来存储局部数据。单个函数调用操作所使用的栈部分被称为栈帧(stack frame) 结构，其一般结构如图3-4所示：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/7.png)

**对于函数A调用函数B的情况，传递给B的参数包含在A的栈帧中**。当A调用B时，函数A的返回地址(调用返回后继续执行的指令地址)被压入栈中，**栈中该位置也明确指明了A栈帧的结束处**（也就是说，先压入参数，后压入返回地址）。而B的栈帧则从随后的栈部分开始，即图中保存帧指针(ebp) 的地方开始。再随后则用于存放任何保存的寄存器值以及函数的临时值。

B函数同样也使用栈来保存不能放在寄存器中的局部变量值。例如由于通常CPU的寄存器数量有限而不能够存放函数的所有局部数据，或者有些局部变量是数组或结构，因此必须使用数组或结构引用来访问。另外，C语言的地址操作符“&”被应用到一个局部变量上时，我们就需要为该变量生成一个地址，即为变量的地址指针分配一空间。最后，B函数会使用栈来保存调用任何其他函数的参数。

栈是往低(小)地址方向扩展的，而esp指向当前栈顶处的元素。通过使用push和pop指令我们可以把数据压入栈中或从栈中弹出。对于没有指定初始值的数据所需要的存储空间，我们可以通过把栈指针递减适当的值来做到。类似地，通过增加栈指针值我们可以回收栈中已分配的空间。

##### 2.函数调用举例

```c
void swap() {
	int c;
	c = *a;
	*a = *b;
	*b = c;
}

int main(int argc, char const *argv[]) {
	int a, b;

	a = 16;
	b = 32;
    swap(&a, &b);

	return a - b;
}
```

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/8.png)

可以看出，函数swap()从调用者main()的栈帧中获取其参数。（注意一个问题，程序是按照逆向顺序把函数参数压入栈中，即函数最后(最右边的)一个参数先入栈，而最左边的第1个参数在最后调用指令之前入栈）

##### 3.main()也是一个函数

另外，上面提到C程序的**主程序main()也是一个函数。这是因为在编译链接时它将会作为crt0.s 汇编程序的函数被调用**。crt0.s 是一个桩(stub) 程序，名称中的“crt”是“C run-time”的缩写。**该程序的目标文件将被链接在每个用户执行程序的开始部分**，主要用于**设置一些初始化全局变量等**。Linux0.12中crt0.s汇编程序如下所示。其中已建立并初始化全局变量environ 供程序中的其他模块使用。

```assembly
.text
.globl _environ					# 声明全局変量environ (对应C程序中的environ变量)。

__entry:						# 代码入口标号
		movl 8(%esp), %eax		# 取程序的环境变量指针envp并保存在environ中。
		movl %eax, _environ		# envp是execve()函数在加载执行文件时设置的。
		call _main				# 调用我们的主程序。其返回状态值在eax寄存器中。
		pushl %eax				# 压入返回值作为exit()函数的参数并调用该函数。
l:		call _exit
		jmp lb					# 控制应该不会到达这里。若到达这里则继续执行exit()。
.data
_environ:						# 定义变量_environ,为其分配一个长字空间，
		.long 0
```

通常使用gcc编译链接生成执行文件时，gcc会自动把该文件的代码作为第一个模块链接在可执行程序中。在编译时使用显示详细信息选项“-v”就可以明显地看出这个链接操作过程:

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/9.png)

为了使用ELF格式的日标文件以及建立共享库模块文件，现在的gcc编译器(2.x)已经把这个crt0扩展成几个模块: crtl.o、 crti.o、 crtbegin.o、 crtend.o 和crtn.o。**crti.o用于在.init区中执行初始化函数init()。.init 区中包含进程的初始化代码，即当程序开始执行时，系统会在调用main()之前先执行.init中的代码。crtn.o则用于在.fini区中执行进程终止退出处理函数fini()函数，即当程序正常退出时(main()返回之后)，系统会安排执行.fini中的代码**。

### 3.5、Linux0.12目标文件格式

为了生成内核代码文件，Linux0.12 使用了两种编译器。第一种是汇编编译器as86和相应的链接程序(或称为链接器) ld86。它们专门用于编译和链接**运行在实地址模式下的16位内核引导扇区程序bootsect.S 和设置程序setup.s**。第二种是GNU的汇编器as (gas) 和C语言编译器gcc以及相应的链接程序gld。编译器用于为源程序文件产生对应的.进制代码和数据目标文件。链接程序用于对相关的所有目标文件进行组合处理，形成一个可被内核加载执行的目标文件，即可执行文件。

本节首先简单说明编译器产生的目标文件结构，然后描述链接器如何把需要链接在一起的目标文件模块组合在一起，以生成二进制可执行映像文件或一个大的模块文件。最后说明Linux0.12内核**二进制代码文件Image**的生成原理和过程。这里给出了Linux 0.12内核支持的a.out。

#### 3.5.1、目标文件格式

在Linux 0.12 系统中，GNU gcc或gas编译输出的目标模块文件和链接程序所生成的可执行文件都使用了UNIX传统的a.out格式。这是一种被称为汇编与链接输出(Assembly&linker editor output)的目标文件格式。**对于具有内存分页机制的系统来说，这是一种简单有效的目标文件格式**。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/10.png)

a.out格式7个区的基本定乂和用途是:

- 执行头部分(exec header)。 执行文件头部分。该部分中含有一些参数(exec 结构)，是**有关目标文件的整体结构信息**。例如**代码和数据区的长度、未初始化数据区的长度、对应源程序文件名以及目标文件创建时间等**。**内核使用这些参数把执行文件加载到内存中并执行，而链接程序(ld)使用这些参数将一些模块文件组合成一个可执行文件**。这是**目标文件唯一必要的组成部分**。
- 代码区(text segment)。 由编译器或汇编器生成的二进制指令代码和数据信息，含有程序执行时被加载到内存中的指令代码和相关数据。能**以只读形式加载**。
- 数据区(data segment)。由编译器或汇编器生成的二进制指令代码和数据信息，这部分**含有已经初始化过的数据**，总是被加载到可读写的内存中。
- 代码重定位部分(text relocation)。 这部分含有供链接程序使用的记录数据。**在组合目标模块文件时用于定位代码段中的指针或地址**。当链接程序需要改变目标代码的地址时就需要修正和维护这些地方。
- 数据重定位部分(data relocation)。 类似于代码重定位部分的作用，但是用于数据段中指针的重定位。
- 符号表部分(symbol table)。 这部分同样**含有供链接程序使用的记录数据**。这些记录数据**保存着模块文件中定义的全局符号以及需要从其他模块文件中输入的符号**，或者是由链接器定义的符号，**用于在模块文件之间对命名的变量和函数(符号)进行交叉引用**。
- 字符串表部分(string table)。该部分含有与符号名相对应的字符串，供调试程序调试目标代码，**与链接过程无关**。这些信息可包含源程序代码和行号、局部符号以及数据结构描述信息等。

对于一个指定的目标文件并非一定会包含所有以上信息。**由于Linux0.12系统使用了Intel CPU的内存管理功能，因此它会为每个执行程序单独分配一个64MB的地址空间(逻辑地址空间)使用。在这种情况下，因为链接器已经把执行文件处理成从一个固定地址开始运行，所以相关的可执行文件中就不再需要重定位信息**。

##### 1.执行头部分

目标文件的文件头中含有一个长度为32B的exec 数据结构，通常称为文件头结构或执行头结构。其定义如下所示：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/11.png)

a_bss字段指明**内核在加载目标文件时**数据段后面未初始化数据区域(bss段)的长度。**由于Linux在分配内存时会自动对内存清零，因此bss段不需要被包括在模块文件或执行文件中**（但是，当我们谈及C语言内存模型的时候，此时就会把bss段加上，因为可执行文件被加载进入了内存中）。为了形象地表示目标文件逻辑地具有一个bss段，在后面图示中将使用虚线框来表示目标文件中的bss段。

entry字段指定了程序代码开始执行的地址。对于可执行文件来说并不需要符号表和重定位信息，因此除非链接程序为了调试目的而包括了符号信息，执行文件中的这几个字段(a_ syms a_trsize、a_drsize)的值通常为0。

##### 2.重定位信息部分

Linux0.12系统的模块文件和执行文件都是a.out格式的目标文件，但是**只有编译器生成的模块文件中包含用于链接程序的重定位信息**。代码段和数据段的重定位信息均有重定位记录(项)构成，每个记录的长度为8B,其结构如下所示:

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/12.png)



重定位项的功能有两个。一是当代码段被重定位到一个不同的基地址处时，重定位项则用于指出需要修改的地方。二是在模块文件中存在对未定义符号引用时，当此未定义符号最终被定义时链接程序就可以使用相应重定位项对符号的值进行修正。

##### 3.符号表和字符串部分

符号表记录项的结构如下所示:

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/13.png)

由于GNU gcc编译器允许任意长度的标识符，因此标识符字符串都位于符号表后的字符串表中。

磁盘上a.out执行文件的各区在进程逻辑地址空间中的对应关系如图3-8所示：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/14.png)

(这里的映射指的是当可执行文件被加载到内存的时候，各个段在内存中所处的位置)

Linux 0.12系统中进程的逻辑空间大小是64MB。对于ZMAGIC类型的a.out执行文件，它的代码区的长度是内存页面的整数倍。由于**Linux 0.12内核使用需求页技术，即在一页代码实际要使用的时候才被加载到物理内存页面中**，而在进行加载操作的fs/execve()函数中仅仅为其设置了分页机制的页目录项和页表项，因此需求页技术可以加快程序的加载速度。

图中bss是进程的未初始化数据区，用于存放静态的未初始化数据。**在开始执行程序时bss的第一页内存会被设置为全0**。图中heap是堆空间区，用于分配进程在执行过程中动态申请的内存空间。

#### 3.5.3、链接程序输出

**链接程序对输入的一个或多个模块文件以及相关的库函数模块进行处理，最终生成相应的二进制执行文件或一个由所有模块组合而成的大模块文件**。在这个过程中，链接程序的首要任务是**给执行文件(或者输出的模块文件)进行存储空间分配操作**（疑问：这里的存储空间分配指的是什么意思？？）。一旦存储位置确定，链接程序就可以继续执行符号绑定操作和代码修正操作。因为**模块文件中定义的大多数符号与文件中的存储位置有关，所以在符号对应的位置确定之前符号是没有办法解析的**。

每个模块文件中包括几种类型的段，**链接程序的第二个任务就是把所有模块中相同类型的段组合连接在一起，在输出文件中为指定段类型形成单一一个段**。例如，链接程序需要把所有输入模块文件中的代码段合并成一个段放在输出的执行文件中。

对于a.out格式的模块文件来说，由于段类型是预先知道的，因此链接程序对a.out格式的模块文件进行存储分配比较容易。例如，对于具有两个输入模块文件和需要连接一个库函数模块的情况，其存储分配情况如图3-9所示。每个模块文件都有一个代码段(text)、数据段(data)和一个bss段，也许还会有一些看似外部(全局)符号的公共块。链接程序会收集每个模块文件包括任何库函数模块中的代码段、数据段和bss段的大小。在读入并处理了所有模块之后，**任何具有非零值的未解析的外部符号都将作为公共块来看待，并且把它们分配存储在bss段的末尾处**。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/15.png)

此后链接程序就可以为所有段分配地址。**对于Linux 0.12系统中使用的ZMAGIC类型的a.out格式，输出文件中的代码段被设置成从固定地址0开始**。数据段则从代码段后下一个页面边界开始。bss段则紧随数据段开始放置。在每个段内，链接程序会把输入模块文件中的同类型段顺序存放，并按字进行边界对齐。

当Linux 0.12内核加载一个可执行文件时，它会**根据文件头部结构中的信息**首先判断文件是不是一个合适的可执行文件，即其魔数类型是否为ZMAGIC,然后系统在用户态堆栈顶部为程序设置环境参数和命令行上输入的参数信息块并为其**构建一个任务数据结构**。接着再设置一些相关寄存器值后利用堆栈返回技术去执行程序。执行程序映像文件中的代码和数据将会在实际执行到或用到时利用需求加载技术(Load on demand)动态加载到内存中。

Linux0.12内核的编译是根据内核的配置文件Makefile使用make命令指挥编译器和链接程序操作而完成的。在编译过程中make还利用内核源代码tools/目录下的build.c程序编译生成了一个用于组合所有模块的临时工具程序build。**由于内核是由引导启动程序利用ROM BIOS中断调用加载到内存中的，因此编译产生的内核各模块中的执行头结构部分需要去掉**。**工具程序build的主要功能就是分别去掉bootsect、setup和system文件中的执行头结构，然后把它们顺序组合在一起产生一个名为Image的内核映像文件**。

#### 3.5.4、链接程序预定义变量

在链接过程中，链接器ld和ld86会使用变量记录执行程序中每个段的逻辑地址。因此在程序中可以通过访问这几个外部变量来获得程序中段的位置。链接器预定义的外部变量通常至少有`etext`、`_etext`、 `edata`、`_edata`、 `end` 和`_end`。

变量名`_etext` 和`etext`的地址是程序正文段结束后的第1个地址;`_edata` 和`edata`的地址是初始化数据区后面的第1个地址;`_end`和`end`的地址是未初始化数据区(bss) 后的第1个地址位置。

我们可以在C程序代码中打印出这些变量的值。

我们知道现在Linux系统中程序代码从其逻辑地址0x08048000处开始存放，因此`etext - 0x08048000`就可以得到这个程序的代码段长度字节数。

## 第四章：80x86保护模式及其编程

### 4.1、80x86系统寄存器和系统指令

为了协助处理器执行初始化和控制系统操作，80x86 提供了一个标志寄存器EFLAGS和几个系统寄存器，除了一些通用状态标志外，EFLAGS中还包含几个系统标志。**这些系统标志用于控制任务切换、中断处理、指令跟踪以及访问权限**。**系统寄存器用于内存管理和控制处理器操作，含有分段和分页处理机制系统表的基地址、控制处理器操作的位标志位**。

#### 4.1.1、标识寄存器

通常只允许操作系统代码有权修改标志寄存器EFLAGS中的系统标志和IOPL字段。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/16.png)

(1) TF:  位8是跟踪标志(Trap Flag)。当设置该位时可为调试操作启动单步执行方式;复位时则禁止单步执行。在单步执行方式下，**处理器会在每个指令执行之后产生一个调试异常,这样我们就可以观察执行程序在执行每条指令后的状态**。如果程序使用POPF、POPFD或IRET指令设置了TF标志，那么在随后指令之后处理器就会产生一个调试异常。

(2) IOPL:  位13、12是I/O特权级(I/O Privilege Level) 字段。**该字段指明当前运行程序或任务的I/O特权级IOPL**。**当前运行程序或任务的CPL（CPU的当前特权级）必须小于或等于这个IOPL才能访问I/O地址空间**。只有当CPL为特权级0时，程序才可以使用POPF或IRET指令修改这个字段。

(CPU的当前特权级（CPL）反映了进程是在用户态还是内核态，并由存放在cs寄存器中的段选择符的RPL字段指定。只要当前特权级被改变，一些段寄存器必须相应地更新(如ds和ss寄存器)。例如，当CPL=3时（用户态），ds寄存器必须含有用户数据段的段选择符，而当CPL=0时，ds寄存器必须含有内核数据段的段选择符。ss寄存器也一样，当CPL为3时，它必须指向一个用户数据段中的用户栈，而当CPL为0时，它必须指向内核数据段中的一个内核栈。当从用户态切换到内核态时，Linux总是确保ss寄存器装有内核数据段的段选择符)

(3) NT:  位14是嵌套任务标志(Nested Task)。 它**控制着被中断任务和调用任务之间的链接关系**。在使用CALL指令、中断或异常执行任务调用时，处理器会设置该标志。在通过使用IRET指令从一个任务返回时，处理器会检查并修改这个NT标志。使用POPF/POPFD指令也可以修改这个标志，但是在应用程序中改变这个标志的状态会产生不可预料的异常。

(4) RF:  位16是恢复标志(Resume Flag)。 该标志**用于控制处理器对断点指令的响应**。当设置时，这个标志会临时禁止断点指令产生的调试异常;当该标志复位时，则断点指令将会产生异常。**RF标志的主要功能是允许在调试异常之后重新执行一条指令。**当调试软件使用IRETD指令返回被中断程序之前，需要设置堆栈上EFLAGS内容中的RF标志，以防止指令断点造成另一个异常。处理器会在指令返回之后自动清除该标志，从而再次允许指令断点异常。

(5) VM:  位17是虚拟8086方式(Virtual 8086 Mode)标志。**当设置该标志时，就开启虚拟8086方式;  当复位该标志时，则回到保护模式**。

#### 4.1.2、内存管理寄存器

处理器提供了4个内存管理寄存器(GDTR、LDTR、IDTR和TR),  用于**指定内存分段管理所用系统表的基地址**，如图4-2所示。处理器为这些寄存器的加载和保存提供了特定的指令。有关系统表的作用请参见4.2节“保护模式内存管理”中的详细说明。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/17.png)

GDTR、LDTR、IDTR和TR都是段基址寄存器，这些段中**含有分段机制的重要信息表**。**GDTR、IDTR和LDTR用于寻址存放描述符表的段。TR用于寻址一个特殊的任务状态段(Task State Segment, TSS)。 TSS中包含着当前执行任务的重要信息**。

(1)全局描述符表寄存器GDTR
GDTR寄存器中用于**存放全局描述符表GDT的32位的线性基地址和16位的表限长值**。基地址指定GDT表中字节0在线性地址空间中的地址，表长度指明GDT表的字节长度值。指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。**在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值**。

(2)中断描述符表寄存器IDTR
与GDTR的作用类似，IDTR寄存器用于**存放中断描述符表IDT的32位线性基地址和16位表长度值**。指令LIDT和SIDT分别用于加载和保存IDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。

(3)局部描述符表寄存器LDTR
LDTR寄存器中用于**存放局部描述符表LDT的32位线性基地址、16位段限长和描述符属性值**。包含LDT表的段必须在GDT表中有一个段描述符项。当进行任务切换时，处理器会把新任务LDT的段选择符和段描述符自动地加载进LDTR中。在机器加电或处理器复位后，段选择符和基地址被默认地设置为0,而段长度被设置成0xFFFF。

(4) 任务寄存器TR
TR寄存器用于**存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值**。它引用GDT表中的一个TSS类型的描述符。**当执行任务切换时，处理器会把新任务的TSS的段选择符和段描述符自动加载进任务寄存器TR中**。

#### 4.1.3、控制寄存器

控制寄存器(CR0~CR3)用于控制和确定处理器的操作模式以及当前执行任务的特性，如图4-3所示：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/18.png)

CR0中含有控制处理器操作模式和状态的系统控制标志;  CR1保留不用;  CR2含有导致页错误的线性地址;  CR3 中含有页目录表物理内存基地址，因此该寄存器也被称为页日录基地址寄存器PDBR (Page .Directory Base address Register)。

1.CR0协处理器控制位

TS:  CR0的位3是**任务已切换(Task Switched) 标志**。该标志用于推迟保存任务切换时的协处理器内容，直到新任务开始实际执行协处理器指令。处理器在每次任务切换时都会设置该标志，并且在执行协处理器指令时测试该标志。

2.CR0中保护控制位

(1) PE:  CR0的位0是启用保护(Protection Enable) 标志。**当设置该位时即开启了保护模式;  当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制**。若要启用分页机制，那么PE和PG标志都要置位。

(2) PG:  CR0的位31是分页(Paging) 标志。当设置该位时即开启了分页机制;  当复位时则**禁止分页机制，此时所有线性地址等同于物理地址**。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。

启用保护模式PE (Protected Enable) 位(位0)和开启分页PG (Paging) 位(位31)分别用于控制分段和分页机制。**PE 用于控制分段机制**。**如果PE=1,  处理器就工作在开启分段机制环境下，即运行在保护模式下**（疑问：分段和保护模式之间的关系？？[保护模式--分段机制](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/18.png)）。如果PE=0，则处理器关闭了分段机制，并如同8086工作于实地址模式下。PG用于控制分页机制。如果PG=1,  则开启了分页机制。**如果PG=0,  分页机制被禁止，此时线性地址被直接作为物理地址使用**。

在开启分页(PG=1)之前必须先刷新**页高速缓冲**TLB。

(3) WP:  对于Intel 80486或以，上的CPU,  CR0的位16是写保护(Write Proctect)标志。当设置该标志时，处理器会禁止超级用户程序(例如特权级0的程序)向用户级只读页面执行写操作;  当该位复位时则反之。**该标志有利于UNIX类操作系统在创建进程时实现写时复制(Copy on Write)技术**。（疑问：为什么？？）

3.CR2和CR3

**CR2和CR3用于分页机制。CR3含有存放页目录表页面的物理地址**，因此CR3也被称为PDBR。因为页目录表页面是页对齐的，所以该寄存器只有高20位是有效的。而低12位保留供更高级处理器使用，因此在往CR3中加载一个新值时低12位必须设置为0。

使用MOV指令加载CR3时具有让页高速缓冲无效的副作用。**为了减少地址转换所要求的总线周期数量，最近访问的页目录和页表会被存放在处理器的页高速缓冲器件中**，该缓冲器件被称为转换查找缓冲区(Translation Lookaside Buffer, TLB)。**只有当TLB中不包含要求的页表项时才会使用额外的总线周期从内存中读取页表项**。

CR2用于出现页异常时报告出错信息。**在报告页异常时，处理器会把引起异常的线性地址存放在CR2中。因此操作系统中的页异常处理程序可以通过检查CR2的内容来确定线性地址空间中哪一个页面引发了异常**。













































































































































































