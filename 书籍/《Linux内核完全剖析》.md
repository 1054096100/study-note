# Linux内核完全剖析

## 第二章：微型计算机组成结构

操作系统与所运行的硬件环境密切相关。如果想彻底理解操作系统运行全过程，那么就需要了解它的运行硬件环境。

### 2.2、IO端口寻址和访问控制方式

#### 2.2.1、I/O端口和寻址

CPU为了访问I/O接口控制器或控制卡.上的数据和状态信息，需要首先指定它们的地址。这种地址就称为I/O端口地址或者简称端口。通常，一个I/O控制器包含访问数据的**数据端口**、输出命令的**命令端口**和访问控制器执行状态的**状态端口**。端口地址的设置方法-一般有两种:统一编址和独立编址。

### 2.3、主存储器、BIOS和CMOS存储器

1981年IBM PC刚推出时系统只带有640KB的RAM主存储器(简称内存)。由于所采用的8088/8086CPU只有20根地址线，因此内存寻址范围最高1024KB (1MB)。

目前的计算机通常都配置有512MB或者更多的物理内存容量，并且都采用Intel 32位CPU,即都是PC/AT计算机。因此CPU的物理内存寻址范围已经高达4GB (通过采用CPU的新特性，系统甚至可以寻址64GB的物理内存容量)。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/1.png)

但是**为了与原来的PC在软件上兼容，系统1MB以下物理内存使用分配上仍然保持与原来的PC基本一致**，只是原来系统ROM中的基本输入输出程序BIOS一直处于CPU能寻址的内存最高端位置处。

当计算机上:电初始化时，物理内存被设置成从地址0开始的连续区域。除了地址从0xA0000~0xFFFFF (640KB~1MB，共384KB）和0XFFFE0000～0XFFFFFFFF（4GB处的最后64KB）范围以外的所有内存都可用做系统内存。这两个特定范围被用于I/O设备和BIOS程序。假如我们的计算机中有16MB的物理内存，那么在Linux0.1x系统中，0~640KB将被用做存放内核代码和数据。**Linux内核不使用BIOS功能，也不使用BIOS设置的中断向量表**。640KB~1MB之间的384KB仍然保留用作图中指明的用途。**1MB~16MB将被内核用做可分配的主内存区**。另外高速缓冲区和内存虚拟盘也会占用内核代码和数据后面的一部分内存区域。该区域通常会跨越640KB~1MB的区域。

#### 2.3.2、基本输入/输出程序BIOS

存放在ROM中的系统BIOS程序**主要用于计算机开机时执行系统各部分的自检,建立起操作系统需要使用的各种配置表，如中断向量表、硬盘参数表**。并且把处理器和系统其余部分初始化到一个已知状态，而且还为DOS等操作系统提供硬件设备接口服务。但是**由于BIOS提供的这些服务不具备可重入性(即其中程序不可并发运行)**，并且从访问效率方面考虑，因此**除了在初始化时会利用BIOS提供一些系统参数以外，Linux操作系统在运行时并不使用BIOS中的功能**。

**当计算机系统上电开机或者按了机箱上的复位按钮时**，CPU会自动把代码段寄存器CS设置为0xF000，其段基地址则被设置为0xFFFF0000， 段长度设置为64KB。而IP被设置为0xFFF0,因此此时CPU代码指针指向0xFFFFFFF0处，即4GB空间的最后64KB的最后16B处。由图2-4可知，**这里正是系统ROM BIOS 存放的位置**，并且BIOS会在这里存放一条跳转指令JMP，跳转到BIOS代码中64KB范围内的某一-条指令开始执行。由于目前PC/AT中BIOS容量人多有1MB~2MB,并存储在闪存(Flash Memory) ROM中，因此为了能够执行或访问BIOS中超过64KB范围而又远远不在0~1MB地址空间中的其他BIOS代码或数据，BIOS程序会首先使用32位访问方式把数据段寄存器的访问范围设置成4GB (而非原来的64KB)，这样CPU就可以在0~4GB范围内执行和操作数据。此后，BIOS在执行了一些列硬件检测和初始化操作之后，就会把与原来PC兼容的64KB BIOS代码和数据复制到内存低端1MB末端的64KB处，然后跳转到这个地方并让CPU真正运行在实地址模式下，如图2-5所示。最后BIOS就会从硬盘或其他块设备把操作系统引导程序加载到内存0x7c00处，并跳转到这个地方继续执行引导程序。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/2.png)

#### 2.3.3、CMOS存储器

在PC/AT中，除需要使用内存和ROM BIOS以外，还使用只有很少存储容量的(只有64B或128B) CMOS 存储器来存放计算机的实时时钟信息和系统硬件配置信息。**这部分内存通常和实时时钟芯片(RealTime Chip)做在一块集成电路中。CMOS内存的地址空间在基本内存地址空间之外，需要使用I/O指令来访问**。

### 2.4、控制器和控制卡

#### 2.4.1、中断控制器

IBM PC/AT 80x86 兼容机使用两片级联的8259A可编程中断控制芯片组成一个中断控制器，用于实现I/O设备的中断控制数据存取方式,并且能为15个设备提供独立的中断控制功能。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/3.png)

#### 2.4.2、DMA控制器

如前所述，DMA控制器的主要功能是通过**让外部设备直接与内存传输数据**来增强系统的性能。通常它由机器上的Intel 8237芯片或其兼容芯片实现。**通过对DMA控制器进行编程，外设与内存之间的数据传输能在不受CPU控制的条件下进行**。因此在数据传输期间，**CPU可以做其他事情**。

#### 2.4.3、定时/计数器

Intel 8253/8254是一个可编程定时/计数器(Programmable Interval Timer, PIT)芯片，用于处理计算机中的精确时间延迟。该芯片提供了3个独立的16位计数器通道。每个通道可工作在不同的工作方式下，并且这些工作方式均叮以使用软件来设置。**在软件中进行延时的一种方法是执行循环操作语句，但这样做很耗CPU时间。若机器中采用了8253/8254 芯片，那么程序员就可以配置8253以满足自己的要求并且使用其中一个计数器通道达到所期望的延时。在延时到后，8253/8254将会向CPU发送一个中断信号**。

对于PC/AT及其兼容机系统采用的是8254芯片。3个定时/计数器通道被分别用于**时钟计时中断信号**、动态内存DRAM刷新定时电路和主机扬声器音调合成。**Linux0.12 操作系统只对通道0进行了重新设置**，使得该计数器工作在方式3下，并且**每间隔10ms发出一个信号以产生中断请求信号(IRQ0)**。这个间隔定时产生的中断请求就是Linux 0.12内核工作的脉搏，它**用于定时切换当前执行的任务和统计每个任务使用的系统资源量(时间)**。

#### 2.4.5、串行控制卡

##### 1.异步串行通信原理

两台计算机/设备进行数据交换，即通信，必须像人们对话一样使用同一种语言。在计算机通信术语中，我们把计算机/设备与计算机/设备之间的“语言”称为通信协议。通信协议规定了传送一个有效数据长度单位的格式。通常使用术语“帧”来描述这种格式。为了能让通信双方确定收/发的顺序和进行一些错误检测操作，除了必要的数据以外，在传输的1帧信息中还包含起始同步和错误检测作用的其他信息。
例如，在开始传输数据信息之前先发送起始同步或通信控制信息，并且在发送完需要的数据信息之后再传输一一些校验信息等，如图2-8所示。

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/4.png)

## 第三章：内核编程语言和环境

### 3.1、as86汇编器

#### 3.1.1、as86汇编器语言语法

汇编器编译产生的目标文件objfile通常至少包含3个段或区(section),即**正文段(.text)、数据段(.data) 和未初始化数据段(.bss)**。 正文段(或称为代码段)是一个已初始化过的段，通常其中包含程序的执行代码和只读数据。数据段也是一个已初始化过的段，其中包含可读/写的数据。而**未初始化数据段是一个未初始化的段**。**通常汇编器产生的输出目标文件中不会为该段保留空间，但在目标文件链接成执行程序被加载时操作系统会把该段的内容全部初始化为0**。

### 3.2、GNU as汇编

由于操作系统许多关键代码要求有很高的执行速度和效率，因此在一个操作系统源代码中通常就会包含大约10%的起关键作用的汇编语言代码。**Linux操作系统也不例外，它的32位初始化代码、所有中断和异常处理过程接口程序以及很多宏定义都使用了as汇编语言程序或扩展的嵌入汇编语句**。

#### 3.2.4、区与重定位

区(Section) (也称为段、节或部分)用于表示一个地址范围，操作系统将会以相同的方式对待和处理在该地址范围中的数据信息。例如，可以有一个“只读”的区，只能从该区中读取数据而不能写入。区的概念主要用来表示编译器生成的目标文件(或可执行程序)中不同的信息区域，例如目标文件中的正文区或数据区。

链接器ld会把输入的目标文件中的内容按照一定规律组合生成一个可执行程序。**当as汇编器输出一个目标文件时，该目标文件中的代码被默认设置成从地址0开始。此后ld将会在链接过程中为不同目标文件中的各个部分分配不同的最终地址位置。ld 会把程序中的字节块移动到程序运行时的地址处**。这些块是作为固定单元进行移动的。它们的长度以及字节次序都不会被改变。这样的固定单元就被称做区(或段、部分)。而**为区分配运行时刻的地址的操作就被称为重定位(Relocation)操作，其中包括调整目标文件中记录的地址，从而让它们对应到恰当的运行时刻地址上**。

另外，还有一种名为“未定义的”区(Undefined Section)。在汇编时不能确定所在区的任何地址都被设置成{undefinedU},其中U将会在以后填上。因为数值总是有定义的，所以出现未定义地址的唯一途径仅涉及未定义的符号。对一个称为公共块(Common Block)的引用就是这样一种符号:在汇编时它的值未知，因此它在undefined区中。

**链接器ld会把程序所有目标文件中的text区放在相邻的地址处。我们习惯上所说的程序的text区实际上是指其所有目标文件text区组合构成的整个地址区域**。对程序中data和bss区的理解也同样如此。

##### 1.链接器涉及的区

链接器ld只涉及如下4类区：

- text区、data区。这两个区用于保存程序。as和ld会分别独立而同等地对待它们。对其中text区的描述也同样适合于data区。然而**当程序在运行时，通常text 区是不会改变的。text区通常会被进程共享，其中含有指令代码和常数等内容**。**程序运行时data区的内容通常是会变化的，例如，C变量一般就存放在data区中**。
- bss区。**在程序开始运行时这个区中含有0值字节**。该区用于存放未初始化的变量或作为公共变量存储空间。虽然程序每个目标文件bss区的长度信息很重要，但是由于该区中存放的是0值字节，因此**无须在目标文件中保存bss区**。**设置bss区的目的就是为了从目标文件中明确地排除0值字节**。
- absolute区。该区的地址0总是“重定位”到运行时刻地址0处。如果你不想让ld在重定位操作时改变你所引用的地址，那么就使用这个区。从这种观点来看，我们可以把绝对地址称做“不可重定位的”，即在重定位操作期间它们不会改变。
- undefined区。对不在先前所述各个区中对象的地址引用都属于本区。

图3-2中是3个理想化的可重定位区的例子：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/5.png)

这个例子使用传统的区名称:.text和.data。其中水平轴表示内存地址。

##### 3.bss区

bss区用于**存储局部公共变量**。**你可以在bss区中分配空间，但是在程序运行之前不能在其中放置数据。因为当程序刚开始执行时，bss 区中所有字节内容都将被清零。**

#### 3.2.5、符号

在程序编译和链接过程中，符号(Symbol) 是一个比较重要的概念。程序员使用符号来命名对象，**链接器使用符号进行链接操作**，而调试器利用符号进行调试。

### 3.3、C语言程序

#### 3.3.1、C程序编译和链接

使用gcc汇编器编译C语言程序时通常会经过4个处理阶段，即预处理阶段、编译阶段、汇编阶段和链接阶段：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/6.png)

在预处理阶段中，gcc 会把C程序传递给C前处理器cpp,对C语言程序中指示符和宏进行替换处理，输出纯C语言代码;在编译阶段，gcc把C语言程序编译生成对应的与机器相关的as汇编语言代码;在汇编阶段，as汇编器会把汇编代码转换成机器指令，并以特定二进制格式输出保存在目标文件中;最后GNU ld 链接器把程序的相关目标文件组合链接在一起，生成程序的可执行映像文件。调用gcc的命令行格式与编译汇编语言的格式类似:

```shell
gcc [选项] [-o outfile] infile ...
```

对于某次编译过程，并非一定要全部执行这4个阶段，使用命令行选项可以令gcc编译过程在某个处理阶段后就停止执行。例如，使用“-S”选项可以让gcc在输出了C程序对应的汇编语言程序之后就停止运行;
使用“-c”选项可以让gcc只生成目标文件而不执行链接处理：

```shell
gcc -o hello hello.c    // 编译hello.c程序，生成可执行文件hello
gcc -S -o hello.s hello.c    // 编译hello.c程序，生成对应汇编程序hello.s
gcc -c -o hello.o hello.c    // 编译hello.c程序，生成对应目标文件hello.o而不链接 
```

#### 3.3.2、嵌入汇编

在C语言中写汇编代码：

```c
asm("汇编语句"
    : 输出寄存器
    : 输入寄存器
    : 会被修改的寄存器
);
```

除第1行以外，后面带冒号的行若不使用就都可以省略。

#### 3.3.5、内联函数

内联函数嵌入调用者代码中的操作是**一种优化操作**，因此只有进行优化编译时才会执行代码嵌入处理。**若编译过程中没有使用优化选项“-O”，那么内联函数的代码就不会被真正地嵌入到调用者代码中，而是只作为普通函数调用来处理**。

函数中的某些语句用法可能会使得内联函数的**替换操作无法正常进行**，或者不适合进行替换操作。例如**使用了可变参数**、内存分配函数malloca()、叮变长度数据类型变量、非局部goto语句以及**递归函数**。编译时可以**使用选项-Winline让gcc对标志成inline 但不能被替换的函数给出警告信息以及不能替换的原因**。

### 3.4、C与汇编程序的互相调用

#### 3.4.1、C函数调用机制

在Linux内核程序boot/head.s执行完基本初始化操作之后，就会跳转去执行init/main.c 程序（即init进程的main函数）。那么head.s程序是如何把执行控制转交给init/main.c 程序的呢?即汇编程序是如何调用执行C语言程序的?这里我们首先描述一下C函数的调用机制、控制权传递方式，然后说明head.s程序跳转到C程序的方法。

##### 1.栈帧结构和控制权转移方式

大多数CPU .上的程序实现使用栈来支持函数调用操作。栈被用来传递函数参数、存储返回信息、临时保存寄存器原有值以备恢复以及用来存储局部数据。单个函数调用操作所使用的栈部分被称为栈帧(stack frame) 结构，其一般结构如图3-4所示：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/7.png)

**对于函数A调用函数B的情况，传递给B的参数包含在A的栈帧中**。当A调用B时，函数A的返回地址(调用返回后继续执行的指令地址)被压入栈中，**栈中该位置也明确指明了A栈帧的结束处**（也就是说，先压入参数，后压入返回地址）。而B的栈帧则从随后的栈部分开始，即图中保存帧指针(ebp) 的地方开始。再随后则用于存放任何保存的寄存器值以及函数的临时值。

B函数同样也使用栈来保存不能放在寄存器中的局部变量值。例如由于通常CPU的寄存器数量有限而不能够存放函数的所有局部数据，或者有些局部变量是数组或结构，因此必须使用数组或结构引用来访问。另外，C语言的地址操作符“&”被应用到一个局部变量上时，我们就需要为该变量生成一个地址，即为变量的地址指针分配一空间。最后，B函数会使用栈来保存调用任何其他函数的参数。

栈是往低(小)地址方向扩展的，而esp指向当前栈顶处的元素。通过使用push和pop指令我们可以把数据压入栈中或从栈中弹出。对于没有指定初始值的数据所需要的存储空间，我们可以通过把栈指针递减适当的值来做到。类似地，通过增加栈指针值我们可以回收栈中已分配的空间。

##### 2.函数调用举例

```c
void swap() {
	int c;
	c = *a;
	*a = *b;
	*b = c;
}

int main(int argc, char const *argv[]) {
	int a, b;

	a = 16;
	b = 32;
    swap(&a, &b);

	return a - b;
}
```

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/8.png)

可以看出，函数swap()从调用者main()的栈帧中获取其参数。（注意一个问题，程序是按照逆向顺序把函数参数压入栈中，即函数最后(最右边的)一个参数先入栈，而最左边的第1个参数在最后调用指令之前入栈）

##### 3.main()也是一个函数

另外，上面提到C程序的**主程序main()也是一个函数。这是因为在编译链接时它将会作为crt0.s 汇编程序的函数被调用**。crt0.s 是一个桩(stub) 程序，名称中的“crt”是“C run-time”的缩写。**该程序的目标文件将被链接在每个用户执行程序的开始部分**，主要用于**设置一些初始化全局变量等**。Linux0.12中crt0.s汇编程序如下所示。其中已建立并初始化全局变量environ 供程序中的其他模块使用。

```assembly
.text
.globl _environ					# 声明全局変量environ (对应C程序中的environ变量)。

__entry:						# 代码入口标号
		movl 8(%esp), %eax		# 取程序的环境变量指针envp并保存在environ中。
		movl %eax, _environ		# envp是execve()函数在加载执行文件时设置的。
		call _main				# 调用我们的主程序。其返回状态值在eax寄存器中。
		pushl %eax				# 压入返回值作为exit()函数的参数并调用该函数。
l:		call _exit
		jmp lb					# 控制应该不会到达这里。若到达这里则继续执行exit()。
.data
_environ:						# 定义变量_environ,为其分配一个长字空间，
		.long 0
```

通常使用gcc编译链接生成执行文件时，gcc会自动把该文件的代码作为第一个模块链接在可执行程序中。在编译时使用显示详细信息选项“-v”就可以明显地看出这个链接操作过程:

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90/9.png)

为了使用ELF格式的日标文件以及建立共享库模块文件，现在的gcc编译器(2.x)已经把这个crt0扩展成几个模块: crtl.o、 crti.o、 crtbegin.o、 crtend.o 和crtn.o。**crti.o用于在.init区中执行初始化函数init()。.init 区中包含进程的初始化代码，即当程序开始执行时，系统会在调用main()之前先执行.init中的代码。crtn.o则用于在.fini区中执行进程终止退出处理函数fini()函数，即当程序正常退出时(main()返回之后)，系统会安排执行.fini中的代码**。



































































































































































