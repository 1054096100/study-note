# C Primer Plus

### 1、C编译器

C 编译器负责把C代码翻译成**特定的机器语言(因为不同的cpu的指令集是不同的)**。 此外， C编译器还将源代码与C库的代码合并成最终的程序（更精确地说， 应该是由一个被称为**链接器**的程序来链接库函数， 但是**在大多数系统中， 编译器运行链接器**）。其结果是， 生成一个用户可以运行的可执行文件， 其中包含着计算机能理解的代码 

2、如果想要储存编译好的可执行文件， 应该把它重命名。 否则， 该文件会被下一次编译程序时生成的新文件替换 

### 3、字符串

字符串（character string） 是一个或多个字符的序列， 如下所示："Zing went the strings of my heart!"双引号不是字符串的一部分。 **双引号仅告知编译器它括起来的是字符串， 正如单引号用于标识单个字符一样** 

数组末尾位置的字符\0。 这是**空字符**（null character） ， C语言用它标记字符串的结束。 空字符不是数字0， 它是非打印字符， 其ASCII码值是（或等价于） 0。 **C中的字符串一定以空字符结束**， 这意味着数组的容量必须至少比待存储字符串中的字符数多1。 因此，**一个40个存储单元的字符串， 只能储存39个字符， 剩下一个字节留给空字符** 

当我们使用`scanf `读取输入字符串的时候，不用亲自把空字符放入字符串末尾，因为，scanf()在读取输入时就已完成这项工作 ：

```c
char name[40];
scanf("%s", name);
```

此时，我们输入名字即可：

```
huanghantao
```

而不用输入：

```c
huanghantao\0
```

如果我们使用`strlen()`函数来处理name数组：

```c
strlen(name)
```

那么会返回11，说明没有把第12个单元存储的空字符计入

![](http://oklbfi1yj.bkt.clouddn.com/C%20Primer%20Plus/1.PNG)

如果我们使用`sizeof`运算符来处理name：

```c
sizeof name
```

那么会得到40

说明name数组有40个存储单元(也就是这个字符串占40个字节的存储空间)

sizeof圆括号的使用时机取决于运算对象是类型还是特定量。运算对象是类型时，圆括号必不可少， 但是对于特定量，可有可无。也就是说，对于类型，应写成sizeof(char)或sizeof(float)；对于特定量，可写成sizeof name或sizeof 6.28。尽管如此， 还是**建议所有情况下都使用圆括号**， 如sizeof(6.28) 

### 4、printf()函数

函数的格式：

```c
printf( 格式字符串, 待打印项1, 待打印项2,...);
```

待打印项1、 待打印项2等都是要打印的项。 它们可以是变量、 常量， 甚至是在打印之前先要计算的表达式 

如果只打印短语或句子， 就不需要使用任何转换说明(指的是%d这些东西)。 如果只打印数据， 也不用加入说明文字 

**(使用两个%%可以打印出%)**

### 5、转换说明的意义

我们知道，在计算机中，只能存储二进制数，所以，当我们输入如下：

```c
int num = 76;
```

实际上，在计算机中不是直接以`76`的形式存储的，而是`01001100 `

而**转换说明就是把以二进制格式存储在计算机中的值转换成一系列字符（字符串） 以便于显示** 。例如， 数字76在计算机内部的存储格式是二进制数01001100。 %d转换说明将其转换成字符7和6， 并显示为76； %x转换说明把相同的值（01001100） 转换成十六进制记数法4c； %c转换说明把01001100转换成字符L 

转换（conversion） 可能会误导读者认为原始值被转替换成转换后的值。实际上，转换说明是翻译说明，**%d的意思是“把给定的值翻译成十进制整数文本并打印出来”** 

例如：

```c
int num = 76;
printf("%s\n", num);
```

这个会报错：

```
warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
  printf("%s\n", num);
  ^
```

这就说明了并不是转换，而是翻译说明

### 6、scanf()函数

scanf()和 printf()类似，也使用格式字符串和参数列表。两个函数主要的区别在参数列表中。printf()函数使用变量、 常量和表达式，而**scanf()函数使用指向变量的指针** 

### 7、赋值运算符

**赋值运算符左侧必须引用一个存储位置**。 最简单的方法就是使用变量名。 指针也可用于指向一个存储位置。 概括地说， **C 使用可修改的左值（modifiable lvalue）标记那些可赋值的实体** 

**赋值表达式语句的目的是把值储存到内存位置上**。 用于储存值的数据存储区域统称为数据对象 。C 标准只有在提到这个概念时才会用到对象这个术语。 使用变量名是标识对象的一种方法 

**对象指的是实际的数据存储， 而左值是用于标识或定位存储位置的标签** 

举个例子：

```c
income = salary + bribes;
```

`income`、`salary`和`bribes`都是可修改的左值。因为每个变量都标识了一个可被赋值的数据对象。但是，表达式`salary + brives`是一个右值 

### 8、求模运算符

求模运算符常用于控制程序流 

### 9、递归的基本原理

例如有如下程序：

```c
#include <stdio.h>
void up_and_down(int);

int main(void)
{ 
	up_and_down(1);
	return 0;
}
void up_and_down(int n)
{
	printf("Level %d: n location %p\n", n, &n); // #1
	if (n < 4)
	{
		up_and_down(n + 1);
	}
	printf("LEVEL %d: n location %p\n", n, &n); // #2
}
```

结果：

![](http://oklbfi1yj.bkt.clouddn.com/C%20Primer%20Plus/3.PNG)

一、每级函数调用都有自己的变量

​	也就是说， 第1级的n和第2级的n不同， 所以程序创建了4个单独的变				                  量， 每个变量名都是n， 但是它们的值各不相同 

二、每次函数调用都会返回一次

​	当函数执行完毕后， 控制权将被传回上一级递归。 程序必须按顺序逐级返回递归， 从某级返回上一级， 不能跳级回到main()中的第1级调用 

![](http://oklbfi1yj.bkt.clouddn.com/C%20Primer%20Plus/2.PNG)

三、递归函数中位于递归调用之前的语句， 均按被调函数的顺序执行

​	例如：上面那个程序中，打印语句#1位于递归调用之前，它按照递归的顺序： 第1级、 第2级、 第3级和第4级， 被执行了4次

四、递归函数中位于递归调用之后的语句， 均按被调函数相反的顺序执行。 

​	例如，上面那个程序中，打印语句#2位于递归调用之后，其执行的顺序是第4级、 第3级、 第2级、 第1级。 **递归调用的这种特性在解决涉及相反顺序的编程问题时很有用**

五、递归函数必须包含能让递归调用停止的语句

​	通常，递归函数都**使用if或其他等价的测试条件**在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值 

### 10、尾递归

最简单的递归形式是**把递归调用置于函数的末尾，即正好在 return 语句之前**。这种形式的递归被称为尾递归（tail recursion） ，因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它**相当于循环** 

### 11、递归和倒序计算

例如，打印一个整数的二进制数的问题

整个过程都是围绕这对2整除和对2取模，所以，可以使用递归来解决

但是，并不是第一次取模得到的数字就立马打印出来，而是最后打印出来；同样的，第二次取模得到的数字是倒数第二打印出来。显然，这很符合递归的思路

```c
#include <stdio.h>
void to_binary(unsigned long n);

int main(int argc, char const *argv[]) {
	int num;
	printf("input the num:\n");
	scanf("%d", &num);
	to_binary(num);
	return 0;
}

void to_binary(unsigned long n) {
	int num = n % 2;
	if(n >= 2) {
		to_binary(n / 2);
	}
	printf("%d", num);
	return;
}
```

![](http://oklbfi1yj.bkt.clouddn.com/C%20Primer%20Plus/4.PNG)

如果不使用递归，在显示结果之前必须把所有的位数都储存在别处（例如， 数组）

### 12、查找地址；&运算符

如果主调函数不使用return返回的值， 则必须通过地址才能修改主调函数中的值 

**一元&运算符给出变量的存储地址** 。可以把地址看作是变量在内存中的位置 

### 13、指针

指针（pointer） 是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符， int类型变量的值是整数， 指针变量的值是地址

### 14、间接运算符：*

### 15、指针和数组

数组表示法其实是在变相地使用指针 

在C中， 指针加1指的是增加一个存储单元。 对数组而言， 这意味着把加1后的地址是下一个元素的地址， 而不是下一个字节的地址(指针加1， 指针的值递增它所指向类型的大小 )

































































