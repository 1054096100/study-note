# Linux网络编程

### 1、进程控制

#### 进程的概念

每个进程包括程序代码和数据。其中数据包含程序变量数据、外部数据和程序堆栈等 

系统的命令解释程序 shell 为了执行一条命令，就要建立一个新的进程并运行它

因为一个进程对应于一个程序的执行，所以绝对不要把进程与程序这两个概念相混淆。进程是动态的概念，而程序为静态的概念。实际上，**多个进程可以并发执行同一个程序**，对于公用的实用程序就常常是这样（例如，几个用户可以同时运行一个编辑程序，每个用户对此程序的执行均作为一个单独的进程 ）

#### 进程的建立 

**fork()** 在 Linux 系统库 **unistd.h** 中的函数声明如下：

```c
pid_t fork(void);
```

父进程与子进程就**并发执行**，它们都从 fork()调用后的那句语句开始执行

fork()调用执行示意图：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.PNG)

如图，它分为 fork()调用前和调用后两部分。调用前的那一部分给出了进程 A 调用fork()的情况。 PC（程序计数器）指向当前执行的语句。这时它指向第一个 printf 语句。调用后那一部分给出了调用 fork()以后的情况。这时进程 A 和 B 一起运行，进程 A 是父进程，进程 B 是子进程，它是进程 A 的副本，执行与 A 一样的程序。两个 PC 都指向第二个 printf语句，即 fork()调用之后的语句。也就是说， A 和 B 都从程序的相同点开始执行

系统调用 fork()没有参数，它返回一个 pid_t 类型的值 pid。 pid 被用来区分父进程和子进程。在父进程中， pid 被置为一个非 0 的正整数；在子进程中， pid 被置为 0。**根据 fork()在父进程和子进程中的返回值不同，程序员可以据此为两个进程指定不同的工作** 

在父进程中， pid 中返回的数是子进程的进程标识符

举个例子：

```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char const *argv[])
{
	pid_t pid;
	printf("now only one process\n");
	printf("Calling fork...\n");
	pid = fork();

	if (0 == pid) {
		printf("I am the child\n");
	}
	else if (pid > 0) {
		printf("I am the parent, child has pid %d\n", pid);
	}
	else {
		printf("fork fail\n");
	}
	return 0;
}
```

fork函数**被调用一次**，但**返回两次**。两次返回的唯一出别是child process的返回值是0，而父进程的返回值则是child process的进程ID

**注意：父进程执行完整的main函数。子进程是父进程的副本，开始于fork函数**（从fork函数开始以后的代码父子共享。**fork之后的父进程先执行还是子进程先执行是不确定的**。而且，此时在终端可能会出现显示混乱的现象，所以如果要同步执行，可以**在父进程**中使用`wait()`函数

fork 调用后面的条件语句有三个分支：第一个分支对应于 pid 的值为零，它给出了子进程的工作；第二个分支对应于 pid 之值为正数，它给出了父进程的工作。第三个分支对应于 pid 之值为负数（实际为-1），它给出了 fork 建立子进程失败时所作的工作。当系统那进程总数已达到系统规定的最大数，或者是用户可建立的进程数已达到系统规定的最大数时，这时再调用 fork，则会导致失败。上述两个进程间没有同步措施，所以父进程和子进程的输出内容有可能会叠加在一起

可以用 Linux 提供的进程间通信机构（如**信号和管道**等），使父进程与子进程协作**完成彼此有关的不同任务** 

#### 进程的运行 

```c
int execl( const char *path, const char *arg, ...);
int execlp( const char *file, const char *arg, ...);
int execle( const char *path, const char *arg , ..., char* const envp[]);
int execv( const char *path, char *const argv[]);
int execvp( const char *file, char *const argv[]);
```

exec 系列中的系统调用（unistd.h 中）都完成相同的功能，它们**把一个新程序装入调用进程的内存空间，来改变调用进程的执行代码，从而形成新进程**。如果 exec 调用成功，调用进程将被覆盖，然后从新程序的入口开始执行。这样就产生了一个新的进程，但是**它的进程标识符与调用进程相同。这就是说， exec 没有建立一个与调用进程并发的新进程，而是用新进程取代了原来的进程**。所以，对 exec **调用成功后，没有任何数据返回**，这与 fork()不同 

execl()调用的参数均为字符型指针，第一个参数 path 给出了被执行的程序所在的**文件名**，它必须是一个有效的路径名，文件本身也必须含有一个真正的可执行程序 。第二个以及用省略号表示的其它参数一起组成了该程序执行时的参数表。参数表的第一项是不带路径的程序文件名。被调用的程序可以访问这个参数表，它们相当于 shell 下的命令行参数。实际上， shell 本身对命令的调用也是用 exec 调用来实现的。由于参数的个数是任意的（即参数表的长度是不确定的），所以必须用一个 null 指针来**标记参数表的结尾**

使用 execl 调用来运行目录列表程序 ls 的例子：

```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char const *argv[])
{
	printf("Executing ls\n");
	execl("/bin/ls", "ls", "-l", NULL);

	/* 如果 execl 返回，说明调用失败 */
	perror("execl failed to run ls");
	exit(1);
}
```

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.PNG)

`execl()`导致从新程序（ls）的入口开始执行，此时，`execl()`后面的代码不会再执行了（除非`execl()`执行失败了）

#### exec 和 fork()的联用 

可以先用 fork()建立子进程，然后在子进程中使用 exec,这样就实现了父进程运行一个与其不同的子进程，并且父进程不会被覆盖：

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
	int pid;
	// fork 子进程
	pid = fork();
	switch (pid) {
		case -1:
				perror("fork failed");
				exit(1);
		case 0:
				execl("/bin/ls", "ls", "-l", "--color", NULL);
				perror("execl failed");
				exit(1);
		default:
				wait(NULL);
				printf("ls completed\n");
				exit(0);
	}
}
```

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.PNG)

在调用 fork()建立一个子进程之后，马上调用了 wait()，使父进程在子进程结束之前，一直处于睡眠状态。所以， **wait()向程序员提供了一种实现进程之间同步的简单方法**（这样，我们就可以控制那些代码先执行，哪些代码后执行）

**pid_t wait (int *status)**：

**wait()**函数会暂时停止目前进程的执行，**直到有信号来到或子进程结束**。**如果在调用wait()时子进程已经结束，则wait()会立即返回子进程结束状态值**。子进程的结束状态值会由参数status 返回，而子进程的进程识别码也会一起返回。如果不在意结束状态值，则status可以设成NULL

#### shell 的工作概况

当 shell （也就是bash进程）从命令行接受到以正常方式（即前台运行）执行一个命令或程序（例如pstree命令）的要求时，它就按上述方法调用 fork()（fork一个子进程）、exec（让这个fork出的进程执行pstree命令） 和 wait()（父进程，即bash进程等待子进程pstree执行完了之后再执行），以实现命令或程序的执行。当要求在后台执行一个命令或程序时， shell 就省略对 wait 的调用，使得 shell 和命令进程并发运行 

#### 数据和文件描述符的继承 

##### fork()、文件和数据 

因为子进程可用的数据是父进程可用数据的拷贝，并且**其占用不同的内存地址空间**，所以必须要确保以后一个进程中变量数据的变化，不能影响到其它进程中的变量 

另外，**在父进程中已打开的文件，在子进程中也已被打开，子进程支持这些文件的文件描述符**。但是，通过 fork()调用后，被打开的文件与父进程和子进程存在着密切的联系，这是以为子进程与父进程公用这些文件的文件指针。由于**文件指针由系统保存，所以程序中没有保存它的值，从而当子进程移动文件指针时，也等于移动了父进程的文件指针**。这就可能会产生意想不到到结果 

**文件指针为两个进程共用**

#### exec()和打开文件 

已打开的文件描述符能通过 exec 传送给新程序，并且这些文件的指针也不会被 exec 调用改变 

#### 终止进程的方法 

系统调用 exit()实现进程的终止：

```c
void exit(int status);
```

status，称作进程的退出状态，父进程可以使用它的低 8 位

exit()除了停止进程的运行外，它还有一些其它作用，其中最重要的是，**它将关闭所有已打开的文件**

如果父进程因执行了 wait()调用而处于睡眠状态，那么**子进程执行 exit()会重新启动父进程运行**。另外， exit()还将完成一些系统内部的清除工作，例如缓冲区的清除工作等 

除了使用 exit()来终止进程外，当进程运行完其程序到达 **main()函数**(注意是主函数，而不是其他的函数)末时，进程会自动终止。当进程在 **main()函数**（注意是主函数，而不是其他的函数）内执行一个 return 语句时，它也会终止 

#### 进程同步的方法

系统调用 wait()是实现进程同步的简单手段：

```c
pid_t wait(int *status)
```

当子进程执行时， wait()可以**暂停父进程**的执行（在子进程中使用`wait()`是无效的，达不到进程同步的效果），使起等待。一旦子进程执行完，等待的父进程就会重新执行。如果有多个子进程在执行，那么父进程中的 wait()**在第一个子进程结束时返回，恢复父进程的执行** 

通常情况下，父进程调用 fork()后要调用 wait()：

```c
pid = fork();
if (!pid) {
/* 子进程 */
} else {
/* 父进程 */
wait(NULL);
}
```

### 2、进程的属性 

#### 进程标识符 

一个标识符所代表的进程是唯一的。系统把标识符 0 和 1 保留给系统的两个重要进程。**进程 0 是调度进程，它按一定的原则把处理机分配给进程使用。进程 1 是初始化进程，它是程序/sbin/init 的执行。进程 1 是 UNIX 系统那其它进程的祖先，并且是进程结构的最终控制者**

##### 获取进程标识符

```c
pid = getpid();
```

##### 获取进程的父进程标识符 

```c
ppid = getppid();
```

#### 进程组标识符 

Linux 把进程分属一些组，用进程的组标识符来知识进程所属组。进程最初是通过 fork()和 exec 调用来**继承**其进程组标识符

但是，进程可以使用系统调用 setpgrp()，自己形成一个新的组：

```c
/* #include <unistd.h> */
int setpgrp(void);
```

setpgrp()的返回值是新的进程组标识符，**新的进程组标识符就是调用进程的进程标识符**。这时，调用进程就成为这个新组的进程组组长。它所建立的所有进程，将继承 newpg 中的进程组标识符 

##### 获得进程组标识符 

```c
/* #include <unistd.h> */
// 返回值是进程组的标识符，如果我们自己写一个简单的程序，那么它的进程id和进程组id是一样的
int getpgrp(void);
```

##### 设置新的进程组标识符

```c
/* #include <unistd.h> */
int setpgrp(void);
```

该函数的调用者会把自己加入一个新的process group，并且process group leader就是自己，即process group ID就是自己的进程号

**进程组对于进程间的通信机构——信号来说，是非常有用的**

##### 进程组的应用

当某个用户退出系统时，则相应的 shell 进程所启动的全部进程都要被强行终止。系统是根据进程的组标识符来选定应该终止的进程的。如果一个进程具有跟其祖先 shell 进程相同的组标识符，那么它的生命期将可超出用户的注册期。这对于需要长时间运行的后台任务是十分有用的  

### 3、进程环境 

一个进程的初始环境和用 fork() 或 exec 建立它的父进程的环境相同

由于环境可以通过 fork()或者 exec 被传送，所以其信息被半永久性的保存。对于新建立的进程来说，可以重新指定新的环境 

### 4、进程的当前目录 

每个进程都有一个当前目录（**当前目录是进程的一个属性**）。**一个进程的当前目录最初为其父进程的当前目录**，可见当前目录的初始值是通过 fork()和 exec 传送下去的 

**子进程通过 chdir()改变了它的当前目录，但是其父进程的当前目录并没有因此而改变**。鉴于此原因，**系统的 cd 命令（改变当前目录命令）实际上是一个 shell 自身的内部命令，其代码在 shell 内部，而没有单独的程序文件**（理解）。只有这样，才能改变相应 shell进程的当前目录。否则的话，只能改变 cd 程序所运行进程自己的当前目录（因为`cd`进程是`shell`进程的子进程，而如果cd命令是单独的程序文件，那么，使用cd命令的时候，只会改变子进程cd自己的当前目录，而不会改变shell进程<可以理解为终端>的工作目录，这显然不是我们想要的结果） 

每个进程还有一个根目录，它与绝对路径名的检索起点有关。与当前目录一样，进程的根目录的初始值为其父进程的根目录。可以用系统调用 chroot()来改变进程的根目录，但是这不会改变其父进程的根目录 

### 5、进程的有效标识符

每个进程都有一个**实际**用户标识符（也就是说，每个进程都要有一个用户来启动）和一个实际组标识符，它们永远是启动该进程的用户的用户标识符和组标识符 

进程的有效用户标识符和有效组标识符也许更重要些，它们被用来确定一个用户能否访问某个确定的文件。在通常情况下，它们与实际用户标识符和实际组标识符是一致的。但是，**一个进程或其祖先进程可以设置程序文件的置用户标识符权限或置组标识符权限。这样，当通过 exec 调用执行该程序时，其进程的有效用户标识符就取自该文件的文件主的有效用户标识符，而不是启动该进程的用户的有效用户标识符**

#### 获得进程的实际用户标识符 

```c
uid = getuid();
```

#### 获得进程的有效用户标识符 

```c
euid = geteuid();
```

#### 设置进程的有效用户标识符

```c
/*不是超级用户所引用的进程，只能把它的有效用户表示符重新设置成其实际用户标识符*/
/*通过这个系统调用，进程可以改变自己的标识符，进而改变自己的权限（因为 Linux中权限是通过标识符来判断的）*/
status = setuid(newuid);
```

#### 获得进程的实际组标识符 

```c
gid = getgid();
```

#### 获得进程的有效组标识符 

```c
egid = getegid();
```

#### 设置进程的有效组标识符 

```c
/*不是超级用户所引用的进程，只能把它的有效组标识符重新设置成其实际组标识符*/
status = getgid(newgid);
```

### 6、进程的优先级

进程的**优先数越大**，其**优先权越低**

**普通进程**可以用系统调用 nice()降低优先权：

```c
nice(5); // 使当前的优先数增加了 5,显然，其对应进程的优先权降低了
```

**超级用户**可以用系统调用 nice()增加优先权：

```c
nice(-1); // 使当前的优先数减少了 1
```

### 7、守护进程 

守护进程是一种后台运行并且独立于所有终端控制之外的进程，它们执行着各种系统服务和管理的任务

#### 需要守护进程的原因

1、首先，**处于安全性**的考虑我们不希望这些进程在执行中的信息在任何一个终端上显示（安全性）

2、其次，我们不希望这些进程被终端所产生的中断信号所打断（不被中断）

3、最后，虽然我们可以通过&将程序转为后台执行，我们有时也会需要程序能够自动将其转入后台执行（自动转入后台）

#### 启动守护进程的方法

1、在系统期间通过系统的初始化脚本启动守护进程 

2、很多网络服务程序是由 inetd 守护程序（主进程）启动的。它**监听各种网络请求**，如 telnet、 ftp 等，在请求到达时启动相应的服务器程序（ telnet server、ftp server 等） 

3、由 cron 定时启动的处理程序（这些定时启动的程序在运行时实际上也是一个守护进程 ）

4、由 at 启动的处理程序 

#### 创建守护进程 

1． fork

首先需要 fork 一个子进程并将父进程关闭。**这样子进程就自动称为了后台进程**（注意，后台进程和守护进程是有区别的）。而且，子进程从父进程那里继承了组标识符同时又拥有了自己的进程标识符，这样保证了子进程不会是一个进程组的首（但是，这个子进程仍然在bash进程所在的进程组里面，所以还没有脱离终端）

2． setsid

setsid()调用创建了一个新的进程组，调用进程成为了该进程组的首进程。这样，就使该进程脱离了原来的终端，成为了独立于终端外的进程

3、忽略 SIGHUP 信号，重新 fork

这样使进程不再是进程组的首进程，可以防止在某些情况下进程意外的打开终端而重新与终端发生联系 

4、改变工作目录，清除文件掩码

改变工作目录主要是为了切断进程与原有文件系统的联系。并且保证无论从什么地方启动进程都能正常的工作。清除文件掩码是为了消除进程自身掩码对其创建文件的影响 

5、关闭全部已打开的文件句柄

防止子进程继承了在父进程中打开的文件而使这些文件始终保持打开从而产生某些冲突 

### 8、进程间通信 

**进程阻塞**  

当一个进程在执行某些操作的条件得不到满足时，就自动放弃 CPU 资源而进入休眠状态，以等待条件的满足。当操作条件满足时，系统就将控制权返还给该进程继续进行未完的操作 

**共享资源** 

因为计算机的内存、存储器等资源是有限的，无法为每一个进程都分配一份单独的资源。所以**系统将这些资源在各个进程间协调使用，称为共享资源** 

**锁定** 

当某个进程在使用共享资源使用，可能需要防止别的进程对该资源的使用

Linux 提供一些方法来保证共享资源在被某个进程使用时，别的进程无法使用。这就叫做共享资源的锁定

#### 信号

信号是 UNIX 系统所使用的进程通信方法中，最古老的一种。系统使用它来通知一个或多个进程异步事件的发生

信号不但能从内核发往一个进程，也能从一个进程发往另一个进程。例如，用户在后台启动了一个要运行较长时间的程序，如果想中断其执行，可以用 kill 命令把 SIGTERM信号发送给这个进程， SIGTERM 将终止此进程的执行 

**信号可以中断一个进程，而不管它正在作什么工作**。**由于信号的特点，所以不用它来作进程间的直接数据传送**，而把它用作对非正常情况的处理 

由于信号本身不能直接携带信息，这就限制了它作为一项通用的进程通信机制。但是，每种信号都有其特定的含义

Linux 提供的**大多数信号**类型是**供内核使用**的，只有少数的几种信号可以用作在进程之间传送 

##### SIGHUP

当终止一个终端时，内核就把这一种信号发送给该终端所控制的所有进程。这就可以保证当一个用户退出使用时，其后台进程被终止，除非有其它方面的安排 

##### SIGINT

当一个用户按了中断键（一般为 Ctrl+C）后，内核就向与该终端有关联的所有进程发送这种信号。中止运行程序

##### SIGALRM

当一个定时器到时的时候，内核就向进程发送这个信号

##### SIGCHLD（很重要）

子进程结束信号。UNIX 中用它来**实现系统调用 exit()和 wait()**。执行 exit()时，就向子进程的父进程发送 SIGCHLD 信号，如果这时父进程政在执行 wait()，则它被唤醒；如果这时候父进程不是执行 wait()，则此父进程不会捕捉 SIGCHLD 信号，因此该信号不起作用，子进程进入过渡状态（**如果父进程忽略 SIGCHLD，子进程就结束而不会进入过渡状态**）。这个机制对大多数 UNIX 程序员来说是**相当重要**的

##### 进程间发送信号

```c
/*#include <signal.h>*/
int kill(pid_t pid, int sig);
```

参数 pid 指定了信号发送的对象进程，参数 sig 指定发送的信号类型 

参数 pid 可以是某个进程的进程标识符(pid)。（如果 pid 为零，则信号被发送到**当前进程所在的进程组**的所有进程）

注意：普通用户的进程只能向具有与其相同的**用户标识符**（UID）的进程发送信号。也就是说，一个用户的进程不能向另一个用户的进程发送信号。只有 root 用户的进程能够给任何线程发送信号

##### kill 命令

它是一个对系统调用 kill()的命令层接口。 kill 命令用于向一个运行进程发送信号，它发送的信号默认为 SIGTERM，但是也可以指定为其它信号 

##### 信号的处理

几乎所有的信号都将终止接收到该信号的进程。但是，正当在对一个重要的数据库进行修改期间，由于不小心碰到了中断键，而使程序被意外的终止，从而产生严重的后果。所以，我们需要处理进程接收到的信号

UNIX 的系统调用 signal()用于接收一个指定类型的信号，并可以指定相应的方法：

```c
int signal (int sig, __sighandler_t handler);
```

第一个参数 sig 指明了所要处理的信号类型，它可以取除了 SIGKILL 和 SIGSTOP 外的任何一种信号。参数 handler 描述了与信号关联的动作，它可以取以下三种值：

1、一个返回值为整数的**函数地址**（函数名实际上可以理解为地址）

此函数必须在 signal()被调用前声明， handler 中为这个函数的名字。当接收到一个类型为 sig 的信号时，就执行 handler 所指定的函数：

```c
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>

void catch(int sig);

int main(void)
{
    signal(SIGINT, catch); /* 将 SIGINT 信号与 catch 函数关联 */
    printf("in main function\n");
    sleep(10);
    printf("end\n");
    return 0;
}

void catch(int sig)
{
    printf("Catch succeed!\n");
    return 1;
}
```

当程序运行时我们按下中断键（ Ctrl+C），进程被中断，函数 catch 就被执行。它执行完毕后，进程回到中断点继续执行（所以，此时当我们按下  Ctrl+C 之后，进程就不会立刻结束了。如果我们需要结束进程，可以在需要结束的地方手动加上 `exit()`函数）

**注意**：当程序把一个信号处理函数与 SGINT 和 SIGQUIT 联系起来后，**如果该程序在后台执行**，那么由于 shell 的作用，会使得 SIGINT 和 SIGQUIT 被忽略。这样**后台程序就不会被 SIGINT 和 SIGOUT 所中止**

##### 信号与系统调用的关系 

**当一个进程正在执行一个系统调用时，如果向该进程发送一个信号，那么对于大多数系统调用来说，这个信号在系统调用完成之前将不起作用，因为这些系统调用不能被信号打断**。但是有少数几个系统调用能被信号打断，例如： wait(),pause()以及对慢速设备（终端、打印机等）的 read()、 write()、 open()等

##### 信号的复位

当一个信号的信号处理函数执行时，如果进程又接收到相同的信号，该信号会自动被储存而不会中断信号处理函数的执行，直到信号处理函数执行完毕再重新调用相应的处理函数 

但是，如果在信号处理函数执行时进程收到了**其它类型**的信号，该函数的执行就会被中断

##### 系统调用 pause()

使进程暂停执行，直至接收到某种信号为止

```c
/*#include <unistd.h>*/
int pause(void);
```



##### 系统调用 abort()

```c
/*#include < stdlib.h>*/
void abort(void);
```

abort()向调用进程发送一个信号，产生一个非正常终止，即核心转贮。说明**进程可以向自己发送信号**这一事实

#### 管道

管道就是将**一个程序的输出**和**另外一个程序的输入**连接起来的单向通道。形象的说，就是数据沿着管道从管道的左边流到了管道的右边

例如：

```shell
ls -l | more
# | 底层就用到了管道
```

当进程创建一个管道的时候，系统内核同时为该进程设立了一对文件句柄（一个流），一个文件句柄用来向管道输出（ write） ，另一个文件句柄用来从该管道获取数据（ read）

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5.PNG)

在 Linux 系统内核里，每个管道都是用一个 inode节点来表示的。（当然，你是不会看到这个节点的，它只存在于系统的内核中。）

fork()的子进程自动继承了父进程打开的文件句柄（父子两个进程同时拥有对同一个管道的读写句柄 ）。利用继承的句柄，就可以实现父/子间的通信了：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6.PNG)

因为管道必须是单向的（因为它没有提供锁定的保护机制），所以我们必须决定数据的流动方向（从父到子，还是从子到父？ ） 假设我们需要管道从子进程向父进程传送数据，关闭了相应句柄后的管道可以用下图来表示：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7.PNG)

##### 建立管道

```c
/*
* fd[0] 是从管道中读出数据的句柄, fd[1] 是向管道写入数据的句柄。即，fd[1]的写入由 fd[0]读出
*/
int pipe( int fd[2] ); 
```

建立管道：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
main()
{
    int fd[2];
    pid_t childpid;
    pipe(fd);
  
    if((childpid = fork()) == -1)
    {
        perror("fork");
        exit(1);
    }
… … 
}
```

接下来，我们假设需要管道中数据的流动是从子进程到父进程。这样父进程就需要关闭（ close()）写管道的句柄（ fd[1]），而子进程需要关闭读管道的进程（ fd[0]）：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
main()
{
    int fd[2];
    pid_t childpid;
    pipe(fd);
    
    if((childpid = fork()) == -1)
    {
        perror(“fork”);
        exit(1);
    }
    if(childpid == 0)
    {
        /* 子进程关闭管道的读句柄 */
        close(fd[0]);
    }
    else
    {
        /* 父进程关闭管道的写句柄 */
        close(fd[1]);
    }
……
……
}
```

##### 使用管道

```c
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
int main(void)
{
    int fd[2], nbytes;
    pid_t childpid;
    char string[] = "Hello, world!\n";
    char readbuffer[80];
	pipe(fd);
  
    if((childpid = fork()) == -1)
    {
        perror("fork");
        exit(1);
    }
    if(childpid == 0)
    {
        /* 子进程关闭管道的读句柄 */
        close(fd[0]);
        /* 通过写句柄向管道写入信息 */
        write(fd[1], string, strlen(string));
        _exit(0);
    }
    else
    {
        /* 父进程关闭管道的写句柄 */
        close(fd[1]);
        /* 通过读句柄从管道读出信息 */
        nbytes = read(fd[0], readbuffer, sizeof(readbuffer));
        printf("Received string: %s", readbuffer);
    }
  
    return(0);
}
```

##### 需要注意的问题

1、pipe()的调用必须在 fork()之前

2、及时关闭不需要的管道句柄

3、使用 dup()之前确定定向的目标是最小的文件句（因为在 dup()函数中我们无法指定重定向的新句柄，系统将自动使用未被使用的最小的文件句柄 <记住，句柄是一个整型量。例如：文件句柄 0（ stdin）> 作为重定向的新句柄）

4、管道只能实现父子进程间的通信，如果两个进程之间没有 fork()关系，就必须考虑其他的进程通信方法

##### 有名管道

为了解决管道不能提供非父/子关系进程间通信的缺陷，在管道的基础上发展了有名管道（ FIFOs）的概念。我们知道，尽管管道在 Linux 系统内部是以文件节点（ inode）的形式存在的，但是由于其对外的不可见性（“无名”性），我们无法创建新的句柄对其进行访问。而有名管道在 Linux 系统中以一种特殊的设备文件的形式存在于文件系统中。这样它不仅具有了管道的通信功能，也具有了普通文件的优点（可以同时被多个进程共享，可以长期存在等等），有效的解决了管道通信的缺点 

#### 文件和记录锁定

由于在共享资源的访问中没有健全互斥性措施，从而引起了访问和操作的混乱。因此我们要求进程在对共享资源访问前必须进行锁定以避免其它进程对它的操作，当然在该进程访问完共享资源后也要进行解锁操作，以使其它进程能有机会占用共享资源 

##### 锁定中的几个概念

文件锁定的是整个文件，而记录锁定只锁定文件的某一特定部分。 UNIX 的记录指的是从文件的某一相对位置开始的一段连续的字节流，因此， UNIX 记录锁更恰当的称呼应该是范围锁，它是对文件某个范围的锁定

#### 信号量

用来控制多个进程对共享资源使用的计数器。它经常被用作一种锁定保护机制，当某个进程在对资源进行操作时阻止其它进程对该资源的访问。需要注意的是， System V 中的信号量对象实际上是信号量的集合（在 Linux 系统中，这种集合是以数组的形式实现的。数组的每个成员都是一个单独的信号量，它们在系统中是以 sem 结构的形式储存的），它可以包含多个信号量，控制多个共享资源

##### 与信号量有关的数据结构 

Sem 结构：

```c
/*在 Linux 系统库 linux/sem.h 中 */
struct sem {
    short sempid; /* 保存了最近一次操作信号量的进程的 pid */
    ushort semval; /* 保存着信号量的计数值 */
    ushort semncnt; /* 等待使用资源的进程数目 */
    ushort semzcnt; /* 等待资源完全空闲的的进程数目 */
};
```

semun 联合：

```c
union semun {
    int val; /* value for SETVAL */
    struct semid_ds *buf; /* buffer for IPC_STAT & IPC_SET */
    ushort *array; /* array for GETALL & SETALL */
    struct seminfo *__buf; /* buffer for IPC_INFO */
    void *__pad;
};
```

sembuf 结构：

```c
struct sembuf {
    unsigned short sem_num; /* 接受操作的信号量在信号量数组中的序号（数组下标） */
    short sem_op; /* 定义了进行的操作(可以是正、负和零) */
    short sem_flg; /* 控制操作行为的标志 */
};
```

如果 `sem_op ` 是负值，就从指定的信号量中减去相应的值。这对应着**获取**信号量所监控的资源的操作；如果 sem_op 是正值，就在指定的信号量中加上相应的值。这对应着**释放**信号量所监控的资源的操作 

如果 `sem_op ` 是零，那么调用 `semop()` 函数的进程就会被阻塞直到对应的信号量值为零。这种操作的**实质是等待信号量所监控的资源被全部使用**。利用这种操作可以动态监控资源的使用并调整资源的分配，避免不必要的等待

semid_qs 结构：

```c
struct semid_ds {
    struct ipc_perm sem_perm; /* 保存了信号量对象的存取权限以及其他一些信息 */
    __kernel_time_t sem_otime; /* 保存了最近一次 semop()操作的时间 */
    __kernel_time_t sem_ctime; /* 保存了信号量对象最近一次改动发生的时间 */
    struct sem *sem_base; /* 指针保存着信号量数组的起始地址 */
    struct sem_queue *sem_pending; /* 指针保存着还没有进行的操作 */
    struct sem_queue **sem_pending_last; /* 指针保存着最后一个还没有进行的操作 */
    struct sem_undo *undo; /* 保存了 undo 请求的数目 */
    unsigned short sem_nsems; /* 保存了信号量数组的成员数目 */
};
```

##### 使用信号量要用到的函数

```c
/*
* 在 Linux 系统库 linux/sem.h中
* 建立新的信号量对象或者获取已有对象的标识符
*/
int semget ( key_t key, int nsems, int semflg);
```

```c
/*
* 在 Linux 系统库 linux/sem.h中
* 改变信号量对象中各个信号量的状态
*/
int semop ( int semid, struct sembuf *sops, unsigned nsops);
```

```c
/*
* 在 Linux 系统库 linux/sem.h中
* 用来直接对信号量对象进行控制
*/
int semctl ( int semid, int semnum, int cmd, union semun arg );
```

#### 共享内存

简单的说就是被多个进程共享的内存。它在各种进程通信方法中是最快的，因为它是将信息直接映射到内存中，省去了其它 IPC（进程间通信） 方法的中间步骤 

### 9、套接字

网络程序设计全靠套接字接受和发送信息

套接字工作过程如下:服务器首先启动，通过调用 socket()建立一个套接字，然后调用bind()将该套接字和本地网络地址联系在一起，再调用 listen()使套接字做好侦听的准备，并规定它的请求队列的长度,之后就调用 accept()来接收连接。客户在建立套接字后就可调用 connect()和服务器建立连接。连接一旦建立，客户机和服务器之间就可以通过调用 read()和 write()来发送和接收数据。最后，待数据传送结束后，双方调用 close()关闭套接字

#### socket 接口示意图

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8.PNG)

Socket 利用网间网通信设施实现进程通信，但它对通信设施的细节毫不关心，只要通信设施能提供足够的通信能力，它就满足了

Socket 实质上**提供了进程通信的端点**。**进程通信之前，双方首先必须各自创建一个端点**，否则是没有办法建立联系并相互通信的。正如打电话之前，双方必须各自拥有一台电话机一样 

每一个 Socket 都用一个半相关描述：

```
{协议，本地地址，本地端口}
```

一个完整的 Socket 则用一个相关描述：

```
{协议，本地地址，本地端口，远程地址，远程端口}
```

每一个 Socket 有一个本地的唯一 Socket 号，由操作系统分配

Socket 是**面向客户－服务器模型**而设计的，针对客户和服务器程序提供不同的 Socket 系统调用。Socket 利用客户— 服务器模式巧妙的**解决了进程之间建立通信连接的问题**

#### 套接字的三种类型

##### 流式套接字（ SOCK_STREAM）

流式的套接字可以**提供可靠的、面向连接的**通讯流。如果你通过流式套接字发送了顺序的数据：“ 1”、“２ ”。那么数据到达远程时候的顺序也是“１ ”、“２ ” 

Telnet 是一个流式连接

WWW 浏览器，它使用的 **HTTP 协议也是通过流式套接字来获取网页的** 

流式套接字是怎样保证这种应用层次上的数据**传输质量**呢？它使用了 TCP协议。**TCP 保证了你的数据传输是正确的，并且是顺序的**

##### 面向连接的 socket 的工作流程图

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.PNG)

##### 数据报套接字（ SOCK_DGRAM）

数据报套接字定义了一种**无连接**的服务，数据通过**相互独立**的报文进行传输，是**无序的，并且不保证可靠性** 

（ UDP）不像流式套接字那样维护一个打开的连接，你只需要把数据打成一个包，把远程的 IP 贴上去，然后把这个包发送出去。这个过程是**不需要建立连接的**。 UDP 的应用例子有： tftp, bootp 等 

无连接服务器一般都是**面向事务处理**的，一个请求一个应答就完成了客户程序与服务程序之间的相互作用

##### 无连接的 socket 工作流程图

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/10.PNG)

无连接的会比面向连接的简单些。面向连接服务器处理的请求往往比较复杂，不是一来一去的请求应答所能解决的，而且往往是并发服务器

##### 原始套接字

原始套接字主要**用于一些协议的开发**，可以进行**比较底层**的操作。它功能强大，但是没有上面介绍的两种套接字使用方便，一般的程序也涉及不到原始套接字

原始套接字允许对低层协议如 IP 或 ICMP 直接访问，主要用于新的网络协议实现的测试 

#### 套接字地址

##### 什么是 Socket

它是通过标准的 UNIX 文件描述符和其他的程序通讯的一个方法（**Socket 是一个文件描述符**）

##### Socket 描述符

在 UNIX 系统中，任何对 I/O 的操作，都是通过**读或写文件描述符**来实现的 

一个文件描述符只是一个简单的**整形数值**，代表一个被打开的文件（这里的文件是广义的文件，并不只代表不同的磁盘文件，它可以代表一个网络上的连接，一个先进先出队列，一个终端显示屏幕，以及其他的一切）。**在 UNIX 系统中任何东西都是一个文件**！！所以**如果想通过 Internet 和另外一个程序通讯的话，你将会是通过一个文件来描述符实现的**

因为套接字描述符是一个文件描述符，所以**write() 和 read() 是可以对套接字描述符进行操作的**，但是，**send() 和 recv() 函数可以对网络数据的传输进行更好的控制**

#### 套接字的一些基本知识

##### 基本结构

```c
struct sockaddr {
    unsigned short sa_family; /* address族, 一般来说都是AFINET */
    char sa_data[14]; /* 14 bytes的协议地址，远程电脑的地址、端口和套接字的数目 */
};
```

```c
/* #include <netinet/in.h> */
struct sockaddr_in {
    short int sin_family; /* Internet地址族，一般是AF_INET */
    unsigned short int sin_port; /* 端口号 */
    struct in_addr sin_addr; /* Internet地址（IP地址） */
    unsigned char sin_zero[8]; /* 添0（和struct sockaddr一样大小） */
};
```

这个结构提供了方便的手段来访问 socket address（ struct sockaddr）结构中的每一个元素。注意 sin_zero[8] 是为了是两个结构在内存中具有相同的尺寸，使用 sockaddr_in 的时候要把 sin_zero 全部设成零值（使用 bzero()或 memset()函数）

一定要保证 **sin_port 和 sin_addr 必须是网络字节顺序**

```c
struct in_addr {
	unsigned long s_addr; // 可以让s_addr为INADDR_ANY，绑定所有的IP（INADDR_ANY在#include                                <sys/types.h>里面定义了）
};
```

##### 基本转换函数

```c
/*
* "Host to Network Short"主机字节顺序转换为网络字节顺序（对无符号短型进行操作 4 bytes）
*/
htons(); // 一般对端口号使用这个函数转换
```

```c
/*
* "Host to Network Long"　主机字节顺序转换为网络字节顺序（对无符号长型进行操作 8 bytes）
*/
htonl(); // 一般对IP地址使用这个函数转换
```

```c
/*
* "Network to Host Short"　网络字节顺序转换为主机字节顺序（对无符号短型进行操作 4 bytes）
*/
ntohs();
```

```c
/*
* "Network to Host Long"　网络字节顺序转换为主机字节顺序（对无符号长型进行操作 8 bytes）
*/
ntohl();
```

因为程序可能会被移植到另外的机器上，所以在把数据发送到 Internet 之前，一定要把它的字节顺序从主机字节顺序转换到网络字节顺序

#### 基本套接字调用

##### socket() 函数

取得套接字描述（其实就是一个**文件描述符**）

```c
#include <sys/types.h>
#include <sys/socket.h>
int socket(int domain, int type, int protocol); //返回一个套接字描述符
```

domain 需要被设置为 “ AF_INET”，就像上面的 struct sockaddr_in。然后， type参数告诉内核这个 socket 是什么类型，“ SOCK_STREAM”或是“ SOCK_DGRAM”。最后，只需要把 protocol 设置为 0

##### bind() 函数

指定一个套接字使用的**端口**

如果需要进行端口监听 listen()操作，等待接受一个连入请求的时候，一般都需要经过这一步；如果只是想进行连接一台服务器，也就是进行 connect() 操作的时候，这一步并不是必须的

有时候你并不一定要调用 bind()来建立网络连接。比如你只是想连接到一个远程主机上面进行通讯（也就是说不需要特定的服务，例如FTP服务，WWW服务等等，所以，不需要使用特定的端口），你并不在乎你究竟是用的自己机器上的哪个端口进行通讯（比如 Telnet），那么你可以简单的直接调用 connect()函数，**connect()将自动寻找出本地机器上的一个未使用的端口，然后调用 bind()来将其 socket 绑定到那个端口上**

记住：基本上，我们并不在乎我们本地用什么端口来通讯，我们在乎的是我们连到哪台主机上的哪个端口上。 Linux 内核自动为我们选择了一个没有被使用的本地端口（connect()函数会做这个事）

```c
#include <sys/types.h>
#include <sys/socket.h>
/*
返回值：成功0， 失败-1
*/
int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
```

sockfd 是由 socket()函数返回的套接字描述符

my_addr 是一个指向 struct sockaddr 的指针，包含地址的信息：名称、端口和 IP 地址。如果原来的my_addr 是sockaddr_in类型的结构体，那么，需要进行类型转换，再把它作为第二个参数传递进去：

```c
(struct sockaddr*)&my_addr
```

addrlen 可以设置为 sizeof(struct sockaddr)

注意：调用 bind() 的时候，**不要把端口数设置的过小**！**小于 1024 的所有端口都是保留下来作为系统使用端口的**，没有 root 权限无法使用。你可以**使用 1024 以上的任何端口**，一直到 65535 

##### connect() 函数（客户端用的）

```c
#include <sys/types.h>
#include <sys/socket.h>
int connect (int sockfd, struct sockaddr *serv_addr, int addrlen);
```

sockfd ：套接字文件描述符，由 socket()函数返回的

serv_addr 是一个存储**远程**计算机的 **IP 地址和端口**信息的结构

addrlen 是 sizeof(struct sockaddr) 

##### listen() 函数

等待别人连接，进行系统侦听请求的函数

```c
#include <sys/socket.h>
/*
返回值：成功0， 失败-1
*/
int listen(int sockfd, int backlog);
```

sockfd 是一个套接字描述符，由 socket()系统调用获得

backlog 是未经过处理的**连接请求队列**可以容纳的最大数目

backlog 的具体意思：每一个连入请求都要进入一个连入请求队列，等待listen 的程序调用 accept() 函数来接受这个连接。当系统还没有调用 accept()函数的时候（也就是还没有被接收），如果有很多连接，那么本地能够等待的最大数目就是 backlog 的数值。推荐将其设成 5 到 10 之间的数值

此时，需要指定本地端口了，因为我们是等待别人的连接。所以，在 listen()函数调用之前，我们需要使用 bind() 函数来指定使用本地的哪一个端口数值

##### accept()函数

```c
#include <sys/socket.h>
/*
返回值：成功：一个新的代表连接的socket文件描述符；失败：-1
*/
int accept(int sockfd, void *addr, int *addrlen);
```

sockfd 是正在 listen() 的一个套接字描述符

addr 一般是一个指向 struct sockaddr_in 结构的指针；里面存储着远程连接过来的计算机的信息（比如远程计算机的 IP 地址和端口）

addrlen 是一个本地的整型数值，在它的地址传给 accept() 前 它 的 值 应 该 是sizeof(struct sockaddr_in)； accept()不会在 addr 中存储多余 addrlen bytes 大小的数据。如果accept()函数在 addr 中存储的数据量不足 addrlen，则 accept()函数会改变 addrlen 的值来反应这个情况 

当调用 accept() 的时候，大致过程如下：

1、有人从很远很远的地方尝试调用 connect()来连接你的机器上的某个端口（当然是你已经在 listen()的） 

2、他的连接将被 listen 加入等待队列等待 accept()函数的调用（加入等待队列的最多数目由调用 listen()函数的第二个参数 backlog 来决定） 

3、你调用 accept()函数，告诉他你准备连接

4、accept()函数将会返回一个新的套接字描述符，这个描述符就**代表了这个连接**

这时候你有了两个套接字描述符，返回给你的那个就是和远程计算机的连接，而第一个套接字描述符仍然在你的机器上原来的那个端口上 listen() 。这时候你**所得到的那个新的套接字描述符就可以进行 send()操作和 recv()操作了** 

##### send()

通过**连接的**套接字流进行通讯的函数

```c
#include <sys/types.h>
#include <sys/socket.h>
int send(int sockfd, const void *msg, int len, int flags);
```

sockfd 是代表你与远程程序连接的套接字描述符（也就是那个 accept() 函数返回的新的套接字）

msg 是一个指针，指向你想发送的信息的地址（例如：`char *msg = "Hello! World"` ，`msg`就是信息的地址）

len 是你想发送信息的长度

flags 发送标记。一般都设为 0

**注意：注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里**

##### recv()函数

```c
#include <sys/types.h>
#include <sys/socket.h>
int recv(int sockfd, void *buf, int len, unsigned int flags);
```

sockfd 是你要读取数据的套接字描述符（这个sockfd里面有请求头的信息）

buf 是一个指针，指向你能存储数据的内存缓存区域（把收到到的数据存到 buf 中 ）

len 是缓存区的最大尺寸

flags 是 recv() 函数的一个标志，一般都为 0

##### sendto() 和 recvfrom() 函数

这两个函数是进行**无连接的 UDP** 通讯时使用的

```c
#include <sys/types.h>
#include <sys/socket.h>
int sendto(int sockfd, const void *msg, int len, unsigned int flags, const struct sockaddr *to, int tolen);
```

to 是一个指向 struct sockaddr 结构的指针，里面包含了远程主机的 IP 地址和端口数据 

tolen 只是指出了 struct sockaddr 在内存中的大小 sizeof(struct sockaddr)

```c
#include <sys/types.h>
#include <sys/socket.h>
int recvfrom(int sockfd, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen);
```

from 是一个本地指针，指向一个 struct sockaddr 的结构（里面存有源 IP 地址和端口数） 

fromlen 是一个指向一个 int 型数据的指针，它的大小应该是 sizeof （ struct sockaddr）．当函数返回的时候， formlen 指向的数据是 form 指向的 struct sockaddr 的实际大小

##### close()和 shutdown()函数

程序进行网络传输完毕后，需要**关闭这个套接字描述符所表示的连接**：

```c
close(sockfd);
```

执行 close()之后，套接字将不会在允许进行读操作和写操作。任何有关对套接字描述符进行读和写的操作都会接收到一个错误 

```c
#include <sys/socket.h>
int shutdown(int sockfd, int how);
```

sockfd 是一个你所想关闭的套接字描述符

how 可以取下面的值：

 0 表示不允许以后数据的**接收操作**； 1 表示不允许以后数据的**发送操作**； 2 表示和 close()一样，不允许以后的**任何操作**（包括接收，发送数据）

### 10、五种 I/O 模式

一般来说，程序进行输入操作有两步：

1、等待有数据可以读

2、将数据从系统内核中拷贝到程序的数据区

对于一个套接字的输入操作，第一步一般是**等待数据从网络上传到本地**。当数据包到达的时候，数据将会从网络层拷贝到内核的缓存中；第二步是**从内核中把数据拷贝到程序的数据区中**

#### 阻塞 I/O（阻塞就是＂睡眠＂的同义词 ）

很多函数都可以阻塞。像 accept()函数是阻塞的，所有以 recv 开头的函数也都是阻塞的。它们这样做的原因是他们需要这样做 

大部分程序使用的都是阻塞模式的 I/O

一个套接字建立后所处于的模式就是阻塞 I/O 模式

对于一个 UDP 套接字来说，数据就绪的标志比较简单：

1、已经收到了一整个数据报

2、没有收到

对于 TCP 这个概念就比较复杂，需要附加一些其他的变量：

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11.PNG)

#### 非阻塞模式 I/O

当我们将一个套接字设置为非阻塞模式，我们相当于告诉了系统内核：“当我请求的I/O 操作不能够马上完成，你想让我的进程进行休眠等待的时候，不要这么做，请马上返回一个错误给我。”

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/12.PNG)

我们开始对 recvfrom 的三次调用，因为系统还没有接收到网络数据，所以内核马上返回一个 EWOULDBLOCK 的错误。第四次我们调用 recvfrom 函数，一个数据报已经到达了，内核将它拷贝到我们的应用程序的缓冲区中，然后 recvfrom 正常返回，我们就可以对接收到的数据进行处理了

当一个应用程序使用了非阻塞模式的套接字，它需要使用一个循环来测试是否一个文件描述符有数据可读（称做 polling）。**应用程序不停的 polling 内核来检查是否 I/O操作已经就绪。这将是一个极浪费 CPU 资源的操作**。这种模式使用中不是很普遍 

#### I/O 多路复用

在使用 I/O 多路技术的时候，我们调用 select()函数和 poll()函数，在调用它们的时候阻塞，而不是我们来调用 recvfrom（或 recv）的时候阻塞

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/13.PNG)

当我们调用 select 函数阻塞的时候， **select 函数等待数据报套接字进入读就绪状态**。**当select 函数返回的时候，也就是套接字可以读取数据的时候**。这时候我们就可以调用 recvfrom函数来将数据拷贝到我们的程序缓冲区中 

和阻塞模式相比较， select()和 poll()并没有什么高级的地方，而且，在阻塞模式下只需要调用一个函数：读取或发送，在使用了多路复用技术后，我们需要调用两个函数了：先调用 select()函数或 poll()函数，然后才能进行真正的读写。多路复用的高级之处在于，它**能同时等待多个文件描述符**，而这些文件描述符（套接字描述符）**其中的任意一个进入读就绪状态， select()函数就可以返回**

#### 信号驱动 I/O 模式

使用信号，让内核在文件描述符就绪的时候使用 SIGIO 信号来通知我们

使用这种模式，我们首先需要允许套接字使用信号驱动 I/O ，还要安装一个 SIGIO 的处理函数。在这种模式下，系统调用将会立即返回，然后我们的程序可以继续做其他的事情。当数据就绪的时候，系统会向我们的进程发送一个 SIGIO 信号。这样我们就可以在 SIGIO信号的处理函数中进行 I/O 操作（或是我们在函数中通知主函数有数据可读）

对于信号驱动 I/O 模式，它的**先进之处在于它在等待数据的时候不会阻塞**，程序可以做自己的事情。当有数据到达的时候，系统内核会向程序发送一个 SIGIO 信号进行通知，这样我们的程序就可以获得更大的灵活性，因为我们不必为等待数据进行额外的编码

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/14.PNG)

#### 异步 I/O 模式

当我们运行在异步 I/O 模式下时，我们如果想进行 I/O 操作，只需要告诉内核我们要进行 I/O 操作，然后内核会马上返回。具体的 I/O 和数据的拷贝全部由内核来完成，我们的程序可以继续向下执行。当内核完成所有的 I/O 操作和数据拷贝后，内核将通知我们的程序

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.PNG)

异步 I/O 和 信号驱动 I/O 的区别是：

1、信号驱动 I/O 模式下，内核在操作可以被操作的时候通知给我们的应用程序发送 SIGIO 消息 

2、异步 I/O 模式下，内核在**所有的操作都已经被内核操作结束之后**才会通知我们的应用程序 

#### 几种 I/O 模式的比较

![](http://oklbfi1yj.bkt.clouddn.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/16.PNG)























































































































































































































































