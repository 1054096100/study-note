## TCP 是三次握手，而不是两次或四次的原因

TCP作为一种可靠传输控制协议，其**核心思想**：既要保证数据可靠传输，又要提高传输的效率，而用**三次恰恰可以满足以上两方面的需求！**

**TCP可靠传输的精髓**：TCP连接的一方A，由操作系统动态随机选取一个**32位长的序列号（Initial Sequence Number），**假设A的初始序列号为1000，**以该序列号为原点，对自己将要发送的每个字节的数据进行编号**，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让**B有一个思想准备**，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。**如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达**

同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。

**一句话概括，TCP连接握手，握(可以理解为交流信息)的是啥？**

**通信双方数据原点的序列号！**

以此核心思想我们来分析二、三、四次握手的过程。

A <-------> B

**四次握手的过程：**

**1.1 **A 发送同步信号**SYN** + **A's Initial sequence number **

**1.2 **B 确认收到A的同步信号，并记录 A's ISN 到本地，命名 **B's ACK sequence number**
**1.3 **B发送同步信号**SYN** + **B's Initial sequence number **
**1.4 **A确认收到B的同步信号，并记录 B's ISN 到本地，命名 **A's ACK sequence number**

很显然1.2和1.3 这两个步骤可以合并，**只需要三次握手，**可以提高连接的速度与效率

**那么为什么在A发送确认信号给B之后，B不要给A发送确认信号呢？**

因为在1.2和1.3这步，B已经给A发送了确认信号，所以，就没有必要再确认了，否则会造成无限的确认循环


**二次握手的过程：**

**2.1 **A 发送同步信号**SYN** + **A's Initial sequence number **

**2.2** B发送同步信号**SYN** + **B's Initial sequence number** + **B's ACK sequence number**

这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，**A和B就B的初始序列号将无法达成一致**

于是TCP的设计者将**SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是）**，既然是一个字节的数据，按照**TCP对有数据的TCP segment 必须确认的原则**(TCP 握手的SYN并没有数据，但是SYN就意味着一个字节，对方必须要确认)，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号

有童鞋会说，如果A发给B的确认丢了，该如何？
A会超时重传这个ACK吗？不会！**TCP不会为没有数据的ACK超时重传**。

那该如何是好？**B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。**

**-------------------**
补充阅读：

**第一个包，即A发给B的SYN 中途被丢，没有到达B**

A会周期性超时重传，直到收到B的确认

**第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A**

B会周期性超时重传，直到收到A的确认

**第三个包，即A发给B的ACK 中途被丢，没有到达B**

A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：


a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。

b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的 Data。

c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据









