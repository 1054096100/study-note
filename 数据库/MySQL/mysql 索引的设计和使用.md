# mysql 索引的设计和使用

> MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构

索引用于快速找出**在某个列中有一特定值的行**。**不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行**。表越大，花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有数据

在MySQL中所有的类型数据列都可以被索引，对相关列使用索引是提高select操作性能的最佳途径

## **设计索引原则**

**1、最合适索引的列是经常出现在where子句中的列，或者连接子句中的列**

2、使用唯一索引，索引的列的基数越大(也就是说这个列的值的可选范围大)，索引效果越好，如存放生日的列具有不同的值，**很容易区分各个行**，**而记录性别的列，只含有“m”和“f”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会大约得出一半的行**(理解)

3、使用前缀索引，如果对一个字符串列进行索引，应该指定一个前缀长度

4、如果索引了多列（复合索引），要遵守最左前缀法则。所谓最左前缀，指的是查询从索引的最左前列开始，并且不跳过索引中的列，例如：

![](http://oklbfi1yj.bkt.clouddn.com/mysql%20%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/1.PNG)

​	第2条语句，使用索引失败，导致MySQL采用**ALL访问策略**，**即全表查询**.在开发中，应该尽量避免全表查询

**5、不要过多的使用索引**。**每一次的更新，删除，插入都会维护该表的索引**；更多的索引意味着也需要更多的空间 ；过小的表，建索引可能会更慢哦 ：） （举个生活中的例子：读个2页的宣传手册，你还先去找目录？）

6、对InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存，InnoDB表的普通索引都会保存主键的键值，所以**主键尽可能的选择较短的数据类型**

**7、索引列不应该作为表达式的一部分，即也不能在索引列上使用函数(否则索引会失效)**，例如：

![](http://oklbfi1yj.bkt.clouddn.com/mysql%20%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8/2.PNG)



# 存在索引但不能使用索引的典型场景



## like语句的索引问题

**以%开头的LIKE查询不能够利用B-Tree索引，例如：在like “value%”可以使用索引，但是like “%value%”不会使用索引，走的是全表扫描**。这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，对于业务需求，考虑使用MySQL全文索引，或者使用solr或者es是个不错的方案



## 数据类型出现隐式转换的时候也不会使用索引，特别是当列类型是字符串，那么一定记得在where条件中把字符常量值用引号引起来，否则即便这个列上有索引，MySQL也不会用到它



## 符合索引的情况下

假如查询条件不包含索引列最左边部分，即不满足最左边原则Leftmost，是不会使用复合索引的



## 用or分割开的条件

如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。因为or后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加I/O访问，一次全表扫描过滤条件就足够了