# 打造扛得住的MySQL数据库架构

## 1、B+树索引和Hash索引

### 在什么情况下可以用到B+树索引

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/1.png)

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/2.png)

### B+树的使用限制

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/3.png)

### 哈希索引

#### 哈希索引的特点

InnoDB的哈希索引不是我们自己来建立的，而是InnoDB储存引擎自己建立的，所以也称为自适应哈希索引。

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/4.png)

#### 哈希索引的限制

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/5.png)

### 为什么使用索引

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/6.png)

### 索引会带来的性能损耗

- 索引会增加写操作的成本

  由于我们在进行数据更新、插入、删除操作的同时必须**要对相关的索引进行维护**，所以索引越多，修改数据所需要的时间就越长。为了解决这个问题，InnoDB储存引擎引入了插入缓存，可以把多次插入合并成一次。

- 太多的索引会增加查询优化器的选择时间

  也就是说，**过多的索引也会影响读的性能**。因为查询优化器会根据索引的统计信息和查询条件来为查询**选择合适的索引**（也就是说对同一个查询有很多索引可以使用，查询优化器需要分析的时间就越多，从而也会影响查询效率）。

## 2、索引优化策略

### 索引列上不能使用表达式或函数

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/7.png)

要想使用索引，可以改写为：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/8.png)

### 前缀索引和索引列的选择性

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/9.png)

### 联合索引

#### 如何选择索引列的顺序

- 经常会被使用到的列优先

  如果我们会频繁的使用每一个列，我们需要把这个列放在联合索引的最左边。

- 选择性高的列优先

  选择性高的列往往意味着可以过滤掉更多的数据。

- 宽度小的列优先

  宽度越小，也就意味着一页可以存储的索引也就越多。也就意味着使用索引的时候，IO操作次数就越小，所以也就加快了查找效率。

### 覆盖索引

#### 优点

- 可以优化缓存，减少磁盘IO操作。

- 可以减少随机IO，变随机IO操作为顺序IO操作。

- 可以避免对InnoDB主键索引的二次查询。

- 可以避免MyISAM表进行系统调用。

  因为对于MyISAM储存引擎来说，它只会缓存索引的信息，数据则是要依赖操作系统来缓存，因此如果我们要访问数据，则要进行一次系统调用，而系统调用的性能通常会比较差。所以，如果能够通过索引来获得全部所需要的数据，则可以避免系统调用的产生。

#### 无法使用覆盖索引的情况

- 有的储存引擎不支持覆盖索引

- 不是所有的索引都可以建立覆盖索引

  只有在索引的叶子节点包括了键值的索引，才能建立覆盖索引。所以哈希索引就不能作为覆盖索引来使用。

- 查询中使用了太多的列

  覆盖索引之所以能够提高查询效率，主要是因为索引的大小要比行的大小小的多，如果索引本身很大，那么就没有使用覆盖索引的必要了。特别是对于`select * `这样的查询，因为查询了表中的所有列，所以不可能有索引覆盖到所有的列。

- 使用了双`%`号的`like`查询

### 使用索引来优化查询

#### 使用索引扫描来优化排序

- ORDER BY 中所有的列必须包含在相同的索引（联合索引）


- 索引的列顺序（指的是联合索引）和Order By子句的顺序完全一致

- 索引中所有列的排序方向（升序，降序）和Order by子句完全一致

  也就是说，混合使用ASC模式和DESC模式则不使用索引。

- Order by中的字段全部在关联表中的第一张表中

- where 语句与ORDER BY语句组合满足最左前缀

#### 模拟Hash索引优化查询

MySQL对于B+树索引的长度是有限制的。如果我们想要在一个很长字符串（例如`varchar(255)`）上进行查找，就只能使用前缀索引。但是这样就会使得索引列键值的可选择性很差。要解决这个问题，可以使用Hash索引。但是，并不是所有的储存引擎都支持Hash索引。此时，我们可以**通过B+树索引来模拟Hash索引**。

举个例子：

假设表film中有一个字段是一个很长的字符串类型：

```mysql
`title` varchar(255) NOT NULL,
KEY `idx_title` (`title`)
```

因为InnoDB储存引擎是不能够人为的去建立Hash索引。所以我们可以在表中新加一个列：

```mysql
alter table film add title_md5 char(32);
```

然后为表film的每条记录增加字段`title_md5`的值：

```mysql
update film set title_md5 = md5(title);
```

因为我们要使用B+树索引来模拟Hash索引，所以，我们还需要为这个`title_md5`列建立一个索引：

```mysql
create index idx_md5 on film(title_md5);
```

接下来，使用这个B+树索引来模拟Hash索引：

```mysql
explain select * from film where title_md5 = md5('EGG IGBY') and title = 'EGG IGBY'\G
```

会得到如下结果：

```
Extra: Using index condition; Using where
```

也就是说，使用了索引，也使用了where来进行过滤。

##### 局限性

- 和Hash索引一样，只能处理键值的**全值匹配**查找

- 所使用的Hash函数决定着索引键的大小

  如果我们使用的Hash函数生成的Hash值太大，就会造成索引比较大的情况。所以我们需要选取合适的Hash函数，既不能使生成的Hash值太大，也不能造成太多的Hash冲突。

既要在`title_md5`上做过滤也要在`title`上做过滤的原因：

为了避免Hash冲突的出现。因为只对`title_md5`做过滤掉，那么很可能得不到我们真正想要的结果（因为不同的key可能得到的Hash值相同）。

### 利用索引优化锁

InnoDB储存引擎使用的是行级锁，只有在修改行时才会对需要的行加锁。但是只有在InnoDB储存引擎层可以过滤掉不需要的行时，这种情况（指的是加锁）才会有效。如果储存引擎层不可以过滤掉我们不需要的行，则需要**锁定所有行**然后**在内存中**通过where条件来**进行过滤**。所以通过**使用索引我们可以减少锁定的行数**。

- 索引可以减少锁定的行数

- 索引可以加快处理速度，同时也加快了锁的释放

  因为我们只需要对很少的行进行处理，而不需要把所有数据都加载到内存中再进行过滤，所以使得数据在查询过程中锁定更少的行。因此也**增加了数据处理的并发性**，从而提升了数据库的性能。同时也会加快锁的释放速度。

  判断是否把数据加载到内存中再进行过滤的方法：

  使用`explain`，看Extra字段的值是否是`Using where`，如果是，则说明把数据加载到了内存中再进行过滤的。

### 索引的维护和优化

MySQL允许在相同的列上建立多个索引，MySQL需要单独的维护这些索引，并且在优化器优化查询的过程中，还要逐个对这些索引来进行选择，这无疑会影响数据库的性能。因此我们需要删除重复和冗余的索引。

#### 删除重复和冗余的索引

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/10.png)

#### 更新索引统计信息以及减少索引碎片

## 3、SQL查询优化

### 如何获取有性能问题的SQL

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/11.png)

#### 使用慢查询日志获取有性能问题的SQL

这种方式性能的主要开销是：磁盘IO和存储日志做需要的磁盘空间。

对于磁盘IO来说，由于写日志是顺序存储的，所以其开销可以忽略不计。所以使用这种方式我们所需要关心的**主要问题是储存日志所需要的大量的磁盘空间**。

##### 常用的慢查询日志分析工具

mysqldumpslow

可以汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。

例如：

```shell
mysqldumpslow -s r -t 10 slow-mysql.log
```

`-s`后面跟的参数指的是结果按照哪种排序方式输出，有如下几种：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/12.png)

`-t`后面跟的选项指定取前几条作为结果输出。

### 特定SQL的查询优化

#### 对于大表数据的修改

最好要分批处理。

例如，我们要在1000万行记录的表中删除/更新100万行记录。我们最好分成多个批次来删除/更新。例如，一次只删除/更新5000行记录。

并且为了减少对主从复制同步的压力，我们在每次修改数据之后，可以暂停几秒，给主从复制集群提供同步数据的时间。

#### 如何修改大表的表结构

对表中的列的字段类型进行修改、改变字段的宽度时还是会**锁表**。无法解决主从数据库延迟的问题。所以必须使用一些特殊的方法来对大表的表结构进行修改。

##### 方法一

利用主从复制服务器的架构，先在从服务器上进行修改，然后再进行主从切换，最后再在原来的主服务器上进行修改。

使用这种方法，因为要进行主从服务器的切换，所以还是存在一定的风险。

##### 方法二

在主服务器上建立一个新的表，这个新表的结构就是原来的表修改之后的结构。然后再把老表的数据导入到新表中，并且在老表上建立一系列的触发器，把老表数据的修改也同步到新表中。当老表和新表的数据同步后，再对老表加一个排它锁，再重新命名新表名字（与老表同名），最后再删除老表。

这种方法可以尽量减少主从延迟以及可以在重命名之前不用加任何的锁，只需要在重命名的时候，加一个短暂的锁。

#### 如何优化 not in 和 < > 查询

例子：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/13.png)

这里使用 not in ，就需要**对customer表中的每一个customer_id到payment表中去查询**看是否有缴费记录。所以会多次对payment表进行查询。所以这时候可以采用连接查询进行优化。

如下：

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/14.png)

采用这种方式，可以避免对payment表进行多次查询。

#### 使用汇总表优化查询

![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/15.png)

## 4、数据库分库分表的几种方式

虽然主从复制可以减轻主数据库读的压力，但是当主数据库很大的时候，主数据库写的压力也会很大。

### 方式1

- 把原来单一的主数据库服务器中的多个数据库拆分到不同的物理服务器中的数据库实例中去。

  在一个MySQL实例中，可能包含多个逻辑数据库。

  ![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/16.png)

  这种方式有一个问题：如果压力的写压力主要集中在订单这个数据库，那么这样拆分效果不是很大。

### 方式2

- 把一个库中的表分离到不同的数据库中

  一个数据库中往往来说会有很多的表，这些表通常会记录不同的主题中的数据。例如：

  ![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/17.png)

  如果我们发现对于这个数据库的主要写压力来源于订单表和购物车，这个时候，我们就可以单独的把这两张表拆分到不同的数据库节点中：

  ![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/18.png)

  这样拆分后，每一个数据库节点实际上承担的知识原来的数据库中的一部分写压力。这样就可以达到减轻原有数据库写负载的目的。

  使用这种方式在一定的时间内可以解决我们的问题，但是如果随着我们业务的进一步发展，这时候我们又发现订单表又出现了写压力的问题。这时候就需要对表进行水平拆分。

### 方式3

- 对一个库中的相关表进行**水平拆分**到不同实例的数据库中。也就是对数据库进行分片处理。

  我们通常所说的分库分表在大多数情况下指的就是这种方式。这和MySQL的分区表有些类似，不同的是**MySQL的分区表是在同一个节点上的同一个数据库中建立的**。而**数据库分片后通常是存放在不同的物理节点上**。

  不到万不得已，不建议对数据库进行分片。数据库分片后会变得难以维护。

  ![](http://oklbfi1yj.bkt.clouddn.com/%E6%89%93%E9%80%A0%E6%89%9B%E5%BE%97%E4%BD%8F%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/19.png)

### 如何选择分区键

- 分区键要尽量**避免跨分片查询的发生**
- 分区键要尽量**使各个分片中的数据平均**

### 如何储存无需分片的表

- 每个分片中储存一份相同的数据
- 使用额外的节点统一存储

### 如何在节点上部署分片

- 每个分片使用单一数据库，并且数据库名也相同
- 将多个分片表储存在一个数据库中，并在表名上加入分片号后缀
- 在一个节点中部署多个数据库，每个数据库包含一个分片

### 如何分配分片中的数据

- 按分区键的Hash值取模来分配分片数据
- 按分区键的范围来分配分片数据
- 利用分区键和分片的映射表来分配分片数据

### 如何生成全局唯一ID

- 使用auto_increment_increment和auto_increment_offset参数
- 使用全局节点来生成ID
- 在Redis等缓存服务器中创建全局ID



























