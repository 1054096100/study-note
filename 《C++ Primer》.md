# 《C++ Primer》

## 1、标准库string类型

使用`cin`方式来输入字符串，这个字符串里面是不会包含空格的。在前面的空格会被忽略。后面遇到空格，则会被当作结束。例如在终端输入（引号不是输入的，只是为了凸显前面的空格和后面的结尾）：

```shell
"    Hello World"
```

那么，实际上得到的将会是如下字符串：

```shell
"Hello"
```

### string对象的操作

#### empty()

判断s是否为空串

#### size()

返回s中字符的个数

这个函数的返回值类型是`size_type`类型的值。`string`类类型和许多其他库类型都定义了一些配套类型。**通过这些配套类型，库类型的使用就能与机器无关**。`size_type`就是这些配套类型中的一种。

`size_type`定义为与`unsigned`型（`unsigned int`或`unsigned long`）具有相同的含义，而且可以保证足够大能够存储任意`string`对象的长度。

任何存储`string`的`size()`操作结果的变量必须为`string::size_type`类型（size_type前面不要漏了string::）。不要把`size()`的返回值赋给一个`int`变量（虽然不一定会报错，因为可能没有溢出）。

在对`string`对象中的每个字符做遍历的时候，也最好使用`string::size_type`类型：

```c++
for (string::size_type i = 0; i < s.size(); i++) {
    cout<<s[i];
}
```

#### s[n]

返回s中位置为n的字符（位置从0开始计数）

#### s1 + s2

把s1和s2连接成一个新的字符串，返回新生成的字符串

#### s1 == s2（区分大小写）

比较s1和s2的内容是否相等

## 2、标准库vector类型

### vector对象动态增长

vector对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。因为vector增长的效率高，在元素已知的情况下，最好是动态地添加元素。

虽然可以对给定元素个数的vector对象预先分配内存：

```c++
vector<T> v4(n); // v4含有值初始化的元素的 n 个副本
```

但更有效的方法是先初始化一个空vector对象，然后再动态地增加元素。

### vector对象的操作

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8AC++%20Primer%E3%80%8B/1.PNG)

#### size()

与string的size()函数类似，返回相应vector类定义的size_type的值。

```c++
vector<int>::size_type; // 正确
vector::size_type; // 错误
```

#### push_back()

插入（push）到vector对象的后面（back）

#### 下标操作不添加元素

指的是下标操作不会在vector对象的后面插元素。必须是已存在的元素才能用下标操作符进行索引。通过下标操作进行赋值时，不会添加任何元素。

试图对不存在的元素进行下标操作是程序设计过程中经常会犯的严重错误。**所谓的“缓冲区溢出”错误就是对不存在的元素进行下标操作的结果**。

## 3、迭代器

除了使用下标来访问vector对象的元素外，标准库还提供了另一种访问元素的方法：使用迭代器。

标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。

#### begin()和end()操作

每种容器都定义了一对命名为begin和end的函数，用于返回迭代器。

由end()操作返回的迭代器指向vector的“末端元素的下一个”。通常称为超出末端迭代器，表明指向一个不存在的元素。**如果vector为空，begin()和end()返回的迭代器相同**。

由**end()操作**返回的迭代器并不指向vector中任何实际的元素，相反，它只是**起一个哨兵的作用**，表示我们已处理完vector中所有的元素。

#### 迭代器的算术操作

除了对迭代器进行自增和自减外，也可以支持其他的算术操作：

```c++
iter + n; // 其位置在iter所指元素之后n个元素的位置
iter - n; // 其位置在iter所指元素之前n个元素的位置
```

加或减之后的结果必须指向iter所指vector中的某个元素，或者是vector末端元素的下一个。加上或减去的值的类型应该是vector的size_type或difference_type类型。

```c++
iter1 - iter2; // 计算两个迭代器对象的距离
```

任何改变vector长度的操作都会使已存在的迭代器失效。例如，在调用push_back之后，就不能再信赖指向vector的迭代器的值了。

## 4、顺序容器

### 顺序容器类型

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8AC++%20Primer%E3%80%8B/2.PNG)

### 容器的容器

因为容器受容器元素类型的约束，所以可定义元素是容器类型的容器。例如：

```c++
vector< vector<string> > lines; // 容器的容器
```

**必须用空格隔开两个相邻的`>`符号**，以示这是两个分开的符号，否则系统会认为`>>`是单个符号，为右移操作符，并导致编译时错误。

### vector和deque容器的迭代器提供额外的运算

C++定义的容器类型中，只有vector和deque容器提供下面两种重要的运算集合：迭代器算术运算（==和!=这两种关系运算适用于所有容器）：

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8AC++%20Primer%E3%80%8B/3.PNG)

关系操作符只适用于vector和deque容器，这是因为只有这两种容器为其元素提供快速、随机的访问。它们确保可根据元素位置直接有效地访问指定的容器。这两种容器都支持通过元素位置实现的随机访问，因此它们的迭代器可以有效地实现算术和关系运算。

而**其他的容器只提供前置和后置的自增、自减运算以及相等（不等）运算**。

### 迭代器范围

因为end指向的是最后一个元素的下一个位置，所以，如果begin和end两个迭代器相等，则迭代器范围为空。此类元素范围称为左闭合区间：[begin, end)

#### 使用左闭合区间的编程意义

因为：

1、当begin与end相等，迭代器范围为空。

2、当begin与end不相等，迭代器范围内至少有一个元素，而且begin指向该区间中的第一个元素。此外，通过若干次自增运算可以使begin的值不断增大，直到begin=end为止。

由上面的两条性质，可以安全地编写如下循环，处理范围内的每一个元素：

```c++
while (begin != last) { // 意味着迭代器范围内还有元素
    ++begin;
}
```

### begin和end成员

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8AC++%20Primer%E3%80%8B/4.PNG)

### 容器元素都是副本

在容器中添加元素时，系统是将元素值复制到容器里面。类似地，使用一段元素初始化新容器时，新容器存放的是原始元素的副本。**被复制的原始值与新容器中的元素各不相关**，此后，容器内元素值发生变化，被复制的原值不会受到影响，反之亦然。

### 删除元素

![](http://oklbfi1yj.bkt.clouddn.com/%E3%80%8AC++%20Primer%E3%80%8B/5.PNG)

## 5、关联容器

关联容器共享大部分--但并非全部--的顺序容器操作。关联容器不提供front、push_front、pop_front、back、push_back以及pop_back操作。

**关联容器不能通过容器大小来定义**，因为这样的话，就无法知道键所对应的值是什么。

### pair类型

#### p.first

```c++
p.first // 返回p中名为first的（公有）数据成员
```

#### p.second

```c++
p.second // 返回p的名为second的（公有）数据成员
```

#### pair对象的操作

对于pair类，可以直接访问其数据成员：其成员都是公有的，分别命名为first和second。只需使用普通的点操作符。

#### 生成一个新的pair对象

使用`make_pair`函数，由传递给它的两个实参生成一个新的pair对象。

```c++
pair<string, string> next_auth;
string first, last;
while (cin >> first >> last) {
    next_auth = make_pair(first, last);
    // process next_auth...
}
```

### map类型

它的值会自动初始化为1。

map是键-值对的集合。map类型通常可理解为关联数组：可使用键作为下标来获取一个值。

#### 键类型的约束

在使用关联容器时，它的键不但有一个类型，而且还有一个相关的比较函数。默认情况下，**标准库使用键类型定义的`<`操作符来实现键的比较**。

**对于键类型，唯一的约束就是必须支持 < 操作符，至于是否支持其他的关系或相等运算，则不作要求。**

#### map定义的类型

![](http://oklbfi1yj.bkt.clouddn.com/C++%20Primer/6.PNG)

可以用`value_type`来创建一个pair对象：

```c++
map<string, int>::value_type("Anna", 1); // 和make_pair("Anna", 1)的效果是一样的
```

谨记`value_type`是`pair<const K, V>`类型的同义词。K为键类型，而V是键所关联的值类型。

map迭代器进行解引用将产生pair类型的对象。它的first成员存放键，为const类型（只读），而second成员则存放值。

#### 给map添加元素

可以使用insert成员函数实现；或者，先用下标操作符（这个下标原先可以是不存在的）获取元素，然后给获取的元素赋值。

#### 使用下标访问map对象

```c++
map<string, int> word_count; // 空的map
word_count["Anna"] = 1; // 插入一个叫做Anna的键；然后分配1给它
```

将发生以下事情：

（1）在word_count中查找键为Anna的元素，没有找到。

（2）将一个新的键-值对插入到word_count中。它的键是const string类型的对象，保存Anna。而它的值则采用值初始化，这就意味着在本例中值为0。

（3）将这个新的键-值对插入到word_count中。

（4）**读取新插入的元素**，并将它的值赋为1。

 使用下标访问map与使用下标访问数组或vector的行为截然不同：**用下标访问不存在的元素将导致在map容器中添加一个新的元素，它的键即为该下标值**。

#### 检测insert的返回值

map对象中一个给定键只对应一个元素。**如果试图插入的元素所对应的键已在容器中，则insert将不做任何操作**。

带有一个键-值pair形参的insert版本将返回一个值：包含一个迭代器和一个bool值的pair对象，其中迭代器指向map中具有相应键的元素，而bool值则表示是否插入了该元素。**如果该键已在容器中，则其关联的值保持不变，返回bool值为false；如果该键不在容器中，则插入新元素，且bool值为true**。在这两种情况下，迭代器都将指向具有给定键的元素。

#### 查找并读取map中的元素

下标操作符给出了读取一个值的最简单的方法：

```c++
map<string, int> word_count;
int occurs = word_count["foobar"];
```

但是，**使用下标存在一个很危险的副作用**：如果该键不在map容器中，那么下标操作会插入一个具有该键的新元素。

map容器提供了两个操作：count和find：

![](http://oklbfi1yj.bkt.clouddn.com/C++%20Primer/7.PNG)

在执行count后在使用下标操作符，实际上是对元素作了两次查找。如果希望当元素存在时就使用它，则应该用find操作。

#### map对象的迭代遍历

与其他容器一样，map同样提供begin和end运算，以生成用于遍历整个容器的迭代器。

```c++
map<string, int>::const_iterator map_it = word_count.begin();
while (map_it != word_count.end()) {
	cout<<map_it->first<<"occurs"
	    <<map_it->second<<"times"<<endl;

	++map_it;
}
```

可以**对map的迭代器使用自增**来遍历。

### set类型

map容器是键-值对的集合，而**set容器只是单纯的键的集合**。

set类型不支持下标操作符，而且没有定义`mapped_type`类型。在set容器中，`value_type`不是pair类型，而是与`key_type`相同的类型。它们指的都是set中存储的元素类型。**与map一样，set容器存储的键也必须唯一，而且不能修改（即set中的键是只读的）。**

#### 给set添加元素

与map容器的操作一样，带有一个键参数的insert版本返回pair类型对象，包含一个迭代器和一个bool值，迭代器指向拥有该键的元素，而bool值表明是否添加了元素。

## 6、泛型算法

**泛型算法本身从不执行容器操作**，只是单独依赖迭代器和迭代器操作实现。算法基于迭代器及其操作实现，而并非基于容器操作。正如我们看到的，算法也许会改变存储在容器中元素的值，也许会在容器内移动元素，但是，算法从不直接添加或删除元素。

### 只读算法

#### 拼接字符串

```c++
string sum = accumulate(v.begin(), b.end(), string(""));
```

作用：以第三个参数为起点，把v里面的每个元素连接成一个字符串。注意：程序显示地创建了一个string对象，用作该函数调用的第三个实参。如果第三个参数传递的是一个字符串字面值：

```c++
string sum = accumulate(v.begin(), b.end(), "");
```

将会导致编译错误。因为，累加和的类型将是`const char*`。

### 写容器元素的算法

一些算法写入元素值。在使用这些算法写元素时要当心，必须确保算法所写的序列至少足以存储要写入的元素。

#### 不检查写入操作的算法

```c++
vector<int> vec; // 空的vector容器
fill_n(vec.begin(), 10, 0); // 尝试写入10个元素到vec里面
```

因为这10个元素并不存在，这样写入很可能导致严重的运行时错误。

#### 引入back_inserter

```c++
vector<int> vec; // 空的vector容器
fill_n(back_inserter(vec), 10, 0); // 追加10个元素到vec中
```

现在，fill_n函数没写入一个值，都会通过back——inserter生成的插入迭代器实现。效果相当于在vec上调用push_back，在vec末尾添加10个元素，每个元素的值都是0。

## 7、类

### 类的定义和声明

#### 成员函数

在类内部，声明成员函数是必须的，而定义成员函数则是可选的。在类内部定义的函数默认为**inline**。

在类外部定义的成员函数必须指明它们是在类的作用域中。（因为不同的类它们可能会有同名的函数）

将关键字**const**加在形参表之后，就可以将成员函数声明为常量：

```c++
double avg_price() const;
```

**const成员不能改变其所操作的对象的数据成员**。**const必须同时出现在声明和定义中**，若只出现在其中一处，就会出现一个编译时错误。

#### 使用类型别名来简化类

除了定义数据和函数成员之外，类还可以定义自己的局部类型名字。例如：

```c++
class Screen {
public:
    typedef std::string::size_type index;
private:
    std::string contents;
    index cursor;
    index height, width;
};
```

#### 显示指定inline成员函数

在类内部定义的成员函数，将自动作为inline处理。也就是说，当它们被调用时，编译器将试图在同一行内扩展该函数。也可以显式地将成员函数声明为inline。

可以在类定义体内部指定一个成员为inline，作为其声明的一部分。或者，也可以在类定义体外部的函数定义上指定inline。在声明和定义处指定inline都是合法的。在类的外部定义inline的一个好处是可以使得类比较容易阅读。

#### 类声明与类定义

一旦定义了类，那么就知道了所有的类成员，以及**存储该类的对象所需的存储空间**。

可以声明一个类而不定义它：

```c++
class Screen;
```

#### 为类的成员使用类声明

只有当类定义已经在前面出现过，数据成员才能被指定为该类类型。**如果该类类型是不完全类型，那么数据成员只能是指向该类类型的指针或引用**。

因为，只有当类定义体后成后才能定义类，因此**类不能具有自身类型的数据成员**。然而，只要类名一出现就可以认为该类已声明。因此，**类的数据成员只能是指向自身类型的指针或引用**：

```c++
class LinkScreen {
    Screen window;
    LinkScreen* next;
    LinkScreen* prev;
};
```

### 类作用域

每个类都定义了自己的新作用域和唯一的类型。在类的定义体内声明类成员，将成员名引入类的作用域。两个不同的类具有两个不同的类作用域。

#### 使用类的成员

在类的作用域之外，成员只能通过对象或指针分别使用成员访问操作符`.`或`->`来访问。这些操作符左边的操作数分别是一个类对象或指向类对象的指针：

```c++
Class obj; // Class is some class type
Class* ptr = &obj;
ptr->member;
obj.member;
ptr->memfcn();
obj.memfcn();
```

#### 函数返回类型不一定在类作用域中

当返回类型出现在成员名字前面。如果函数在类定义体之外定义，则用于返回类型的名字在类作用域之外。如果返回类型使用由类定义的类型，则必须使用完全限定名。例如：

```c++
class Screen {
public:
    typedef std::string::size_type index;
    index get_cursor() const;
};
inline Screen::index Screen::get_cursor() const {
    return cursor;
}
```

该函数的返回类型是index，这是在Screen类内部定义的一个类型名。如果在类定义体之外定义get_cursor，则在函数名被处理之前，代码不在类作用域内。当看到返回类型时，其名字是在类作用域之外使用。必须用完全限定的类型名Screen::index来指定所需要的index是在类Screen中定义的名字。

### 隐含this指针

如果class类是一座房子，this就好比一把钥匙，通过钥匙来打开了这座房子的门，那么里面的东西就随意你取用了。

只要类对象调用一个成员函数，编译器即会自动用该对象的地址初始化this指针，因此在成员函数内部，可以直接使用“调用该成员函数的类对象”的成员，而无需再使用成员访问运算符。

this指针是指向实例化对象本身时候的一个指针，里面存储的是对象本身的地址，通过该地址可以访问内部的成员函数和成员变量。

##### 为什么需要this

因为this作用域是在类的内部，自己声明一个类的时候，还不知道实例化对象的名字，所以用this来使用对象变量的自身。**在非静态成员函数中，编译器在编译的时候加上this作为隐含形参**，通过this来访问各个成员（即使你没有写上this指针）。例如：

```c++
/* 假设有一个Point类 */
void MovePoint( int a, int b);
/* 等价于 */
void MovePoint(Point *this, int a, int b);
```

##### this的使用

1)在类的非静态成员函数中**返回对象的本身**时候，直接用return *this（**常用于操作符重载和赋值、拷贝等函数**）。

2)**传入函数的形参与成员变量名相同时，例如：this->n = n (不能写成n=n)**

### 构造函数

构造函数的名字与类的名字相同，并且**不能指定返回类型**。

#### 构造函数自动执行

只要创建该类型的一个对象，编译器就**运行一个**构造函数（因为构造函数可以被重载）。

#### 有时需要参数初始化列表

**可以初始化const对象或引用类型的对象，但不能对它们赋值**。在开始执行构造函数的函数体之前，要完成初始化。初始化const或引用类型数据成员的唯一机会是在构造函数的参数初始化列表中。

#### 成员初始化的次序

构造函数参数初始化列表仅指定用于初始化成员的值，并不指定这些初始化执行的次序。成员被初始化的次序就是定义成员的次序。第一个成员首先被初始化，然后是第二个，以此类推。

**初始化的次序常常无关紧要。然而，如果一个成员是根据其他成员而初始化，则成员初始化的次序是至关重要的。**例如：

```c++
class X {
    int i;
    int j;
public:
    X(int val): j(val), i(j) {}
};
```

此时，构造函数的参数初始化列表看起来似乎是用val初始化j，然后用j来初始化i。然而，i首先本初始化。**这个初始化列表的效果是用尚未初始化的j值来初始化i**。

> 按照与成员声明一致的次序编写构造函数参数初始化列表是个好主意。此外，尽可能避免使用成员来初始化其他成员。

#### 默认构造函数

只要定义一个对象没有提供初始化式，就使用默认构造函数。为所有形参提供默认实参的构造函数也定义了默认构造函数。

一个类哪怕只定义了一个构造函数，编译器也不会再生成默认构造函数。只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。

#### 隐式类类型转换（不懂）

```c++
#include <string>
#include <iostream>
using namespace std;
class Fruit { // 定义一个类，名字叫Fruit
private:
    string name;     //定义一个name成员           
    string colour;   //定义一个colour成员

public:
    bool isSame(const Fruit &otherFruit) { // 期待的形参是另一个Fruit类对象，测试是否同名
        return name == otherFruit.name;
    }
    
    void print() { // 定义一个输出名字的成员print()
        cout<<colour<<" "<<name<<endl;
    }

    Fruit(const string &nst, const string &cst = "green") : name(nst), colour(cst){}  //构造函数

    Fruit() {}
};

int main(int argc, char const *argv[]) {
    Fruit apple("apple");
    Fruit orange("orange");

    cout<<"apple = orange ?: "<<apple.isSame(orange)<<endl; // 没有问题，肯定不同
    cout<<"apple = \"apple\" ?:"<<apple.isSame(string("apple")); // 用一个string做形参？
 
    return 0;
}
```

在第二次调用`isSame()`，我们用一个string类型作一个本来期待Fruit类形参的函数的参数，结果竟然得出了是true（1），不要感到奇怪，这就是我现在要讲的东西，隐式类类型转换：“可以用单个实参来调用的构造函数定义了从形参类型到该类型的一个隐式转换。”《C++ Primer》首先要单个实参，你可以把构造函数colour的默认实参去掉，也就是定义一个对象必须要两个参数的时候，源代码不能通过编译。然后满足这个条件后，系统就知道怎么转换了，不过这里比较严格：）在上面，我们构造对象的时候Fruit apple("apple")其实也已经有了一个转换，从const char *的C字符串格式，转为string，在这里，你再apple.isSame("apple")的话，**蠢系统不懂得帮你转换两次，所以你必须要用string（）来先强制转换，然后系统才知道帮你从string隐式转换为Fruit**，当然其实你自己也可以帮他完成。cout<<"apple = /"apple/" ?:"<<apple.isSame(Fruit("apple"));这样。参考例子1.2 ：Fruit apple = Fruit("apple");  //定义一个Fruit类对象apple。也就是这样转换的。不过这就叫显式转换了，我们不标出来，系统帮我们完成的，叫隐式的贝。这里要说的是，假如你显示转换就可以不管有多少参数了，比如在前面提到的必须需要两个参数的构造函数时的例子。

#### 类成员的显示初始化

尽管大多数对象可以通过运行适当的构造函数进行初始化，但是直接初始化简单的非抽象类的数据成员仍是可能的。对于**没有定义构造函数**并且**其全体数据成员均为public**的类，可以采用与初始化数组元素相同的方式初始化其成员。

### 友元

在某些情况下，允许特定的非成员函数访问一个类的私有成员，同时仍然阻止一般的访问，这是很方便做到的。例如，被重载的操作符，如输入或输出操作符，经常需要访问类的私有数据成员。这些操作符不可能为类的成员。尽管不是类的成员，它们仍是类的“接口的组成部分”。

友元机制允许一个类对其公有成员的访问权授予指定的函数或类。友元的声明以关键字friend开始。它只能出现在类定义的内部。友元声明可以出现在类中的任何地方：**友元不是授予友元关系的那个类的成员**，所以它们不受其声明出现部分的访问控制影响。

**通常，将友元声明成组地放在类定义的开始或结尾**是个好主意。

#### 友元函数

友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。

```c++
#include <iostream>  
  
using namespace std;  
  
class A  
{  
public:  
    friend void set_show(int x, A &a);      //该函数是友元函数的声明  
private:  
    int data;  
};  
  
void set_show(int x, A &a)  //友元函数定义，为了访问类A中的成员（可以看出，这个函数只是一个普通的函数，不属于任何类）
{  
    a.data = x;  
    cout << a.data << endl;  
}  
int main(void)  
{  
    class A a;  
  
    set_show(1, a); // 可以看到，这个函数没有通过对象或者类来调用，所以，它不属于类A 
  
    return 0;  
}
```

#### 友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。

关于友元类的注意事项：

(1) **友元关系不能被继承**。
(2) **友元关系是单向的，不具有交换性**。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
(3) **友元关系不具有传递性**。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。

```c++
#include <iostream>
  
using namespace std;

class A
{
public:
    friend class C;                         //这是友元类的声明  
    void print() { cout << data << endl; }
private:
    int data;
};
  
class C             //友元类定义，为了访问类A中的成员  
{
public:
    void set_show(int x, A &a) { a.data = x; }
};
  
int main(void)
{
    class A a;
    class C c;
  
    c.set_show(1, a);
    a.print();
  
    return 0;
}
```

#### 友元成员函数

使类B中的一些成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员了。

当用到友元成员函数时，**需注意友元声明和友元定义之间的相互依赖**，在下面的例子中，类B必须先定义，否则类A就不能将一个B的函数指定为友元。然而，只有在定义了类A之后，才能定义类B的该成员函数。

更一般的讲，**必须先定义包含成员函数的类，才能将成员函数设为友元**。另一方面，不必预先声明类（比如友元类的那个例子中，类A设定的友元类C是在声明类C之前就设定好了的）和非成员函数（比如友元函数的那个例子中，类A设定的友元函数`set_show`是在声明`set_show`之前就设定好了的）来将它们设为友元。

```c++
#include <iostream>
  
using namespace std;
  
class A;    //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类A的声明  
class B
{
public:
    void set_show(int x, A &a);             //该函数是类A的友元函数  
};
  
class A
{
public:
    friend void B::set_show(int x, A &a);   //该函数是友元成员函数的声明  
    void show() { cout << data << endl; }
private:
    int data;
};
  
void B::set_show(int x, A &a)       //只有在定义类A后才能定义该函数，毕竟，它被设为友元是为了访问类A的成员  
{
    a.data = x;
    cout << a.data << endl;
}
  
int main(void)
{
    class A a;
    class B b;
  
    b.set_show(1, a);
    a.show();
  
    return 0;
}
```

### static类成员

#### static成员函数

**static成员函数没有this形参**，它可以直接访问所属类的static成员，但不能直接使用非static成员。因为static成员不是任何对象的组成部分，所以**static成员函数不能被声明为const**。毕竟，将成员函数声明为const就是承诺不会修改该函数所属的对象。最后，**static成员函数也不能声明为虚函数**。

#### static数据成员

static数据成员可以声明为任意类型，可以是常量、引用、数组、类类型，等等。

static数据成员**必须在类定义体的外部定义（正好一次）**。不像普通数据成员，static成员不是通过类构造函数进行初始化，而是**应该在定义时进行初始化**。

##### 特殊的整型const static 成员

一般而言，类的static成员，像普通数据成员一样，不能在类的定义体中初始化。这个规则的一个例外是，只要初始表达式是一个常量表达式，整型const static数据成员就可以在类的定义体中进行初始化：

```c++
class Account {
private:
    static const int period = 30;
};
```

用常量值初始化的整型const static数据成员是一个常量表达式。同样地，它可以用在任何需要常量表达式的地方，例如，指定数组成员daily_tbl的维数。

##### static成员不是类对象的组成部分

普通成员都是给定类的每个对象的组成部分。static成员独立于任何对象而存在，不是类类型对象的组成部分。因为static数据成员不是任何对象的组成部分，所以它们的使用方式对于非static数据成员而言是不合法的。

例如，static数据成员的类型可以是该成员所属的类类型。非static成员被限定声明为其自身类对象的指针或引用：

```c++
class Bar {
public:
    // ...
private:
    static Bar mem1; // 正确
    Bar* mem2; // 正确
    Bar mem3; // 错误
};
```

## 8、复制控制

### 复制构造函数

是一种特殊构造函数，具有**单个形参**，该形参（常用const修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。当将该类型的对象传递给函数或从函数返回该类型的对象时，将隐式使用复制构造函数。

#### 对象的定义形式

直接初始化和复制初始化。复制初始化使用=符号，而直接初始化将初始化式放在圆括号中。

当用于类类型对象时，初始化的复制形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，复制构造函数总是调用复制构造函数。复制初始化首先使用指定构造函数创建一个临时对象，然后用复制构造函数将那个临时对象复制到正在创建的对象。

**对于类类型对象，只有指定单个实参或显式创建一个临时对象用于复制时，才使用复制初始化。**

#### 形参与返回值

当形参为非引用类型的时候，将复制实参的值。类似地，**以非引用类型作返回值时，将返回return语句中的值的副本**。

当形参或返回值为类类型时，由复制构造函数进行复制。

#### 禁止复制

有些类需要完全禁止复制。例如，iostream类就不允许复制。为了防止复制，类必须显式声明其复制构造函数为private。**如果复制构造函数是私有的，将不允许用户代码复制该类类型的对象，编译器将拒绝任何进行复制的尝试**。

然而，类的友元和成员仍可以进行复制。如果想要连友元和成员中的复制也禁止，就可以声明一个（private）复制构造函数但不对其定义。

### 赋值操作符

#### 重载赋值

存在操作符是一些函数，其名字为operator后跟着所定义的操作符的符号。因此，通过定义名为operator=的函数，我们可以对赋值进行定义。像任何其他函数一样，操作符函数有一个返回值和一个形参表。形参表必须具有与该操作符操作数数目相同的形参（如果操作符是一个成员，则包括隐式this形参）。**赋值是二元运算，所以该操作符函数有两个形参：第一个形参对应着左操作数，第二个形参对应右操作数**。

大多数操作符可以定义为成员函数或非成员函数。**当操作符为成员函数时**，**它的第一个操作数隐式绑定到this指针**（所以此时就不需要显式声明作为左操作数的形参了）。有些操作符（包括赋值操作符）必须是定义自己的类的成员。因为赋值必须是类的成员，所以**this绑定到指向左操作数的指针。因此，赋值操作符接收单个形参，且该形参是同一个类类型的对象。右操作数一般作为const引用传递**。

```c++
class Sales_item {
public:
    Sales_item& operator=(const Sales_item&);
};
```



赋值操作符的返回类型应该与内置类型赋值运算返回的类型相同。内置类型的赋值运算返回对右操作数的引用，因此，赋值操作符也返回对同一类类型的引用。

### 析构函数

当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。析构函数可用于释放对象时构造函数或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非static数据成员的析构函数。

构造函数的一个用途是自动获取资源。例如，构造函数可以分配一个缓冲区或打开一个文件，在构造函数中分配了资源之后，需要一个对应操作自动回收或释放资源。析构函数就是这样的一个特殊函数，它可以完成所需的资源回收，作为类构造函数的补充。

#### 何时调用析构函数

撤销类对象时会自动调用析构函数。

当对象的引用或指向对象的指针超出作用域时，不会运行析构函数。只有删除指向动态分配对象的指针或实际对象（而不是对象的引用）超出作用域时，才会运行析构函数。

析构函数与复制构造函数或复制操作符之间的一个重要区别是，即时我们编写了自己的析构函数，合成析构函数仍然运行。例如，给下面的`Sales_item`类编写如下的空析构函数：

```c++
class Sales_item {
public:
    ~Sales_item() {}
}
```

当撤销`Sales_item`类型的对象时，将先运行这个什么也不做的析构函数，它执行完毕后，将运行编译器生成的默认的析构函数以撤销类的成员。

## 9、重载操作符与转换

### 重载操作符的定义

重载操作符是具有特殊名称的函数：保留字operator后接需要定义的操作符符号。像任意其他函数一样，重载操作符具有返回类型和形参表，如下语句：

```c++
Sales_item operator+(const Sales_item&, const Sales_item&);
```

声明了加号操作符，可用于将两个`Sales_item`对象“相加”并获得一个`Sales_item`对象的**副本**。

#### 重载操作符必须具有一个类类型操作数

重载操作符必须具有至少一个类类型或枚举类型的操作数。这条规则强制**重载操作符不能重新定义用于内置类型对象的操作符**的含义。

#### 优先级和结合性是固定的

操作符的优先级、结合性或操作数数目不能改变。不管操作数的类型和操作符的功能定义如何，表达式：

```c++
x == y + z;
```

总是将实参y和z绑定到operator+，并且将结果用作operator==的右操作数。

#### 类成员与非成员

大多数重载操作符可以定义为普通非成员函数或类的成员函数。

注意：作为类成员的重载函数，其形参看起来比操作数数目少1。**作为成员函数的操作符有一个隐含的this形参，限定为第一个操作数**。重载一元操作符如果作为成员函数就没有（显式）形参，如果作为非成员函数就有一个形参。类似地，重载二元操作符定义为成员时有一个形参，定义为非成员函数时有两个形参。

一般将算术和关系操作符定义为非成员函数，而将赋值操作符定义为成员：

```c++
Sales_item& Sales_item::operator+=(const Sales_item&); // 成员函数
```

```c++
Sales_item operator+(const Sales_item&, const Sales_item&); // 非成员函数
```

复合赋值返回一个引用而加操作符返回一个`Sales_item`对象，这也没什么。当应用于算术类型时，这一区别与操作符的返回类型相匹配：加返回一个右值，而复合赋值返回对左操作数的引用。

#### 操作符重载和友元关系

操作符定义为非成员函数时，通常必须将它们设置为所操作类的友元。

#### 使用重载操作符

非成员函数：

```c++
item1 + item2; // 会隐式调用operator+
```

也可以显式调用：

```c++
operator+(item1, item2);
```

成员函数：

```c++
item1 += item2; // 隐式调用operator+=
```

也可以显式调用：

```c++
item1.operator+=(item2);
```

两个语句都将item2的值加至item1。

### 重载操作符的设计

赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）等操作符必须定义为成员，将这些操作符定义为非成员函数将在编译时标记为错误。

改变对象状态或与给定类型紧密联系的其他一些操作符，如自增、自减和解引用，通常定义为类成员。

对称的操作符，如算术操作符、相等操作符、关系操作符和位操作符，最好定义为普通非成员函数。

### 输入和输出操作符

#### 输出操作符<<的重载

为了与IO标准库一致，操作符应接受`ostream&`作为第一个形参，对类类型`const`对象的引用作为第二个形参，并返回对`ostream`形参的引用。

重载输出操作符一般的简单定义如下：

```c++
ostream& operator<<(ostream& os, const ClassType& object) {
    /* some codes */
    os << // ...
    
    return os;
}
```

第一个形参是对`ostream`对象的引用，在该对象上将产生输出。`ostream`为非`const`，因为写入到流会改变流的状态。该形参是一个引用，因为不能复制`ostream`对象。

#### IO操作符必须为非成员函数

我们不能将IO操作符定义为类的成员，否则，左操作数将只能是该类类型的对象。

## 10、面向对象编程与泛型编程

### 派生类和虚函数

尽管不是必须这样做，派生类一般会重定义所继承的虚函数。如果派生类没有重定义某个虚函数，则使用基类中定义的版本。

派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外：返回对基类型的引用（或指针）的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用（或指针）。例如，基类`Item_base`可以定义返回`Item_base*`的虚函数，如果这样，子类`Bulk_item`中定义的实例可以为返回`Item_base*`或`Bulk_item*`。（因为派生类对象拥有基类部分）

**一旦函数在基类中声明为虚函数，它就一直为虚函数，派生类无法改变该虚函数为虚函数这一事实**。所以，派生类重定义虚函数时，可以使用`virtual`保留字，但不是必须这样做。

### virtual与其他成员函数

C++中的函数调用默认不使用动态绑定。要触发动态绑定，必须满足两个条件：第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定；第二，必须通过基类类型的引用或指针进行函数调用。

因为可以使用基类类型的指针或引用来引用派生类类型的对象，所以，使用基类类型的引用或指针时，不知道指针或引用所绑定的对象的类型：

### 可以在运行时确定virtual函数的调用

将基类类型的引用或指针绑定到派生类对象对基类对象没有影响，**对象本身不会改变，仍为派生类对象**。

通过基类引用或指针调用基类中定义的函数时，如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定的或指针所指向的对象所属类型定义的版本。

### 公用、私有和受保护的继承

每个类控制它所定义的成员的访问。**派生类可以进一步限制但不能放松对所继承的成员的访问**。

### 友元关系与继承

友元关系不能继承。基类的友元对派生类的成员没有特殊访问权限。如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系的类（也就是说，友元函数不能随便访问派生类。每个类控制对自己的成员的友元关系）。





































































































































































