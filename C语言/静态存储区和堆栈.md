# 静态存储区和堆栈

## 一个例子

下面的例子说明指针和数组的区别：

```c++
char* p = "Hello World1"; 
char a[] = "Hello World2";
p[2] = 'A';
a[2] = 'A';

char* p1 = "Hello World1";
```

这个程序是有错误的，错误发生在`p[2] = 'A'`这行代码处，为什么呢？

我们知道指针变量p和变量数组a都存在于栈区的（任何临时变量都是处于栈区的，包括在main()函数中定义的变量）。

因为数据“Hello  World2”存在于数组中，所以，此数据**存储于栈区**，对它修改是没有任何问题的。因为指针变量p仅仅能够存储某个存储空间的地址，数据“Hello  World1”为字符串常量，所以存储在**静态存储区**。

虽然通过p[2]可以访问到静态存储区中的第三个数据单元，即字符`'l'`所在的存储的单元。但是因为 数据“Hello  World1”为**字符串常量**，不可以改变（只读），所以在程序运行时，会报告内存错误。如果此时对p和p1输出的时候会发现**p和p1里面保存的地址是完全相同的**。换句话说，在**数据区只保留一份相同的字符串常量数据**。

## 基础知识

![](http://oklbfi1yj.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E5%92%8C%E5%A0%86%E6%A0%88/1.png)

### 1、静态存储区（全局区）（static）    

初始化数据段与非初始化数据段。

**全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域**。程序结束后**由系统释放**。

**BSS段：非初始化数据段。**BSS段（bss segment，可以理解为better save space<更节省空间>）通常是指用来**存放程序中未初始化的全局变量的一块内存区域**。BSS是英文Block Started by Symbol的简称。**BSS段属于静态内存分配**。【定义而没有赋初值的全局变量和静态变量,放在这个区域】



**数据段：**数据段（data segment）通常是指用来**存放程序中已初始化的全局变量的一块内存区域**。**数据段属于静态内存分配**。【**在编译阶段(而非运行时)就能确定**的数据,可读可写】

### 2、文字常量区（正文段/代码段）

这块区域的数据是**只读**的。

字符串常量就是放在这里的，程序结束后由系统释放。并且编译器可能会将字符串常量优化成一个地方:

```c++
#include <iostream>
#include <string.h>

using namespace std;

int main(int argc, char const *argv[])
{
	const char* p1;
	const char* p2;
	p1 = "123";
	p2 = "123";

	printf("p1: %p, p2: %p\n", p1, p2);
}
```

结果：

![](http://oklbfi1yj.bkt.clouddn.com/%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E5%92%8C%E5%A0%86%E6%A0%88/2.PNG)

**代码段：**代码段（code segment/text segment）通常是指**用来存放程序执行代码的一块内存区域**。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。**在代码段中，也有可能包含一些只读的常数变量，例如字符串常量**等。

总结起来就是：放程序代码的、**编译时确定**、只读。

### 3、栈区（stack）

属于动态数据区。

`Stack Pointer`会自动指引你到放东西的位置,你所要做的只是把东 西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁。

需要注意的是，在分配的时候，比如为一个即将要调用的程序模块分配数据区时，应事先知道这个数据区的大小，也就说是**虽然分配是在程序运行时进行的，但是分配的大小多少是确定的，不变的，而这个" 大小多少"是在编译时确定的，不是在运行时**。

### 4、堆区

属于动态数据区。

堆是应用程序在**运行的时候**请求**操作系统分配**给自己内存。由于是操作系统管理内存分配的工作，所以在分配和销毁时都要占用时间，因此用堆的效率更低。但是**堆的优点在于，编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间**，因此，用堆保存数据时会得到更大的灵活性。

#### 申请方式

```c++
p1 = (char *)malloc(10);
或者
p2 = new char[20];
```

**注意p1、p2本身是在栈中的**，但是分配的空间是在堆中的，也就是说，p1和p2所指向的地方在堆中。

首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，**会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间**。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

事实上，针对面向对象，堆内存分配是必不可少的，因为对象变量所需的存储空间只有在运行时创建了对象之后才能确定。在C++中，要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！这也正是导致效率低的原因。































